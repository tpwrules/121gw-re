/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2014 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __fastcall update_display();
void __fastcall scr_update_with_new_meas();
void __fastcall log_playback_show_sample(unsigned __int16 sample); // idb
void __fastcall scr_show_num(meter_meas_mode mode, unsigned __int8 point, int num);
void __fastcall scr_set_decimal_point(unsigned __int8 decimals);
void __fastcall scr_update_decimal_point();
void scr_refresh_meas_units_and_icons(void);
void __fastcall scr_update_status_icons();
void __fastcall scr_update_units(meter_meas_mode mode, unsigned __int8 range, char f_lowz_ac, unsigned __int8 f_lowz_active);
void __fastcall scr_update_milli_for_VA(meter_meas_mode mode, unsigned __int8 range);
void scr_update_for_playback();
void scr_update_units_in_certain_modes(void);
void __fastcall scr_update_cap_units(unsigned __int8 range);
void __fastcall scr_update_ohm_units(unsigned __int8 range);
void __fastcall scr_update_hz_units(unsigned __int8 range);
void __fastcall update_subscr();
void __fastcall subscr_show_num(int num, unsigned __int8 point, char update_now);
void subscr_show_ac_input_hz(void);
void __fastcall subscr_set_decimal_point(unsigned __int8 decimals);
void subscr_calc_power_amp_point();
void set_point_for_ac_input_hz(void);
unsigned __int8 __fastcall calc_point_for_ac_hz(unsigned __int8 a1);
void erase_part_of_screen_in_order_to_blink_value_being_edited(void);
void __fastcall subscr_show_digits(int digits);
void __fastcall subscr_disp_burden_voltage(signed int meas, char a2);
void __fastcall show_burden_msg();
void __fastcall show_batt_charge(signed __int16 percent);
void __fastcall show_contrast(char contrast);
void __fastcall show_apo_status(char is_off);
void __fastcall show_logging_interval(unsigned __int16 interval);
void __fastcall subscr_show_dBm();
void __fastcall show_burden_display_status(char on);
void show_diode_voltage();
void __fastcall show_continuity_threshold(unsigned __int8 threshold);
void __fastcall show_year_on_subscreen(char update_now, unsigned __int8 year_offset);
void __fastcall show_two_nums_on_subscreen(char update_now, unsigned __int8 left, unsigned __int8 right);
void __fastcall show_two_nums_on_subscreen_with_dash(char update_now, unsigned __int8 left, unsigned __int8 right);
void __fastcall show_hour_min_on_subscr(char update_now); // idb
void __fastcall show_meter_serial(char update_now); // idb
void __fastcall show_temperature(__int16 measurement);
__int16 __fastcall convert_temp_and_round(signed __int16 a1);
void update_bargraph_if_in_appropriate_range(void);
void __fastcall scr_update_bargraph();
void calc_bargraph_pos_for_mode(void);
void __fastcall calc_bargraph_pos(char range);
void __fastcall scr_update_bargraph_range(char a1);
void __fastcall scr_update_bargraph_range_5s(unsigned __int8 bargraph_range_in);
void scr_reset_bargraph();
void scr_turn_off_bargraph(void);
void __fastcall scr_clear_bargraph_bars(unsigned __int8 end, char start);
void __fastcall show_cal_msg_countdown(unsigned __int8 a1);
void __fastcall show_cal_msg_end(unsigned __int8 a1);
void __fastcall show_sdcal_msg();
void __fastcall show_sdsav_msg();
void __fastcall show_sdset_msg();
void __fastcall show_sd_cal_success();
void __fastcall show_sd_cal_err();
void __fastcall show_cal_mode_msg();
void show_cal_mode_msg_on_subscr();
void __fastcall show_low_batt();
void __fastcall show_msg_logging_ended();
void __fastcall show_sd_error(unsigned __int8 error);
void __fastcall show_overload(char on_subscr); // idb
void __fastcall show_temp_error(char on_subscr);
void __fastcall show_lead_err(char on_subscr);
void scr_erase(char subscr);
void __fastcall put_msg_on_scr(char on_subscr, char *msg);
void __fastcall put_chr_on_scr_at_offset(unsigned __int8 where, unsigned __int8 *chr);
void __fastcall put_2_chrs_on_scr_at_offset(unsigned __int8 offset, unsigned __int8 *a2);
void __fastcall scr_turn_off_units();
void __fastcall scr_update_apo_status(char update_now); // idb
void __fastcall scr_update_low_batt_icon(char update_now); // idb
void __fastcall scr_update_bt_icon(char update_now); // idb
void __fastcall scr_update_autorange_icon(char update_now); // idb
char determine_if_autoranging(void);
void __fastcall scr_update_min_max_icons(char update_now); // idb
void __fastcall scr_update_rel_meas_icon(char update_now);
void __fastcall scr_update_hold_icons(char update_now);
char hold_get_status();
void __fastcall scr_update_1ms_peak_icon(char update_now); // idb
void __fastcall scr_update_lpf_icon();
void scr_update_main_acdc_icons();
void __fastcall scr_update_mem_icon(char update_now); // idb
void scr_update_danger_icon();
void scr_update_temp_unit();
void __fastcall subscr_update_units();
void subscr_set_power_amp_units(void);
void subscr_turn_off_units();
void lcd_turn_off_all_segments();
void __cdecl show_firmware_version();
void __cdecl lcd_turn_on_all_segments();
void __fastcall set_7seg(unsigned __int8 chr, unsigned __int8 where);
unsigned __int8 __fastcall ascii_to_segs(unsigned __int8 chr);
void __fastcall conv_uint_to_bcd_tmp(unsigned int num);
void __fastcall conv_bcd_tmp_to_scr(unsigned __int8 decimal_place);
void update_lcd_if_appropriate();
void __fastcall lcd_init(unsigned __int8 contrast, char blank); // idb
void __fastcall gpio_config_lcd_pins();
void __fastcall lcd_set_contrast(unsigned __int8 contrast); // idb
void maybe_refresh_lcd_contrast_register();
unsigned __int8 __fastcall read_eeprom_byte_also(int loc); // idb
void __fastcall try_to_write_byte_10_times_also_also(int loc, unsigned __int8 data);
void __cdecl log_prepare_sample();
void __cdecl log_prepare_sample_main_measurement();
void __fastcall logging_begin();
void __fastcall logging_end(char flush_samples); // idb
void __fastcall log_save_sample();
void save_eeprom_sample_count();
void load_eeprom_sample_count();
void log_calc_playback_window();
unsigned __int16 __fastcall log_get_eeprom_idx_for_sample(unsigned __int16 sample);
void __fastcall write_logged_meas_mode_and_range_to_eeprom();
void read_logged_meas_mode_range_from_eeprom(void);
void __fastcall set_log_start_time_and_write_to_eeprom_badly();
void __fastcall load_log_start_time_from_eeprom_badly();
void __fastcall set_log_end_time_and_write_start_time_to_eeprom_badly();
void __fastcall load_log_end_time_from_eeprom_badly();
void __fastcall log_write_sample_to_eeprom(unsigned __int16 a1);
void __fastcall log_read_sample_from_eeprom(unsigned __int16 sample);
void load_curr_year_month();
void __fastcall save_last_cal_year_month();
void load_meter_serial();
void save_meter_serial(void);
meter_meas_mode __fastcall get_last_mode_v();
meter_meas_mode get_last_mode_mv(void);
meter_meas_mode get_last_mode_hz(void);
meter_meas_mode get_last_mode_ohms(void);
meter_meas_mode get_last_mode_pwr(void);
meter_meas_mode get_last_mode_uA(void);
meter_meas_mode get_last_mode_A(void);
void __fastcall write_curr_meas_mode_with_a_lockout_or_something(unsigned __int8 a1, char a2);
void __fastcall save_curr_meas_mode();
void load_logging_interval();
void __fastcall save_logging_interval(__int16 a1);
void load_lcd_contrast();
void __fastcall save_lcd_contrast(unsigned __int8 a1);
void load_curr_apo_status();
void __fastcall save_curr_apo_status(unsigned __int8 a1);
void load_temp_mode();
void __fastcall save_curr_temp_unit(unsigned __int8 a1);
void load_hv_diode_mode();
void __fastcall save_diode_voltage(unsigned __int8 a1);
void load_curr_cont_threshold();
void __fastcall save_curr_continuity_threshold(unsigned __int8 threshold);
void load_burden_display_enabled();
void __fastcall save_burden_enabled_for_power_ranges(unsigned __int8 a1);
void __fastcall cal_load_amp_rel(meter_meas_mode mode, char range);
void __fastcall cal_save_amp_rel(meter_meas_mode mode, char range, int rel);
void __fastcall cal_erase_amp_rel_data();
int __fastcall calc_amp_rel_eeprom_addr(int mode);
int *__fastcall get_cal_factor_addr();
unsigned __int16 *__fastcall get_ac_cal_data_addr(meter_meas_mode mode, char range);
void __fastcall cal_load_factors_for_mode_and_range(meter_meas_mode mode, unsigned __int8 range);
void __cdecl cal_ohms_50M_offset_factor_validate();
void cal_load_va_factors(void);
void __fastcall cal_validate_ac_factor(unsigned int which);
void cal_load_ac_factors(void);
void __fastcall cal_write_factor(char factor, signed int val);
void __fastcall cal_save_va_factors(char cal_gain);
void __fastcall cal_save_ac_factor(meter_meas_mode mode, char range, char which);
void cal_erase_ac_factors(void);
unsigned int __fastcall read_eeprom_4byte(int loc);
int __fastcall read_eeprom_2byte_signed(int loc); // idb
unsigned __int16 __fastcall read_eeprom_2byte(int loc);
unsigned __int8 __fastcall read_eeprom_byte(int loc);
unsigned __int8 __fastcall read_eeprom_byte_core(int loc);
void __fastcall write_eeprom_4byte(int loc, signed int val);
void __fastcall write_eeprom_2byte(int loc, __int16 val);
void __fastcall try_to_write_byte_10_times_also(int loc, int data);
int __fastcall write_eeprom_byte_without_first_erasing(int loc, unsigned __int8 data); // idb
void __fastcall try_to_write_byte_10_times(int loc, unsigned __int8 data);
void __fastcall bt_echo_rx_msg();
void __fastcall bt_process_received_msg();
unsigned __int8 __fastcall read_hex_digit_from_bt_rx_msg(unsigned __int8 pos);
void update_bt_power();
void write_time_and_serial_to_bt_buf(void);
void build_and_write_bt_packet_also(void);
void build_and_write_bt_packet();
void __fastcall bt_write_temp_sub(unsigned __int8 loc);
void __fastcall bt_write_battery_sub(unsigned __int8 loc);
void __fastcall bt_write_apo_sub(unsigned __int8 loc);
void __fastcall bt_write_lcd_sub(unsigned __int8 loc);
void __fastcall bt_write_year_sub(unsigned __int8 loc);
void __fastcall bt_write_month_day_sub(unsigned __int8 loc);
void __fastcall bt_write_hour_minute_sub(unsigned __int8 loc);
void __fastcall bt_write_spl1_sub(unsigned __int8 loc);
void __fastcall bt_write_spl2_sub(unsigned __int8 loc);
void __fastcall bt_write_spl3_sub(int loc);
void __fastcall sub_800D3DE(unsigned __int8 a1, char a2);
void __fastcall bt_write_hz_sub(unsigned __int8 a1, char a2, int a3, int a4);
void __fastcall bt_write_power_volts(unsigned __int8 a1, unsigned __int8 a2);
void __fastcall bt_write_power_amps(unsigned __int8 loc, unsigned __int8 a2);
void __fastcall bt_write_burden_sub();
void __fastcall bt_write_no_sub(unsigned __int8 loc);
void __fastcall write_hex_2bytes_to_bt_buf(unsigned __int8 loc, int val);
void __fastcall write_hex_byte_to_bt_buf(unsigned __int8 pos, unsigned __int8 num);
unsigned __int8 __fastcall hex_digit_to_ascii(char digit);
void __fastcall usart_write_byte(USART_REGS *USART, unsigned __int8 data);
void end_setup_without_saving_after_2min_timeout(void);
void __fastcall meter_process_range_mode_changed(char should_stop_logging);
void __cdecl update_max_digits_in_range();
void __cdecl subscr_periodically_switch_between_amps_and_volts_for_power();
void __cdecl subscr_update_power_amps_or_volts_display();
void meter_set_default_subscr_mode();
void __fastcall meas_prepare_for_new_mode_range(unsigned __int8 should_load_cal_factors);
void __fastcall meas_config_hy_and_load_cal_factors(char should_load_factors);
void __fastcall update_stuff_based_on_new_power_range();
signed int __fastcall calc_decimal_place_for_mode_range(meter_meas_mode mode, unsigned int range);
void __fastcall meter_set_mode_range_change_delay();
void meter_process_new_meas(void);
void meter_process_autorange();
void __fastcall meter_process_hold();
void __fastcall meter_process_rel_meas();
void __fastcall meter_process_min_max();
void meter_process_overload();
bool __fastcall is_abs_out_of_range(bool num, int range);
void __cdecl finish_sys_init_and_handle_boot_buttons();
void meas_cap_reset_no_reading_timeout_timer();
void __fastcall spinloop(unsigned int amount);
void __fastcall SysTick_Handler_real();
void reset_apo_timeout();
void __fastcall hy_change_CTA_val_for_ac_freq();
void __cdecl beep_contentedly();
void beep_excitedly();
void __fastcall beep_angrily();
void __fastcall beep_and_reset_apo_timeout_if_asked(char should_reset_apo_timeout, char num, __int16 ms); // idb
void __fastcall beep_ms(unsigned __int16 ms);
int __fastcall meas_apply_offset_adj(int a1);
int __fastcall cal_update_curr_offset_accu(int a1);
int __fastcall cal_update_cap_offset_accu(unsigned int a1);
int __fastcall cal_update_ac_offset_accu(int a1);
signed int __fastcall cal_prepare_ac_factor_calibration(char cal_gain); // idb
int __fastcall meas_perform_offset_adj(int a1);
int __fastcall meas_perform_offset_adj_ac(int a1);
int __fastcall meas_apply_gain_adj(int a1);
int __fastcall meas_perform_gain_adj(int a1);
int __fastcall cal_update_curr_gain_accu(int num); // idb
float __cdecl meas_get_gain_adj();
void __fastcall cal_update_cap_gain_accu(unsigned int gain, int last_offset); // idb
void __fastcall cal_update_ac_gain_accu(int num, int offset);
void __fastcall cal_ac_factor_update_and_save(char a1, int a2);
void __fastcall cal_calc_gain_from_gain_accu();
void __fastcall cal_set_curr_gain_div_by_n(float a1, float num);
void __fastcall cal_set_curr_gain_div_by_50000();
void __fastcall call_set_curr_gain_div_by_30000();
void __fastcall cal_set_curr_gain_div_by_10000();
void __fastcall cal_set_curr_gain_div_by_6000();
void cal_set_curr_gain_div_by_42426(void);
void __fastcall meas_setup_hw(meter_meas_mode mode, char range);
void __fastcall meas_hw_set_ac_rms_filter_ctl(meter_meas_mode mode);
void __fastcall meas_hw_set_hv_diode(meter_meas_mode mode);
void __fastcall meas_hw_set_va_ctl_useless(meter_meas_mode mode);
void __fastcall meas_hw_set_temp_ctl(meter_meas_mode mode);
void __fastcall meas_hw_set_fre_ctl(meter_meas_mode mode);
void meas_hw_turn_on_4V_supply();
void __fastcall meas_hw_set_amp_amplifier_power(meter_meas_mode mode);
void __fastcall meas_hw_set_amp_x10(meter_meas_mode mode, char range);
void rtc_read_time();
unsigned __int8 __fastcall bcd2_to_int(unsigned __int8 bcd);
unsigned __int8 __fastcall int_to_bcd2(unsigned __int8 a1);
void rtc_write_time();
void __fastcall rtc_write_reg(RTC_REGS loc, unsigned __int8 data);
_BYTE __fastcall rtc_read_reg(RTC_REGS loc);
void __fastcall rtc_send_reg_number(RTC_REGS loc);
_BYTE rtc_recv_data();
void __fastcall rtc_send_data(unsigned __int8 data); // idb
void rtc_select_chip();
void rtc_deselect_chip();
void rtc_config_data_output();
void rtc_config_data_input();
unsigned __int8 __fastcall get_days_in_month_without_going_over(unsigned __int8 year, unsigned __int8 month, unsigned __int8 curr_day);
unsigned __int8 __fastcall get_days_in_month(unsigned __int8 year, unsigned __int8 month);
void __cdecl fp_compare_c_ge(float a, float b);
void __fastcall fp_compare_c_le(float a, float b);
unsigned int __fastcall fp_to_uint(float a1);
float __fastcall fp_mul(float a, float b);
void __cdecl check_on_batt_and_internal_temp();
void read_batt_level();
unsigned int __fastcall batt_level_avg(int a1);
void batt_level_avg_sort_buf();
int __fastcall batt_level_adjust(unsigned int a1);
int __fastcall prob_read_adc1_ch(char a1);
void __cdecl prob_read_internal_temp();
void __fastcall calc_internal_temp(__int16 adc);
int __fastcall calc_internal_temp_core(unsigned __int16 a1);
int __fastcall temp_conv_c_to_f(int a1);
void __fastcall meas_calc_temp_from_dcmv(int dcmv);
void __fastcall temp_load_offset(int temp_is_negative, signed int a2);
void init_adc_and_stuff();
void __fastcall lcd_set_fcr_and_cr(int a1);
void __fastcall lcd_set_enable(unsigned __int8 result);
void __fastcall lcd_wait_for_FCR_sync();
void __fastcall lcd_set_segment_multiplexing(unsigned __int8 result);
void __fastcall lcd_set_pulse_on_duration(int result);
void __fastcall lcd_set_dead_time(int result);
void __fastcall lcd_set_blink(int result, int a2);
void __fastcall lcd_set_contrast_reg(int contrast);
void set_lcd_update_request();
bool __fastcall read_lcd_sr(int mask); // idb
void apo_config_rcc();
void __fastcall set_hse_bits(_BYTE bits);
bool wait_for_hse_ready();
void __fastcall set_MSI_range(int mask);
void __fastcall set_HSI_ON(int result);
void __fastcall set_lse_bits(char result);
void __fastcall set_RCC_LSION(unsigned __int8 result);
void __fastcall set_system_clock_source(int result);
int read_RCC_curr_clock_source(void); // weak
void __fastcall get_sys_clock_info(_DWORD *info);
void __fastcall set_internal_rtc_and_lcd_clocksource(int result);
void __fastcall set_RCC_CSR_RTCEN(unsigned __int8 val);
void __fastcall set_RCC_CSR_RTCRST(unsigned __int8 val);
void __fastcall set_AHB_periph_clk(int mask, char enable);
void __fastcall set_APB2_periph_clock(int mask, char enable);
void __fastcall set_APB1_periph_clock(int mask, char enable);
void __fastcall reset_apb2_periph(int mask, char reset);
bool __fastcall read_clock_ready_bit(unsigned __int8 a1);
void __fastcall sub_8011450(int result);
void config_clock_interrupts_and_gpio();
void __fastcall set_clocks_and_power_periphs(char use_hse);
void __fastcall enable_internal_rtc_and_lcd_clk();
void power_all_gpio_banks();
void __fastcall power_off_all_gpio_banks();
void probably_something_with_interrupts();
void __fastcall gpio_config_meter_hardware();
void __fastcall gpio_config_switch_button_inputs(unsigned __int8 except_this_range_switch_input);
void __fastcall gpio_config_jack_detector_inputs();
void __cdecl bt_powerup();
void gpio_config_analog_inputs();
void __fastcall config_TIM2();
void __fastcall config_TIM3();
void apo_prepare_to_turn_off(void);
void apo_unset_gpios(void);
void __fastcall apo_something_with_rangeswitch();
__int64 __fastcall sub_8011D04(unsigned __int8 a1, int a2, int a3, int a4);
int __fastcall sub_8011D66(int result);
unsigned __int32 __fastcall one_hot_16bit(signed int result);
unsigned __int8 __fastcall identity_if_lt_16(unsigned __int8 result);
void __cdecl apo_sleep_HY();
void __fastcall lcd_shutdown();
void apo_disable_timers();
void __cdecl bt_shutdown();
void __cdecl powerdown_adc1();
void disable_PWR_voltage_detector();
void __fastcall apo_config_rcc_power_stuff();
void __fastcall apo_something_with_power();
void __fastcall apo_disable_oscillators();
void __fastcall apo_power_off_gpio();
void __fastcall gpio_config_pin(GPIO_REGS *GPIO, GPIO_CONFIG *cfg);
void __fastcall gpio_clear_config(GPIO_CONFIG *cfg);
void __fastcall set_gpio_pin_func(GPIO_REGS *GPIO, unsigned __int16 pin, unsigned __int8 func);
_DWORD *__fastcall sub_8012216(_DWORD *a1);
void cal_save_to_sd(void);
int cal_load_from_sd(void); // weak
int __fastcall sub_8012608(unsigned __int8 a1);
int log_flush_samples_from_eeprom(void);
signed int log_try_flush_samples_from_eeprom();
int log_file_open_and_seek();
void __fastcall log_start_new_link();
int __fastcall log_file_create(char a1, unsigned __int8 a2);
int __fastcall log_file_get_name_then_create(unsigned __int8 a1);
int __fastcall maybe_find_last_log_file_chain_link(int a1);
void __fastcall log_file_name_add_chain_link_num();
void __fastcall log_file_build_name(signed int result);
int log_write_samples_to_file(void); // weak
void __fastcall log_file_prepare_to_write_next_sample();
void __fastcall sub_8012E4A();
void __fastcall sub_8012EBC();
void __fastcall sub_8012F30();
int *sub_8012F68();
bool __fastcall log_file_write_sample(unsigned __int16 sample_idx); // idb
int __fastcall f_get_len(void *a1);
bool __fastcall log_write_num_then_comma(int a1);
int __fastcall log_write_mode(meter_meas_mode mode); // idb
signed int __fastcall log_write_unit(meter_meas_mode mode, unsigned __int8 range);
int log_file_write_header_lines();
bool log_file_write_header_line4();
bool log_file_write_header_line5();
bool log_file_write_header_line2();
bool log_file_write_header_line1();
bool log_write_footer();
bool log_file_write_header_line3();
int __fastcall log_write_measurement(meter_meas_mode mode, unsigned __int8 range, int a3);
signed int __fastcall write_log_token(LOG_TOKENS token, unsigned int num, unsigned __int8 point);
signed int __fastcall write_bytes_to_log_file_and_cache_them_too(char *bytes, unsigned __int16 count);
int log_file_reread_and_verify(void); // weak
char *__fastcall uint_to_ascii(unsigned int num);
char *__fastcall uint_to_ascii_with_point(unsigned int num, unsigned __int8 place); // idb
int __fastcall f_mount_tries(unsigned __int8 a1);
int sd_sub_8014B6E(void); // weak
bool sd_sub_8014BAA();
void read_amp_lead_pos_then_update();
void __fastcall meter_set_amp_leads_incorrect();
void update_mode_based_on_range_switch();
void __fastcall meter_incr_mode();
void meter_update_acv_dcv_mode();
void meter_enable_acv_dcv_mode();
void meter_incr_range(void);
void __fastcall calc_power_ranges(meter_meas_mode mode, unsigned int range);
unsigned __int8 __cdecl get_meas_range_from_power_ranges();
void read_range_switch_then_update(void);
void update_mode_based_on_range_switch_if_necessary();
void read_range_switch(void);
void update_range_switch_inputs(void);
void __fastcall bt_process_rxed_button();
void __fastcall update_based_on_pressed_buttons(meter_buttons mask);
void log_playback_mode_stop();
void meter_incr_subscr_mode(void);
bool __fastcall cal_can_be_done(char cal_gain);
int __fastcall cal_start(char cal_gain); // idb
unsigned __int8 __fastcall cal_calc_countdown_timer();
void __fastcall meas_enable_auto_hold(char should_enable_holding, char was_called_when_logging_started);
void meter_incr_min_max_mode(void);
void __fastcall meter_enable_min_max_mode();
void __fastcall change_diode_voltage();
void __fastcall change_apo_status(char direction);
void __fastcall change_logging_interval(char direction);
void __fastcall change_lcd_contrast(char direction);
void __fastcall change_temp_unit(char direction);
void __fastcall change_continuity_threshold(char direction);
void __fastcall change_year(char direction);
void __fastcall change_month_day(char direction);
void __fastcall change_hour_minute(char a1);
void __fastcall update_last_cal_year_month_and_save();
void __fastcall change_meter_serial(char button);
void __fastcall change_burden_enabled_for_current_ranges(char a1);
void __fastcall change_burden_enabled_for_power_ranges(char a1);
void __fastcall update_based_on_held_buttons(meter_buttons mask);
void __fastcall change_logging_enabled(char activated_with_hold_held);
int __fastcall setup_menu_button_pressed(char button);
void __fastcall read_buttons_then_update();
void __fastcall update_based_on_buttons();
void read_buttons(void);
void __fastcall button_auto_press_up_down(int activate);
int __fastcall button_hold_is_being_held_with_mem(meter_buttons a1); // idb
bool __fastcall exactly_one_range_is_active(unsigned __int8 range_switch_bits);
int __fastcall hold_and_mem_are_both_being_pressed(meter_buttons a1); // idb
int read_button_inputs(void); // weak
float __fastcall fp_from_int(int num);
float __fastcall fp_from_uint(unsigned int num);
float __fastcall fp_from_uint_core(int num);
_DWORD *__fastcall read_bss_table_and_zero(_DWORD *a1);
float __fastcall fp_div(float a, float b);
int __fastcall fp_to_int(float a1);
void unlock_data_eeprom();
void lock_data_eeprom(void);
int __fastcall try_write_byte_to_eeprom_without_first_erasing(int addr, char data); // idb
void unlock_option_bytes_and_data_eeprom(void);
void reload_option_bytes();
void __fastcall probably_reprogram_brownout_level_or_otherwise_init_options(int a1);
unsigned int get_brownout_level_from_option_bytes();
void __fastcall set_flash_sr(int value);
int get_flash_status();
int __fastcall wait_for_flash_to_not_be_busy(int how_long); // idb
unsigned int __fastcall config_usart(USART_REGS *USART, int a2);
void __fastcall set_usart_enable(USART_REGS *USART, char enable);
void __fastcall usart_write_data_reg(USART_REGS *USART, __int16 data);
int __fastcall sub_801798C(int a1);
void __fastcall set_usart_control_bit(USART_REGS *USART, unsigned __int8 a2, char a3);
bool __fastcall get_usart_status_bits(USART_REGS *USART, unsigned __int16 mask);
int __fastcall sub_8017A08(int a1, __int16 a2);
int __fastcall sub_8017A76(int result, __int16 a2);
void __fastcall hy_read_update_and_do_cap_stuff();
void __fastcall hy_read_regs_and_process_ints();
void hy_process_AD1_int(void);
int hy_get_AD1();
int __fastcall hy_add_to_AD1_avg(int ad1);
void __fastcall meas_calc_final_scr_digits();
void __fastcall meas_calc_bargraph_digits();
void __fastcall meas_process_lowz();
void meter_process_new_lowz_meas();
void set_lowz_acdc_switch_counter();
void __fastcall meas_process_ac_amps();
void __fastcall prepare_reading_ac_amps(char measuring_burden_voltage);
void __fastcall meas_process_ac_amps_core();
void __fastcall meas_display_ac_amps();
void __fastcall meas_process_acmv();
void __fastcall meas_display_acv_acmv();
void __fastcall meas_process_acv();
void __fastcall meas_apply_ac_freq_dependent_offset(meter_meas_mode mode);
void __fastcall cal_save_scr_to_ac_factor();
int __fastcall meas_calc_ac_freq_dependent_offset(unsigned __int8 range, signed int digits); // idb
void __fastcall meas_calc_acv_subscr_vals();
void __fastcall meas_process_dcv();
void __fastcall meas_process_dcmv();
void __fastcall meas_process_temp();
void __fastcall meas_process_continuity();
void __fastcall meas_do_continuity(unsigned int bargraph_digits);
signed int meas_calc_beep_threshold();
void __fastcall meas_process_ohms();
signed int __fastcall meas_ohms_calc_5M_offset(signed int a1);
int __fastcall meas_ohms_calc_50M_offset(int digits, int factor);
void __fastcall meas_process_diode();
void __fastcall meas_process_dc_amps();
void __fastcall prepare_reading_dc_amps(char measuring_burden_voltage);
void __fastcall meas_process_dc_amps_core();
void __cdecl hy_process_RMS_int();
int hy_read_rms_data_from_buf();
int __fastcall hy_update_rms_avg(int result);
int __fastcall meas_add_rolling_average_buf1(int num, int max_delta, unsigned __int16 averages); // idb
void __fastcall meas_calc_bargraph_digits_ac(int digits);
void __fastcall meas_process_dc_va();
void __fastcall meas_process_ac_va();
void __fastcall update_power_volts(signed int a1);
void __fastcall update_power_amps(signed int a1);
int __fastcall calc_va_subscr_digits(signed int a1, signed int a2);
void __cdecl rms_int_in_lowz_does_nothing();
void nullsub_1();
void __fastcall meas_acv_dcv_calc_next_mode(char dc);
void __fastcall meas_acv_dcv_switch_mode(char to_dc);
void __fastcall meas_acv_dcv_calc_distance_between_ac_and_dc_as_if_they_were_vectors_90_degrees_apart();
void __fastcall meas_calc_dBm();
int nullsub_2(void); // weak
int nullsub_3(void); // weak
void hy_process_peak_hold(void);
void __cdecl hy_process_CT_int();
void __cdecl hy_read_freq_counters_and_reset();
void __fastcall meas_process_hz(char for_ac_input, char ac_hz_range);
void __fastcall meas_calc_hz_digits(char for_ac_input, char range);
int meas_process_msec();
void __fastcall meas_set_msec_range_and_digits(int a1);
void __fastcall meas_process_duty();
void meas_process_cap();
void __cdecl meas_process_cap_autorange();
void __fastcall meas_calc_curr_freq();
void __fastcall meas_calc_msec();
void __cdecl meas_calc_duty();
void __fastcall cal_update_sysclk();
int __fastcall meas_add_rolling_average_buf2(int num, int max_delta, unsigned __int16 averages); // idb
int __fastcall meas_process_burden_volts(int result);
void __fastcall config_hy_based_on_mode_range(meter_meas_mode mode, unsigned __int8 range);
void __fastcall hy_set_regs_from_table(meter_meas_mode mode, unsigned __int8 range);
void __fastcall config_hy_intregs(meter_meas_mode mode);
void hy_reset_freq_counter();
void __fastcall send_data_to_hy3131(_BYTE *data, char address, unsigned __int16 count);
void __fastcall read_registers_from_hy3131(_BYTE *data, char, unsigned __int16 count);
unsigned __int8 recv_byte_from_hy3131();
void __fastcall send_byte_to_hy3131(unsigned __int8 data, char doing_read_of_register);
void pulse_hy3131_clock();
__int64 __fastcall int64_div(__int64 a, __int64 b);
unsigned __int64 __fastcall uint64_div(unsigned __int64 a, unsigned __int64 b);
int __fastcall meas_calc_ac_freq_dependent_offset_core(signed int digits, int decirange_factor, int fullrange_factor, int decirange_factor_lf, int fullrange_factor_lf, unsigned __int8 range, int ac_in_freq, unsigned __int8 ac_in_range); // idb
int __fastcall meas_calc_ac_freq_dependent_offset_core_for_ACV_5_50V(int digits, int decirange_factor, int fullrange_factor, int decirange_factor_lf, int fullrange_factor_lf, int range, int ac_in_hz); // idb
signed int __fastcall ac_input_freq_to_hz(unsigned int point, signed int num); // idb
void __cdecl fp_equals(float a, float b);
double __fastcall dp_from_fp(float num);
double __fastcall dp_add(double a, double b);
int __fastcall dp_to_int(double num);
int __fastcall dp_to_int_core(double a1);
double __fastcall dp_div(double a, double b);
float __fastcall fp_from_dp(double num);
void __fastcall reset_adc(ADC_REGS *adc);
void __fastcall do_lots_of_adc_config(ADC_REGS *adc, _BYTE *chan);
void __fastcall enable_adc(ADC_REGS *adc, char enable);
int __fastcall sub_801C894(int result, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4);
void __fastcall sub_801CA52(int result);
int __fastcall sub_801CA5C(int a1);
bool __fastcall and_bool_low16(_DWORD a1, unsigned __int16 a2);
int __fastcall sub_801CA7C(int a1, unsigned __int16 a2);
int __fastcall sub_801CAB0(int result, __int16 a2);
double __fastcall dp_mul(double a, double b);
float __fastcall fp_add(float a, float b);
float __fastcall fp_sub(float a, float b);
void __fastcall set_rtc_rcc_csr_access(unsigned __int8 enabled);
void __fastcall set_PWR_voltage_detector_enable(int result);
void __fastcall set_PWR_Vrefint_off_in_low_power_mode(int result);
void __fastcall set_most_pwr_cr_bits(int result);
void __fastcall WFI_or_WFE(int result, char a2);
bool __fastcall test_pwr_csr_bits(int mask); // idb
void __fastcall set_pwr_cr_bits_offset(int mask);
void __fastcall sub_801CE7C(int result, char a2);
void __fastcall set_SCB_AIRCR(int result);
int __fastcall sub_801CEAA(int result);
void __fastcall set_vtor_offset(int base, int offset);
void __fastcall TIM_Base_SetConfig(void *TIM, int *a2);
void __fastcall set_timer_enable(void *TIM, char enable);
int __fastcall sub_801CFBC(int result, __int16 a2, char a3);
void __fastcall TIM_clear_status_bits(void *TIM, __int16 mask);
void __fastcall apo_something_with_rtc(int result, char a2);
int __fastcall sub_801D030(unsigned int a1);
unsigned int __fastcall sub_801D07A(unsigned int result);
int __fastcall sub_801D0A8(int result, unsigned __int8 a2);
int __fastcall sub_801D0FC(int result);
bool __fastcall exti_int_pending(int mask); // idb
void __fastcall exti_ack_int(int mask);
void __fastcall memcpy(void *dest, void *src, int len);
void __fastcall memset(void *mem, char val, int len);
int __fastcall memcmp(char *dst, char *src, int len);
char __fastcall chr_in_str(char *str, char chr);
signed int __fastcall sub_801D222(int a1, int a2);
int __fastcall prob_sd_init_partition_table(int a1);
int __fastcall sub_801D372(int a1, int a2);
signed int __fastcall sub_801D38C(int a1, unsigned int a2);
int __fastcall sub_801D48A(int a1, unsigned int a2, unsigned int a3);
int __fastcall sub_801D5EE(int a1, unsigned int a2);
unsigned int __fastcall sub_801D660(int a1, unsigned int a2);
signed int __fastcall sub_801D73C(int a1, unsigned __int16 a2);
signed int __fastcall sub_801D7F2(int a1, int a2);
int __fastcall sub_801D932(int a1);
int __fastcall sub_801D99A(int a1);
int __fastcall sub_801D9FE(int a1);
signed int __fastcall sub_801DA80(int a1, int a2);
int __fastcall sub_801DBE6(int result, int a2);
int __fastcall sub_801DC8A(int a1, int a2);
signed int __fastcall sub_801DD2A(int a1, int a2);
signed int __fastcall sub_801DDA4(int a1, int a2, char a3);
signed int __fastcall sub_801E1B2(int a1, unsigned __int16 a2);
signed int __fastcall sub_801E1E0(unsigned __int8 a1, int a2);
int __fastcall f_open(void *fp, char *path, FA_MODE mode);
signed int __fastcall f_read(void *fp, void *data, unsigned int count, int *bytes_read);
signed int __fastcall f_write(void *fp, void *data, unsigned int count, int *bytes_written);
signed int __fastcall f_sync_prob(int a1);
int __fastcall f_close(int a1);
signed int __fastcall f_seek(int a1, unsigned int a2);
int __fastcall sub_801EADA(int a1, int a2);
int __fastcall sub_801EB64(int a1, int a2);
int HAL_SD_Init();
signed int sub_801EC86();
unsigned int sub_801ECA8();
signed int sub_801ECD2();
signed int SD_PowerON();
void turn_off_sd_card();
signed int SD_Initialize_Cards();
int __fastcall HAL_SD_GetCardInfo(int a1);
signed int __fastcall sub_801F4B0(int a1);
int __fastcall SD_Select_Deselect(int a1);
signed int __fastcall HAL_SD_ReadBlocks(int a1, int a2, unsigned __int64 a3, signed __int16 a4);
signed int __fastcall prob_write_sd_block(int a1, int a2, unsigned __int64 a3, signed __int16 a4, int a5);
signed int sub_801F8C4();
int sd_stop_transmission();
signed int __fastcall sd_get_status(int a1);
void __fastcall SDIO_interrupt_real();
void __fastcall DMA2_CH4_interrupt_real();
signed int sub_801FB3C();
signed int sub_801FB88();
signed int __fastcall SD_CmdResp1Error(unsigned __int8 a1);
signed int sub_801FD34();
signed int wait_for_sd_cmd_resp();
signed int __fastcall sub_801FDFC(unsigned __int8 a1, int a2);
signed int __fastcall sd_switch_some_kind_of_func(char a1);
signed int __fastcall sub_8020068(int a1, int a2);
int __fastcall strlen(int a1);
void disable_sd_card_hw();
void HAL_SD_MspInit();
int __fastcall sub_80203C4(int a1, unsigned int a2);
void __fastcall sdio_something(int a1, unsigned int a2);
double __fastcall dp_from_int(int num);
double __fastcall dp_from_uint(unsigned int result);
double __fastcall dp_from_uint_core(int num);
double __fastcall dp_sqrt(double num);
float __fastcall fp_from_int64(__int64 num);
double __fastcall dp_log10(double num);
double __fastcall dp_sub(double a, double b);
int __fastcall sub_80207C4(int a1);
bool __fastcall isnt_zero(char a1);
signed int __fastcall sub_80207E6(int a1, int a2, int a3);
signed int __fastcall prob_write_sd_blocks(int a1, int a2, int a3, unsigned __int8 a4);
signed int sub_8020894();
int __fastcall sub_802089C(int a1, unsigned int a2, int a3);
void reset_sdio_periph();
void __fastcall something_gnarly_with_sdio_clk(int result);
void __fastcall HAL_set_sdio_clken(unsigned __int8 clken);
void __fastcall set_sdio_power_reg(int val);
int sdio_power_enabled(void); // weak
void __fastcall sdio_sub_8020932(int result);
void __fastcall SDIO_SendCommand(SDIO_CMD_ST *cmd);
unsigned __int8 get_sdio_respcmd();
_DWORD __fastcall read_resp_word(int which);
void __fastcall SDIO_DataConfig(int result);
int read_sdio_fifo();
void __fastcall set_sdio_mask(int bits, char state);
bool __fastcall get_sdio_sta(int mask); // idb
void __fastcall set_sdio_icr(int val);
bool __fastcall get_sdio_sta_0(int mask); // idb
void __fastcall set_sdio_icr_0(int result);
int __fastcall sub_8020A54(int result, int a2);
int __fastcall sub_8020A92(int result, char a2);
int __fastcall sub_8020AAE(int result, int a2, char a3);
int __fastcall sub_8020AC4(int result);
void fp_set_nan_error();
double __fastcall dp_log_core(double num, int base_sel);
int *__cdecl fp_get_last_error_ptr();
int __fastcall dp_normalize(double *num);
void __fastcall dp_something_0_0(double a, double b);
void nullsub_4();
void __fastcall TIM2_interrupt();
void __fastcall TIM3_interrupt();
void __fastcall USART2_interrupt();
void __fastcall SysTick_Handler();
void __fastcall SDIO_interrupt();
void __cdecl DMA2_CH4_interrupt();
void __fastcall RTC_WKUP_interrupt();
void __fastcall EXTI0_interrupt();
void __fastcall EXTI1_interrupt();
void __fastcall EXTI2_interrupt();
void __fastcall EXTI3_interrupt();
void __fastcall EXTI4_interrupt();
void __fastcall EXTI_9_5_interrupt();
void __fastcall EXTI_15_10_interrupt();
void __fastcall ADC1_interrupt();
void __noreturn main_loop();
void load_stuff_from_eeprom_and_init();
void apo_do_poweroff_then_poweron(void);
void __fastcall SystemInit();
void setup_system_from_reset_continued();
int call_funcs_in_init_func_table(void); // weak
signed int should_call_funcs_in_init_func_table();
void __noreturn unused_sub_8022836();
void __noreturn unused_sub_8022848();
void reset_vector();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_801C404; // weak
_UNKNOWN loc_801CC74; // weak
_UNKNOWN loc_801CCF8; // weak
_UNKNOWN loc_8020658; // weak
unsigned int max_digits_in_range_tbl[25][7] =
{
  { 6000u, 50000u, 50000u, 50000u, 50000u, 50000u, 50000u },
  { 50000u, 50000u, 50000u, 6000u, 50000u, 50000u, 50000u },
  { 50000u, 50000u, 50000u, 6000u, 50000u, 50000u, 50000u },
  { 50000u, 50000u, 50000u, 50000u, 50000u, 50000u, 50000u },
  { 50000u, 50000u, 50000u, 50000u, 50000u, 50000u, 50000u },
  { 10000u, 50000u, 50000u, 50000u, 50000u, 50000u, 50000u },
  { 99999u, 99999u, 99999u, 99999u, 99999u, 99999u, 50000u },
  { 99999u, 99999u, 99999u, 50000u, 50000u, 50000u, 50000u },
  { 990u, 50000u, 50000u, 50000u, 50000u, 50000u, 50000u },
  { 50000u, 50000u, 50000u, 50000u, 50000u, 50000u, 50000u },
  { 50000u, 50000u, 50000u, 50000u, 50000u, 50000u, 50000u },
  { 30000u, 15000u, 50000u, 50000u, 50000u, 50000u, 50000u },
  { 1000u, 1000u, 1000u, 1000u, 1000u, 10000u, 50000u },
  { 25000u, 25000u, 25000u, 25000u, 50000u, 50000u, 50000u },
  { 25000u, 25000u, 25000u, 25000u, 50000u, 50000u, 50000u },
  { 25000u, 25000u, 50000u, 50000u, 50000u, 50000u, 50000u },
  { 50000u, 50000u, 50000u, 50000u, 50000u, 50000u, 50000u },
  { 50000u, 50000u, 50000u, 50000u, 50000u, 50000u, 50000u },
  { 50000u, 50000u, 50000u, 50000u, 50000u, 50000u, 50000u },
  { 50000u, 50000u, 50000u, 50000u, 50000u, 50000u, 50000u },
  { 50000u, 50000u, 10000u, 50000u, 50000u, 50000u, 50000u },
  { 50000u, 50000u, 10000u, 50000u, 50000u, 50000u, 50000u },
  { 25000u, 25000u, 25000u, 25000u, 50000u, 50000u, 50000u },
  { 25000u, 25000u, 25000u, 25000u, 50000u, 50000u, 50000u },
  { 25000u, 25000u, 50000u, 50000u, 50000u, 50000u, 50000u }
};
int temp_range_offset_factor_tbl[158] =
{
  4294961261,
  4294961405,
  4294961566,
  4294961746,
  4294961942,
  4294962155,
  4294962383,
  4294962627,
  4294962885,
  4294963158,
  4294963444,
  4294963742,
  4294964053,
  4294964376,
  4294964709,
  4294965053,
  4294965407,
  4294965769,
  4294966140,
  4294966518,
  4294966904,
  0,
  397,
  798,
  1203,
  1612,
  2023,
  2436,
  2851,
  3267,
  3682,
  4096,
  4509,
  4920,
  5328,
  5735,
  6138,
  6540,
  6941,
  7340,
  7739,
  8138,
  8539,
  8940,
  9343,
  9747,
  10153,
  10561,
  10970,
  11382,
  11795,
  12209,
  12624,
  13040,
  13457,
  13874,
  14293,
  14713,
  15133,
  15554,
  15975,
  16397,
  16820,
  17243,
  17667,
  18091,
  18516,
  18941,
  19366,
  19792,
  20218,
  20644,
  21071,
  21497,
  21924,
  22350,
  22776,
  23203,
  23629,
  24055,
  24480,
  24905,
  25330,
  25755,
  26179,
  26602,
  27025,
  27447,
  27869,
  28289,
  28710,
  29129,
  29548,
  29965,
  30382,
  30798,
  31213,
  31628,
  32041,
  32453,
  32865,
  33275,
  33685,
  34093,
  34501,
  34908,
  35313,
  35718,
  36121,
  36524,
  36925,
  37326,
  37725,
  38124,
  38522,
  38918,
  39314,
  39708,
  40101,
  40494,
  40885,
  41276,
  41665,
  42053,
  42440,
  42826,
  43211,
  43595,
  43978,
  44359,
  44740,
  45119,
  45497,
  45873,
  46249,
  46623,
  46995,
  47367,
  47737,
  48105,
  48473,
  48838,
  49202,
  49565,
  49926,
  50286,
  50644,
  51000,
  51355,
  51708,
  52060,
  52410,
  52759,
  53106,
  53451,
  53795,
  54138,
  54479
};
_BYTE hy_regtbl_ohms[7][20] =
{
  {
    116,
    207,
    21,
    143,
    133,
    0,
    0,
    0,
    0,
    0,
    0,
    64,
    6,
    0,
    4,
    148,
    128,
    210,
    12,
    44
  },
  {
    116,
    207,
    21,
    143,
    133,
    0,
    0,
    0,
    0,
    0,
    0,
    64,
    6,
    0,
    4,
    148,
    128,
    210,
    12,
    44
  },
  { 0, 0, 19, 131, 133, 0, 0, 0, 0, 0, 0, 64, 96, 0, 0, 148, 128, 211, 12, 44 },
  { 0, 0, 20, 131, 133, 0, 0, 0, 0, 0, 0, 64, 0, 6, 0, 148, 128, 211, 12, 44 },
  { 0, 0, 20, 131, 133, 0, 0, 0, 0, 0, 0, 64, 0, 96, 0, 148, 128, 210, 12, 32 },
  {
    0,
    0,
    20,
    147,
    133,
    0,
    0,
    0,
    85,
    0,
    0,
    8,
    0,
    128,
    128,
    134,
    128,
    209,
    0,
    172
  },
  { 0, 0, 21, 147, 133, 0, 0, 0, 85, 0, 8, 8, 0, 0, 0, 134, 128, 209, 0, 172 }
};
_BYTE hy_regtbl_cap[6][20] =
{
  { 118, 33, 7, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 128, 0, 142, 0, 194, 14, 32 },
  { 118, 33, 7, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 128, 0, 142, 0, 194, 14, 32 },
  { 118, 33, 7, 0, 0, 0, 0, 0, 0, 0, 0, 8, 128, 0, 0, 142, 0, 194, 14, 32 },
  { 118, 33, 4, 138, 165, 0, 0, 0, 85, 0, 0, 8, 8, 0, 0, 142, 0, 194, 14, 32 },
  { 118, 33, 4, 138, 165, 0, 0, 0, 85, 0, 0, 8, 8, 0, 0, 142, 0, 194, 14, 32 },
  { 82, 33, 0, 0, 0, 17, 0, 80, 17, 0, 0, 0, 8, 0, 0, 154, 0, 194, 60, 32 }
};
int cal_ohms_50M_factor_tbl[26] =
{
  0,
  5,
  10,
  15,
  20,
  25,
  30,
  35,
  40,
  45,
  50,
  55,
  60,
  0,
  37,
  65,
  85,
  100,
  100,
  100,
  87,
  70,
  40,
  0,
  4294967259,
  4294967231
}; // weak
_BYTE hy_regtbl_dcv[4][20] =
{
  {
    0,
    0,
    19,
    138,
    5,
    64,
    0,
    77,
    49,
    1,
    34,
    0,
    0,
    144,
    40,
    160,
    128,
    199,
    0,
    32
  },
  { 0, 0, 19, 138, 5, 64, 0, 77, 49, 1, 34, 0, 0, 9, 40, 160, 128, 199, 8, 44 },
  {
    0,
    0,
    19,
    138,
    5,
    64,
    0,
    77,
    49,
    1,
    34,
    0,
    144,
    0,
    40,
    160,
    128,
    199,
    8,
    44
  },
  { 0, 0, 19, 138, 5, 64, 0, 77, 49, 1, 34, 0, 9, 0, 40, 160, 128, 199, 8, 44 }
};
_BYTE hy_regtbl_acv_1ms_peak[4][20] =
{
  {
    246,
    221,
    4,
    3,
    82,
    16,
    135,
    37,
    49,
    196,
    0,
    0,
    0,
    144,
    136,
    160,
    153,
    199,
    56,
    32
  },
  {
    246,
    221,
    4,
    3,
    82,
    16,
    135,
    37,
    49,
    236,
    0,
    0,
    0,
    9,
    136,
    160,
    176,
    199,
    56,
    32
  },
  {
    246,
    221,
    4,
    3,
    82,
    16,
    135,
    37,
    49,
    236,
    0,
    0,
    144,
    0,
    136,
    160,
    128,
    199,
    56,
    32
  },
  {
    246,
    221,
    4,
    3,
    82,
    16,
    135,
    37,
    49,
    236,
    0,
    0,
    9,
    0,
    136,
    160,
    128,
    199,
    56,
    32
  }
};
_BYTE hy_regtbl_acv[4][20] =
{
  {
    246,
    221,
    2,
    131,
    245,
    65,
    2,
    77,
    49,
    1,
    0,
    0,
    0,
    9,
    136,
    176,
    128,
    192,
    8,
    44
  },
  {
    246,
    221,
    2,
    131,
    245,
    65,
    2,
    77,
    49,
    1,
    0,
    0,
    144,
    0,
    136,
    176,
    128,
    192,
    56,
    44
  },
  {
    246,
    221,
    2,
    131,
    245,
    65,
    2,
    77,
    49,
    1,
    0,
    0,
    9,
    0,
    136,
    176,
    128,
    192,
    56,
    44
  },
  {
    246,
    221,
    0,
    131,
    245,
    65,
    2,
    77,
    49,
    1,
    0,
    0,
    9,
    0,
    136,
    176,
    128,
    192,
    56,
    44
  }
};
int mcafdoc_corr_tbl_acmv50[2][9] =
{
  { 0, 3, 0, 4294967294, 1, 18, 47, 81, 100 },
  { 0, 4294967291, 4294967295, 7, 40, 70, 90, 98, 100 }
};
int mcafdoc_corr_tbl_acmv500[2][9] =
{
  { 0, 1, 4294967295, 4294967294, 4294967295, 15, 45, 82, 100 },
  { 0, 4294967294, 4294967295, 3, 19, 40, 65, 88, 100 }
};
int mcafdoc_ac_corr_tbl_acv5[36] =
{
  0,
  1,
  18,
  80,
  95,
  105,
  109,
  105,
  100,
  0,
  4294967295,
  14,
  60,
  83,
  92,
  97,
  99,
  100,
  0,
  5,
  13,
  23,
  36,
  50,
  66,
  83,
  100,
  0,
  4,
  10,
  18,
  29,
  43,
  60,
  78,
  100
};
int mcafdoc_ac_corr_tbl_acv50[36] =
{
  0,
  4294967291,
  15,
  90,
  100,
  110,
  107,
  105,
  100,
  0,
  4294967291,
  10,
  57,
  80,
  89,
  96,
  99,
  100,
  0,
  5,
  13,
  23,
  36,
  50,
  66,
  83,
  100,
  0,
  4,
  8,
  16,
  27,
  41,
  58,
  77,
  100
};
int batt_level_offset_factor_tbl[16] =
{
  3120,
  2980,
  2840,
  2700,
  2560,
  2420,
  2280,
  2140,
  2000,
  1860,
  1720,
  1580,
  1440,
  1300,
  1160,
  1020
};
_BYTE hy_regtbl_ac_amps[3][20] =
{
  {
    246,
    221,
    18,
    139,
    243,
    17,
    0,
    85,
    49,
    0,
    0,
    0,
    0,
    0,
    0,
    128,
    128,
    199,
    61,
    44
  },
  {
    246,
    221,
    18,
    139,
    243,
    17,
    0,
    85,
    49,
    0,
    0,
    0,
    0,
    0,
    0,
    128,
    128,
    199,
    61,
    44
  },
  {
    246,
    221,
    18,
    139,
    243,
    16,
    0,
    85,
    49,
    0,
    0,
    0,
    0,
    0,
    0,
    128,
    128,
    199,
    61,
    44
  }
};
_BYTE hy_regtbl_dc_amps[3][20] =
{
  { 0, 0, 18, 155, 147, 49, 0, 85, 49, 0, 0, 0, 0, 0, 0, 128, 128, 199, 51, 44 },
  { 0, 0, 18, 139, 147, 17, 0, 85, 49, 0, 0, 0, 0, 0, 0, 128, 128, 199, 51, 44 },
  { 0, 0, 18, 139, 147, 17, 0, 85, 49, 0, 0, 0, 0, 0, 0, 128, 128, 199, 51, 44 }
};
_WORD internal_temp_offset_factor_tbl[28] =
{
  3758,
  3672,
  3570,
  3451,
  3315,
  3163,
  2997,
  2819,
  2631,
  2437,
  2242,
  2048,
  1859,
  1678,
  1508,
  1349,
  1203,
  1070,
  950,
  842,
  746,
  661,
  585,
  518,
  460,
  408,
  222,
  0
}; // idb
int mcafdoc_corr_tbl_acv500[2][7] = { { 0, 2, 22, 78, 98, 99, 100 }, { 0, 2, 22, 77, 96, 99, 100 } };
int mcafdoc_corr_tbl_acv600[2][7] = { { 0, 2, 22, 85, 95, 99, 100 }, { 0, 2, 22, 77, 95, 99, 100 } };
int mcafdoc_corr_tbl_acuA[2][7] =
{
  { 0, 4294967286, 3, 20, 35, 55, 100 },
  { 0, 4294967276, 4294967288, 2, 16, 43, 100 }
};
int mcafdoc_corr_tbl_acmA[2][7] =
{
  { 0, 4294967286, 3, 20, 40, 55, 100 },
  { 0, 4294967281, 4294967292, 7, 20, 47, 100 }
};
__int16 cal_factor_eeloc_tbl[26] =
{
  48,
  112,
  48,
  176,
  208,
  240,
  256,
  256,
  256,
  272,
  288,
  384,
  400,
  768,
  832,
  896,
  496,
  528,
  560,
  592,
  624,
  672,
  960,
  1024,
  1088,
  720
};
_BYTE hy_regtbl_dcmv[2][20] =
{
  {
    96,
    0,
    28,
    139,
    59,
    81,
    0,
    109,
    49,
    1,
    0,
    0,
    0,
    0,
    8,
    129,
    128,
    192,
    12,
    96
  },
  {
    96,
    0,
    16,
    138,
    53,
    64,
    0,
    109,
    49,
    1,
    0,
    0,
    0,
    0,
    8,
    129,
    128,
    192,
    12,
    44
  }
};
_BYTE hy_regtbl_acmv[2][20] =
{
  {
    246,
    221,
    19,
    138,
    245,
    67,
    6,
    109,
    49,
    1,
    0,
    0,
    0,
    0,
    8,
    145,
    128,
    192,
    58,
    44
  },
  {
    246,
    221,
    19,
    138,
    245,
    64,
    0,
    109,
    49,
    1,
    0,
    0,
    0,
    0,
    8,
    145,
    128,
    192,
    58,
    44
  }
};
_BYTE hy_regtbl_acmv_1ms_peak[2][20] =
{
  {
    246,
    221,
    7,
    3,
    0,
    19,
    129,
    37,
    17,
    236,
    0,
    0,
    0,
    0,
    0,
    144,
    128,
    199,
    58,
    40
  },
  {
    246,
    221,
    7,
    3,
    82,
    16,
    129,
    37,
    17,
    236,
    0,
    0,
    0,
    0,
    0,
    144,
    128,
    199,
    58,
    40
  }
};
_BYTE hy_regtbl_diode[1][20] =
{
  { 0, 0, 18, 131, 141, 0, 0, 0, 17, 0, 0, 0, 8, 0, 64, 146, 128, 225, 3, 172 }
};
_BYTE hy_regtbl_freq[20] = { 254, 221, 0, 0, 0, 1, 0, 0, 0, 0, 34, 0, 0, 144, 40, 160, 0, 192, 8, 44 };
int mcafdoc_infreq_tbl_100khz[9] = { 50, 400, 1000, 10000, 30000, 50000, 70000, 90000, 100000 };
int mcafdoc_ac_infreq_tbl_20khz[9] = { 50, 400, 1000, 3000, 5000, 7000, 10000, 15000, 20000 };
int mcafdoc_ac_infreq_tbl_100khz[9] = { 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000 };
int (*init_func_table)() = (int (*)())0xFFFF4DD3; // weak
_BYTE ascii_to_segs_tbl_uppercase[26] =
{
  63,
  188,
  170,
  181,
  174,
  46,
  159,
  61,
  17,
  177,
  45,
  168,
  191,
  59,
  187,
  47,
  31,
  42,
  158,
  172,
  185,
  185,
  185,
  28,
  157,
  134
};
_BYTE ascii_to_segs_tbl_lowercase[28] =
{
  63,
  188,
  164,
  181,
  174,
  46,
  159,
  60,
  16,
  177,
  45,
  168,
  191,
  52,
  180,
  47,
  31,
  36,
  158,
  172,
  176,
  176,
  176,
  28,
  157,
  134,
  0,
  0
}; // idb
int mcafdoc_infreq_tbl_10khz[7] = { 50, 400, 1000, 3000, 5000, 7000, 10000 };
_BYTE hy_regtbl_continuity[20] = { 116, 207, 16, 143, 133, 0, 0, 0, 0, 0, 0, 64, 6, 0, 4, 148, 128, 210, 12, 44 };
_BYTE ascii_to_segs_tbl_digits[10] = { 187, 17, 167, 151, 29, 158, 190, 27, 191, 159 };
_BYTE ranges_in_mode[25] = { 1, 4, 4, 2, 2, 1, 5, 3, 1, 7, 1, 1, 6, 4, 4, 4, 2, 2, 2, 2, 3, 3, 4, 4, 4 };
_BYTE AHB_APB_PrescTable[16] = { 0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9 }; // idb
char aInterval_0[10] = "INTERVAL,"; // weak
char aOverflow_2[9] = "Overflow"; // weak
char aOverflow_1[10] = "-Overflow"; // weak
char aMain_0[9] = ",MAIN,,,"; // weak
char aSub1_0[9] = "SUB-1,,,"; // weak
char aSub2_0[9] = "SUB-2,,,"; // weak
char aPeakhold_0[9] = "PeakHold"; // weak
_BYTE PLLMulTable[9] = { 3, 4, 6, 8, 12, 16, 24, 32, 48 };
char aStart_0[7] = "START,"; // weak
char aSec_0[5] = "sec,"; // weak
char aMax_0[5] = "MAX,"; // weak
char aMin_0[5] = "MIN,"; // weak
char aRemark_0[8] = "Remark,"; // weak
char aNo__0[6] = "No. ,"; // weak
char aFunc__0[8] = "Func. ,"; // weak
char aValue_0[7] = "Value,"; // weak
char aUnit_0[6] = "Unit,"; // weak
char aLowz_0[6] = "LowZ,"; // weak
char aAcv_0[5] = "ACV,"; // weak
char aDcv_0[5] = "DCV,"; // weak
char aDcmv_0[6] = "DCmV,"; // weak
char aAcmv_0[6] = "ACmV,"; // weak
char aTemp__0[7] = "TEMP.,"; // weak
char aFreq__0[7] = "FREQ.,"; // weak
char aPulse_0[7] = "PULSE,"; // weak
char aDuty_0[6] = "DUTY,"; // weak
char aOhm_1[5] = "OHM,"; // weak
char aBeep_0[6] = "BEEP,"; // weak
char aDiode_0[7] = "DIODE,"; // weak
char aCap__0[6] = "CAP.,"; // weak
char aUva_0[5] = "uVA,"; // weak
char aMva_0[5] = "mVA,"; // weak
char aAcua_0[6] = "ACuA,"; // weak
char aDcua_0[6] = "DCuA,"; // weak
char aAcma_0[6] = "ACmA,"; // weak
char aDcma_0[6] = "DCmA,"; // weak
char aAca_0[5] = "ACA,"; // weak
char aDca_0[5] = "DCA,"; // weak
char aDcuva_0[7] = "DCuVA,"; // weak
char aDcmva_0[7] = "DCmVA,"; // weak
char aDcva_0[6] = "DCVA,"; // weak
char aBurden_0[8] = "Burden,"; // weak
char aKhz_0[5] = "KHz,"; // weak
char aMsec_0[6] = "mSec,"; // weak
char aOhm_2[5] = "ohm,"; // weak
char aKohm_0[6] = "Kohm,"; // weak
char aMohm_0[6] = "Mohm,"; // weak
char a1khz_0[5] = "1KHz"; // weak
char aAcdc_1[5] = "ACDC"; // weak
char asc_200001D4[3] = "\r\n"; // weak
char aId_0[4] = "ID,"; // weak
char aVa_0[4] = "VA,"; // weak
char aMv_0[4] = "mV,"; // weak
char aV_0[3] = "V,"; // weak
char aUa_0[4] = "uA,"; // weak
char aMa_0[4] = "mA,"; // weak
char aA_0[3] = "A,"; // weak
char aC_0[4] = "'C,"; // weak
char aF_0[4] = "'F,"; // weak
char aHz_0[4] = "Hz,"; // weak
char asc_20000200[3] = "%,"; // weak
char aNf_0[4] = "nF,"; // weak
char aUf_0[4] = "uF,"; // weak
int hy_CTA_initial_val = 57344; // weak
int fp_last_error = 0;
char asc_20000214[2] = ","; // weak
char asc_20000216[2] = "-"; // weak
unsigned __int16 curr_logging_interval = 1u;
__int16 sys_boot_button_delay_timer_1ms_unit = 500; // weak
__int16 apo_timeout_sec = 1800; // weak
unsigned __int8 subscr_mode_for_last_units = 255u;
char amp_lead_pos_debounce_timer = '\n'; // weak
unsigned __int8 last_range_switch_bits = 255u;
unsigned __int8 rtc_last_read_seconds = 255u;
char curr_lcd_contrast = '\x0E'; // weak
char meter_mode_range_change_delay = '\x03'; // weak
char lowz_acdc_switch_timer = '\x05'; // weak
char lowz_active_lockout_timer = '\x05'; // weak
_BYTE sd_cal_buf[1200] = { 255, 255, 255, 255, 255, 255, 255, 255,  };
_UNKNOWN unk_20002938; // weak
_UNKNOWN f_file_structure; // weak
_UNKNOWN unk_20002D8C; // weak
_BYTE sd_readback_buf[512]; // idb
int meas_ara1_buf[100];
int meas_ara2_buf[100];
_UNKNOWN unk_200034D0; // weak
__int16 word_20003524; // weak
int batt_level_avg_buf[20];
int batt_level_avg_buf_sorted[20];
LCD_SEGS_C0L segment_buffer_C0L;
LCD_SEGS_C0H segment_buffer_C0H;
LCD_SEGS_C1L segment_buffer_C1L;
LCD_SEGS_C1H segment_buffer_C1H;
LCD_SEGS_C2L segment_buffer_C2L;
LCD_SEGS_C2H segment_buffer_C2H;
LCD_SEGS_C3L segment_buffer_C3L;
LCD_SEGS_C3H segment_buffer_C3H;
unsigned __int8 hy_regs_buf[52];
char bt_buf[56];
_UNKNOWN unk_20003684; // weak
_UNKNOWN unk_200036A0; // weak
char byte_200036A9; // weak
char byte_200036AA; // weak
char byte_200036AB; // weak
char byte_200036AC; // weak
char byte_200036AD; // weak
char byte_200036AE; // weak
char byte_200036AF; // weak
char byte_200036B0; // weak
char byte_200036B2; // weak
char byte_200036B3; // weak
char byte_200036B4; // weak
int dword_200036B8; // weak
int dword_200036BC; // weak
int dword_200036C0; // weak
int dword_200036C4; // weak
int dword_200036C8; // weak
char byte_200036CC; // weak
int sdio_dword_200036D0; // weak
int sdio_dword_200036D4; // weak
int sdio_dword_200036D8; // weak
int sdio_dword_200036DC; // weak
int sdio_dword_200036E0; // weak
int sdio_dword_200036E4; // weak
char bt_rx_buf[20];
char bt_rx_msg[20];
__int16 curr_internal_temp_avg_buf[]; // idb
SDIO_CMD_ST sd_cmd_temp; // weak
char log_file_name[12]; // weak
char uint_to_ascii_unused; // weak
int sd_resp_csd[4]; // weak
int sd_resp_cid[4]; // weak
__int64 cal_dcva_volts_accu; // idb
__int64 cal_dcva_amps_accu; // weak
__int64 cal_acva_volts_accu; // idb
__int64 cal_acva_amps_accu; // weak
char uint_to_ascii_with_point_unused_0; // weak
char scr_msg_tmp[5]; // weak
__int64 cal_curr_gain_accu;
__int64 curr_freq_in_millihz; // weak
__int64 curr_msec_val; // weak
int meas_ohms_50M_offset_val; // weak
float C50MO_frac_into_range;
float C50MO_digits_in_cal_range;
int C50MO_range_start; // weak
int C50MO_range_stop; // weak
int meas_diode_last_digits; // weak
int meas_ara1_last; // weak
int cap_offset_temp; // weak
int log_curr_filename_ptr; // weak
int dword_200037E4; // weak
int log_file_name_number; // weak
int f_bytes_read_temp; // weak
int f_bytes_written_temp; // weak
int log_file_start_pos; // weak
int log_file_curr_pos; // weak
int log_file_total_len; // weak
_DWORD dword_20003800; // idb
int current_brownout_level; // weak
int SysTickTimer; // weak
int curr_meter_serial; // weak
int edit_meter_serial; // weak
int log_rdsamp_C_main_measurement; // weak
int log_rdsamp_F_ex_volt_value; // weak
int log_rdsamp_I_ex_amp_value; // weak
int log_prsamp_C_main_measurement; // weak
int log_prsamp_F_ex_volt_value; // weak
int log_prsamp_I_ex_amp_value; // weak
int log_successful_flushes; // weak
int log_total_samples; // weak
int log_file_total_samples_written; // weak
int log_samples_in_eeprom_that_need_flushing; // weak
int log_file_total_samples_written_backup; // weak
int dword_20003840; // weak
int dword_20003844; // weak
int dword_20003848; // weak
int dword_2000384C; // weak
int curr_cal_factor_eeloc; // weak
int max_digits_in_range; // weak
int curr_scr_digits; // weak
int curr_bargraph_digits; // weak
int hy_curr_AD1; // weak
int hy_curr_rms_data; // weak
int meas_va_last_volts; // weak
int meas_va_last_amps; // weak
int ac_input_freq; // weak
int meter_min_max_maxval; // weak
int meter_min_max_minval; // weak
int meter_min_max_avg; // weak
int meter_min_max_avg_diff; // weak
int meter_min_max_avg_count; // weak
int hold_last_value_for_auto; // weak
int rel_meas_rel_val; // weak
int disp_bcd_tmp[5]; // weak
char curr_hy_INTF; // weak
int hy_curr_AD1_unsigned; // weak
int hy_curr_AD1_internal; // weak
int hy_ad1_avg_sum; // weak
int hy_AD1_avg; // weak
int hy_RMS_DATA_lsb; // weak
int hy_RMS_DATA_msb; // weak
int hy_rms_data; // weak
int hy_rms_avg_accu; // weak
int hy_rms_avg_val; // weak
int hy_PKHMIN; // weak
int hy_PKHMAX; // weak
int hy_last_PKHMIN; // weak
int meas_ara2_last; // weak
int cal_offset_val_unused; // weak
int cal_curr_offset_val; // weak
int cal_curr_offset_accu_div_by_16_never_read; // weak
int cal_ac_offset_temp_result; // weak
int curr_amp_rel; // weak
float cal_curr_gain_val;
int cal_ohms_50M_offset_factor; // weak
int hy_sysclk_in_decihz;
int cal_curr_offset_accu; // weak
float cal_curr_gain_accu_float;
int cal_curr_offset_va_volts; // weak
int cal_curr_offset_va_amps; // weak
float cal_curr_gain_va_volts;
float cal_curr_gain_va_amps;
int curr_duty_val; // weak
int hy_ctr_gate_time; // weak
int hy_curr_CTA_gate_time; // weak
int hy_curr_CTB_freqdata; // weak
int hy_curr_CTC_duty; // weak
int hy_ctr_cyc_elapsed; // weak
int cal_ac_factor_decirange;
int cal_ac_factor_fullrange;
int cal_ac_factor_decirange_lf;
int cal_ac_factor_fullrange_lf;
int curr_ac_offset; // weak
int ac_input_freq_acv; // weak
int ac_input_freq_lowz; // weak
int curr_cap_val; // weak
int burden_last_volts; // weak
int dword_20003950; // weak
int dword_20003954; // weak
int dword_20003958; // weak
int temp_offset; // weak
int temp_meas_val; // weak
int temp_meas_val_base; // weak
int temp_meas_val_in_f; // weak
int peakhold_max_value; // weak
int peakhold_min_value; // weak
float curr_subscr_dBm;
int curr_subscr_digits; // weak
int meas_acv_dcv_dc_value; // weak
int meas_acv_dcv_ac_value; // weak
int meas_acv_dcv_dc_value_squared; // weak
int meas_acv_dcv_ac_value_squared; // weak
int meter_power_volts; // weak
int meter_power_amps; // weak
int meter_power_amps_uVA_precise; // weak
int sdio_dword_20003998; // weak
int dword_2000399C; // weak
int sdio_dword_200039A0; // weak
int sdio_dword_200039A4; // weak
int dword_200039A8; // weak
int dword_200039AC; // weak
int TIM2_prepare_sample_timer_100ms; // weak
int TIM2_500ms_timer; // weak
int apo_timeout_subtimer_10ms; // weak
int bt_packet_write_timer_250ms; // weak
int mcafdoc_result_offset; // weak
int mcafdoc_ac_input_hz; // weak
int mcafdoc_corr_val; // weak
int mcafdoc_freq_range_size; // weak
int mcafdoc_freq_dist_into_range; // weak
int mcafdoc_corr_val_decirange; // weak
int mcafdoc_corr_val_fullrange; // weak
int mcafdoc_corr_digits_decirange; // weak
int mcafdoc_corr_digits_fullrange; // weak
int mcafdoc_freq_range_hi; // weak
int mcafdoc_freq_range_lo; // weak
int mcafdoc_digits_decirange; // weak
int mcafdoc_decirange_factor; // weak
int mcafdoc_fullrange_factor; // weak
int mcafdoc_is_always_zero; // weak
float mcafdoc_frac_into_range;
float mcafdoc_corr_in_range;
int mcafdoc_ac_what; // weak
int mcafdoc_ac_fullrange_factor_diff; // weak
int mcafdoc_ac_decirange_factor_diff; // weak
int mcafdoc_ac_corr_factor; // weak
int mcafdoc_ac_corr_factor_lf; // weak
int mcafdoc_ac_range_diff; // weak
int mcafdoc_ac_digits_into_range; // weak
int mcafdoc_ac_amt_digits_into_range; // weak
int mcafdoc_ac_decirange_factor_lf_digits; // weak
int mcafdoc_ac_range_hi; // weak
int mcafdoc_ac_range_lo; // weak
int mcafdoc_ac_range_lf_hi; // weak
int mcafdoc_ac_range_lf_lo; // weak
int mcafdoc_ac_corr_val_lo; // weak
int mcafdoc_ac_corr_val_hi; // weak
int mcafdoc_ac_result; // weak
int mcafdoc_corr_val_diff; // weak
float mcafdoc_ac_infreq_frac_into_range;
__int16 curr_log_cache_pos; // weak
unsigned __int16 batt_really_is_low_timer;
__int16 word_20003A50; // weak
__int16 last_cal_year_month;
__int16 log_playback_pos; // weak
unsigned __int16 log_playback_window_end;
unsigned __int16 log_playback_window_start;
__int16 log_playback_window_len; // weak
__int16 log_samples_in_eeprom; // weak
__int16 edit_logging_interval; // weak
unsigned __int16 logging_interval_timer_1s;
__int16 log_playback_mode_timeout; // weak
__int16 log_file_chain_idx; // weak
__int16 TIM2_auto_hold_unhold_timer_1s; // weak
__int16 beep_timer_1ms; // weak
__int16 beep_time; // weak
__int16 backlight_related_var_maybe_auto_timeout_unused; // weak
__int16 curr_batt_charge; // weak
__int16 batt_level_avg_count; // weak
__int16 cal_internal_thermistor_factor; // weak
__int16 freq_input_timeout_timer_10ms_unit; // weak
unsigned __int16 hy_change_CTA_val_timer;
__int16 mes_cap_no_reading_timeout_timer_10ms_unit; // weak
__int16 meas_cap_some_other_timer_unused; // weak
__int16 curr_burden_voltage; // weak
__int16 curr_internal_temperature; // weak
__int16 curr_internal_temp_adc; // weak
__int16 curr_internal_temp_avg; // weak
__int16 curr_adc_val_for_batt_level_and_internal_temp; // weak
__int16 curr_internal_temp_avg_count; // weak
__int16 curr_internal_temp_invalid_timer; // weak
unsigned __int16 subscr_power_v_a_switch_timer;
char amp_lead_pos_last; // weak
char range_switch_unbounce_timer; // weak
unsigned __int8 range_switch_bounce_timer;
char autoranging_was_disabled_before_rel_meas_was_enabled; // weak
char button_delay_flag; // weak
char button_debounce_timer; // weak
char last_button_input; // weak
char button_delay_buttons; // weak
char button_repress_fast_counter; // weak
char button_repress_counter; // weak
char f_op_err; // weak
char log_first_byte_of_vol_path_str; // weak
char log_second_byte_of_vol_path_str_never_read; // weak
char log_flush_samples_from_eeprom_try_counter; // weak
char autorange_overflowed_last_time; // weak
char bat_is_low; // weak
char came_from_standby; // weak
unsigned __int8 logging_active;
unsigned __int8 logging_interval_elapsed;
char maybe_logging_was_active_at_some_point; // weak
unsigned __int8 log_playback_mode;
char log_rdsamp_lowz_measuring_ac; // weak
char log_rdsamp_lowz_active_cause_of_enough_volts; // weak
char log_rdsamp_input_lpf_enabled; // weak
char log_rdsamp_input_1ms_peak_enabled; // weak
char log_rdsamp_in_ac_dc_mode; // weak
char log_rdsamp_temp_in_c; // weak
meter_meas_mode logged_meas_mode;
char logged_meas_range; // weak
char logged_meas_decimal_place; // weak
char log_prsamp_A_range_mode; // weak
char log_prsamp_B_flags; // weak
char log_prsamp_D_ex_volt_range_mode; // weak
char log_prsamp_E_ex_volt_flags; // weak
char log_prsamp_G_ex_amp_range_mode; // weak
char log_prsamp_H_ex_amp_flags; // weak
char log_rdsamp_A_range_mode; // weak
char log_rdsamp_B_flags; // weak
char log_rdsamp_D_ex_volt_range_mode; // weak
char log_rdsamp_E_ex_volt_flags; // weak
char log_rdsamp_G_ex_amp_range_mode; // weak
char log_rdsamp_H_ex_amp_flags; // weak
char logging_interval_maxspeed_timer_200ms; // weak
char log_start_year; // weak
char log_start_month; // weak
char log_start_day; // weak
char log_start_hour; // weak
char log_start_minute; // weak
char log_start_second; // weak
char log_end_year; // weak
char log_end_month; // weak
char log_end_day; // weak
char log_end_hour; // weak
char log_end_minute; // weak
char log_end_second; // weak
unsigned __int8 curr_sys_error;
char log_need_to_flush_samples_from_eeprom; // weak
char need_to_display_logging_ended; // weak
meter_meas_mode log_rdsamp_mode;
char log_rdsamp_range; // weak
char log_rdsamp_ex_volt_mode; // weak
char log_rdsamp_ex_volt_range; // weak
char log_rdsamp_ex_amp_mode; // weak
char log_rdsamp_ex_amp_range; // weak
char log_file_starting_new_link; // weak
char log_file_is_ending; // weak
char log_file_need_to_write_header; // weak
char byte_20003ACF; // weak
char byte_20003AD0; // weak
char byte_20003AD1; // weak
char byte_20003AD2; // weak
char bt_enabled; // weak
char bt_rx_buf_curr_pos; // weak
char bt_rx_buf_max_pos; // weak
char bt_rx_msg_len; // weak
char bt_new_received_msg; // weak
char bt_buf_cksum; // weak
char bt_set_the_time; // weak
char bt_rx_checksum_valid; // weak
meter_sub_mode curr_sub_mode;
char apo_woke_up; // weak
unsigned __int8 curr_apo_off;
char apo_trigger_poweroff; // weak
char batt_is_low_icon; // weak
meter_meas_mode curr_meas_mode;
unsigned __int8 curr_meas_range;
unsigned __int8 ac_input_freq_range;
char curr_scr_decimal_place; // weak
unsigned __int8 curr_subscr_decimal_loc;
unsigned __int8 curr_bargraph_bars;
char autoranging_disabled; // weak
char meter_overflow_was_negative; // weak
unsigned __int8 curr_scr_overflow;
char ac_input_hz_overflow; // weak
char scr_overload_displayed; // weak
__int8 meter_mode_changed;
char meter_range_changed; // weak
char bargraph_range; // weak
unsigned __int8 meter_min_max_mode;
unsigned __int8 manual_hold_is_enabled;
unsigned __int8 auto_hold_is_enabled;
unsigned __int8 auto_hold_need_to_unhold;
char auto_hold_holding; // weak
unsigned __int8 mode_range_just_got_changed_for_hold_purposes;
unsigned __int8 lcd_update_from_auto_hold;
char rel_meas_enabled; // weak
char rel_meas_got_rel_val; // weak
char lcd_needs_update; // weak
char autorange_changed_range; // weak
unsigned __int8 meas_was_updated;
char need_to_update_bargraph; // weak
unsigned __int8 force_new_measurement_available_on_range_mode_change;
char scr_need_to_refresh_meas_units_and_icons; // weak
char scr_need_to_update_units_in_certain_modes; // weak
char need_to_update_subscr; // weak
char subscr_need_to_update_units; // weak
char range_switch_was_switched; // weak
unsigned __int8 curr_range_switch_bits;
unsigned __int8 range_switch_inputs;
char new_buttons_pressed; // weak
char new_buttons_held; // weak
char bt_new_rxed_button; // weak
char curr_button_input; // weak
meter_buttons buttons_pressed;
meter_buttons buttons_held;
unsigned __int8 bt_pressed_keycode;
char setup_currently_editing; // weak
char blink_value_being_edited; // weak
char setup_edit_timeout_2min; // weak
char setup_serial_selected_digit; // weak
char button_hold_timer; // weak
char button_check_timer; // weak
char meter_curr_mode_is_timey_not_used; // weak
char amp_lead_in_ma_jack_only; // weak
char meter_amp_leads_incorrect; // weak
char beep_every_half_second; // weak
char beep_currently_beeping; // weak
unsigned __int8 beep_num_beeps;
char backlight_on; // weak
char hy_cap_related_always_set_to_zero; // weak
char curr_hy_R20; // weak
char curr_hy_R29; // weak
char curr_hy_pendingints; // weak
char hy_ad1_avg_ctr; // weak
char hy_AD1_new_avg; // weak
char hy_rms_new_avg; // weak
char hy_rms_avg_count; // weak
char meas_ara1_count; // weak
char meas_ara2_count; // weak
char cobait_timer; // weak
char cal_mode_save_to_sd; // weak
char cal_mode_load_from_sd; // weak
char meter_in_cal_mode; // weak
char setting_last_cal_year_month; // weak
char calibrating_offset; // weak
char calibrating_offset_finished; // weak
char calibrating_gain; // weak
char calibrating_gain_finished; // weak
char calibrating_ohms_50M_offset; // weak
char calibrating_400_unused; // weak
char calibrating_400_finished_unused; // weak
char calibrating_5k_unused; // weak
char calibrating_5k_end_unused; // weak
char cal_countdown_timer; // weak
char calibrating_thermistor_23c; // weak
char cal_switch_to_temp_on_subscr_delay; // weak
char lowz_measuring_ac; // weak
char lowz_active_cause_of_enough_volts; // weak
char some_unused_flag_always_zero; // weak
char hy_change_CTA_val_next; // weak
char cal_save_ac_factor_decirange; // weak
char cal_save_ac_factor_fullrange; // weak
char cal_save_ac_factor_decirange_lf; // weak
char cal_save_ac_factor_fullrange_lf; // weak
char ac_input_freq_range_acv; // weak
char ac_input_freq_range_lowz; // weak
char meas_cap_no_reading_timeout_elapsed; // weak
char burden_enabled_for_current_ranges; // weak
char edit_burden_enabled_for_current_ranges; // weak
char burden_overflow; // weak
char burden_enabled_for_power_ranges; // weak
char edit_burden_enabled_for_power_ranges; // weak
char burden_active_msg_showing_timer_1s; // weak
char temp_in_c; // weak
char curr_internal_temp_invalid; // weak
char temp_meas_sign; // weak
char there_was_a_temp_error; // weak
char curr_internal_temp_calc_invalid; // weak
char curr_internal_temp_calc_invalid_timer; // weak
char meter_danger_icon; // weak
char meter_overload; // weak
char high_voltage_diode; // weak
char meas_diode_reprocess_timer_1s; // weak
char continuity_beeping; // weak
char curr_continuity_threshold; // weak
char input_1ms_peak_enabled; // weak
char peakdet_show_min_always_zero; // weak
char input_lpf_enabled; // weak
char meter_mode_acv_dcv; // weak
char meas_acv_dcv_ac_value_updated; // weak
char meas_acv_dcv_dc_value_updated; // weak
char acv_dcv_measuring_dc; // weak
unsigned __int8 meas_acv_dcv_mode_switch_timer;
char subscr_showing_power_amps; // weak
char meas_va_never_processed; // weak
char measuring_amps_of_va_or_volts_of_burden; // weak
char meas_amp_burden_timer; // weak
char curr_power_volts_range; // weak
char curr_power_amps_range; // weak
char curr_power_volts_overflow; // weak
char curr_power_amps_overflow; // weak
char cal_manual_state; // weak
char cal_sd_state; // weak
char TIM3_1ms_interrupt_unused; // weak
char TIM2_10ms_interrupt; // weak
char TIM2_need_to_prepare_sample; // weak
char need_to_write_bt_packet; // weak
char setup_edit_timeout_subcounter_500ms; // weak
char rtc_last_read_was_new_second; // weak
char blink_dash_for_hour_minute; // weak
char editing_rightside_time_val; // weak
unsigned __int8 curr_year;
unsigned __int8 curr_month;
unsigned __int8 curr_day;
unsigned __int8 curr_hour;
unsigned __int8 curr_minute;
unsigned __int8 curr_second;
char edit_year; // weak
char edit_month; // weak
char edit_day; // weak
char edit_hour; // weak
char edit_minute; // weak
char byte_20003B74; // weak
char byte_20003B75; // weak
char byte_20003B76; // weak
char sdio_err_state; // weak
_UNKNOWN TIM2_0; // weak
_UNKNOWN TIM3; // weak
int LCD_CR; // weak
int LCD_FCR; // weak
int LCD_SR; // weak
int LCD_RAM0L; // weak
int LCD_RAM0H; // weak
int LCD_RAM1L; // weak
int LCD_RAM1H; // weak
int LCD_RAM2L; // weak
int LCD_RAM2H; // weak
int LCD_RAM3L; // weak
int LCD_RAM3H; // weak
int rtc_dword_40002808; // weak
_DWORD dword_4000280C[6]; // idb
int rtc_dword_40002824_unused; // weak
int rtc_dword_40002840; // weak
USART_REGS USART2_1;
int PWR_CR; // weak
int PWR_CSR; // weak
int EXTI_IMR; // weak
int EXTI_EMR; // weak
int EXTI_RTSR; // weak
int EXTI_FTSR; // weak
int EXTI_PR; // weak
ADC_REGS ADC1_BASE; // weak
int SDIO_POWER; // weak
int SDIO_CLKCR; // weak
int SDIO_ARG; // weak
int SDIO_CMD; // weak
int SDIO_RESPCMD; // weak
int SDIO_RESP[4]; // weak
int SDIO_DTIMER; // weak
int SDIO_DLEN; // weak
int SDIO_DCTRL; // weak
int SDIO_STA; // weak
int SDIO_ICR; // weak
int SDIO_MASK; // weak
int SDIO_FIFO; // weak
GPIO_REGS GPIOA;
GPIO_REGS GPIOB; // weak
GPIO_REGS GPIOC; // weak
GPIO_REGS GPIOD; // weak
GPIO_REGS GPIOE; // weak
GPIO_REGS GPIOH; // weak
GPIO_REGS GPIOF; // weak
GPIO_REGS GPIOG; // weak
_DWORD RCC_CR;
int RCC_ICSCR; // weak
int RCC_CFGR; // weak
int RCC_CIR; // weak
int RCC_APB2RSTR; // weak
int RCC_AHBENR; // weak
int RCC_APB2ENR; // weak
int RCC_APB1ENR; // weak
int unused_dword_40023828; // weak
int RCC_CSR; // weak
int FLASH_ACR; // weak
_DWORD FLASH_PECR;
int FLASH_PEKEYR; // weak
int FLASH_OPTKEYR; // weak
int FLASH_SR; // weak
int FLASH_OBR; // weak
int SCB_VTOR; // weak
unsigned int dword_E000ED0C;
int dword_E000ED10; // weak


//----- (08006124) --------------------------------------------------------
void __fastcall update_display()
{
  if ( !log_playback_mode )
  {
    if ( need_to_update_bargraph )
      update_bargraph_if_in_appropriate_range();
    if ( meas_was_updated | force_new_measurement_available_on_range_mode_change )
      scr_update_with_new_meas();
    if ( scr_need_to_refresh_meas_units_and_icons )
      scr_refresh_meas_units_and_icons();
    if ( scr_need_to_update_units_in_certain_modes )
      scr_update_units_in_certain_modes();
    if ( need_to_update_subscr )
      update_subscr();
    if ( subscr_mode_for_last_units != (unsigned __int8)curr_sub_mode || subscr_need_to_update_units )
    {
      subscr_mode_for_last_units = curr_sub_mode;
      subscr_need_to_update_units = 0;
      subscr_update_units();
    }
    if ( lcd_needs_update )
    {
      lcd_needs_update = 0;
      update_lcd_if_appropriate();
    }
  }
}
// 20003AF7: using guessed type char lcd_needs_update;
// 20003AF8: using guessed type char autorange_changed_range;
// 20003AFA: using guessed type char need_to_update_bargraph;
// 20003AFC: using guessed type char scr_need_to_refresh_meas_units_and_icons;
// 20003AFD: using guessed type char scr_need_to_update_units_in_certain_modes;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003AFF: using guessed type char subscr_need_to_update_units;

//----- (080061CA) --------------------------------------------------------
void __fastcall scr_update_with_new_meas()
{
  meas_was_updated = 0;
  force_new_measurement_available_on_range_mode_change = 0;
  if ( meter_amp_leads_incorrect )
  {
    show_lead_err(0);
    curr_scr_overflow = 0;
  }
  else if ( calibrating_offset )
  {
    curr_scr_overflow = 0;
    show_cal_msg_countdown(0);
  }
  else if ( calibrating_offset_finished )
  {
    calibrating_offset_finished = 0;
    curr_scr_overflow = 0;
    show_cal_msg_end(0);
  }
  else if ( calibrating_gain )
  {
    curr_scr_overflow = 0;
    show_cal_msg_countdown(1u);
  }
  else if ( calibrating_ohms_50M_offset )
  {
    curr_scr_overflow = 0;
    show_cal_msg_countdown(4u);
  }
  else if ( calibrating_gain_finished )
  {
    calibrating_gain_finished = 0;
    curr_scr_overflow = 0;
    show_cal_msg_end(1u);
  }
  else if ( calibrating_400_unused )
  {
    curr_scr_overflow = 0;
    show_cal_msg_countdown(2u);
  }
  else if ( calibrating_400_finished_unused )
  {
    calibrating_400_finished_unused = 0;
    curr_scr_overflow = 0;
    show_cal_msg_end(2u);
  }
  else if ( calibrating_5k_unused )
  {
    curr_scr_overflow = 0;
    show_cal_msg_countdown(3u);
  }
  else if ( calibrating_5k_end_unused )
  {
    calibrating_5k_end_unused = 0;
    curr_scr_overflow = 0;
    show_cal_msg_end(3u);
  }
  else if ( (meter_mode_range_change_delay || autorange_changed_range) && curr_meas_mode )
  {
    if ( !auto_hold_is_enabled )
      scr_erase(0);
    curr_scr_overflow = 0;
  }
  else if ( manual_hold_is_enabled | (unsigned __int8)(curr_scr_overflow ^ 1) )
  {
    if ( curr_scr_digits < 100000 && curr_scr_digits >= -99999 )
      scr_show_num(curr_meas_mode, curr_scr_decimal_place, curr_scr_digits);
  }
  else
  {
    show_overload(0);
    curr_scr_overflow = 0;
  }
}
// 20000223: using guessed type char meter_mode_range_change_delay;
// 20003858: using guessed type int curr_scr_digits;
// 20003AE3: using guessed type char curr_scr_decimal_place;
// 20003AF8: using guessed type char autorange_changed_range;
// 20003B12: using guessed type char meter_amp_leads_incorrect;
// 20003B26: using guessed type char calibrating_offset;
// 20003B27: using guessed type char calibrating_offset_finished;
// 20003B28: using guessed type char calibrating_gain;
// 20003B29: using guessed type char calibrating_gain_finished;
// 20003B2A: using guessed type char calibrating_ohms_50M_offset;
// 20003B2B: using guessed type char calibrating_400_unused;
// 20003B2C: using guessed type char calibrating_400_finished_unused;
// 20003B2D: using guessed type char calibrating_5k_unused;
// 20003B2E: using guessed type char calibrating_5k_end_unused;

//----- (0800638E) --------------------------------------------------------
void __fastcall log_playback_show_sample(unsigned __int16 sample)
{
  unsigned __int16 v2; // r0@1

  subscr_show_num(sample, 0, 0);
  v2 = log_get_eeprom_idx_for_sample(sample);
  log_read_sample_from_eeprom(v2 - 1);
  if ( log_rdsamp_C_main_measurement == 0x7FFFFFFF )
    show_overload(0);
  else
    scr_show_num(logged_meas_mode, logged_meas_decimal_place, log_rdsamp_C_main_measurement);
  update_lcd_if_appropriate();
}
// 20003814: using guessed type int log_rdsamp_C_main_measurement;
// 20003AA9: using guessed type char logged_meas_decimal_place;

//----- (080063E0) --------------------------------------------------------
void __fastcall scr_show_num(meter_meas_mode mode, unsigned __int8 point, int num)
{
  // show a decimal number on the main screen
  // num is the digits, point is where the . goes
  // point is 'number of digits to right of decimal point'
  // when hold is active, screen changes are locked out
  if ( !manual_hold_is_enabled )
  {
    scr_set_decimal_point(point);
    if ( num >= 0 )
    {
      segment_buffer_C1H &= ~S1H_MS_NEGATIVE;
    }
    else
    {
      num = -num;
      segment_buffer_C1H |= S1H_MS_NEGATIVE;
    }
    conv_uint_to_bcd_tmp(num);
    conv_bcd_tmp_to_scr(point);
    put_msg_on_scr(0, scr_msg_tmp);
    lcd_needs_update = 1;
  }
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (0800644A) --------------------------------------------------------
void __fastcall scr_set_decimal_point(unsigned __int8 decimals)
{
  // input is number of digits to the right of the decimal point
  // e.g. decimals = 1 -> 0000.0
  segment_buffer_C0L &= ~S0L_MS_POINT_d0;
  segment_buffer_C0H &= 0xFD5u;                 // turn off all three C0H dec points
  *(_DWORD *)&decimals = decimals;
  if ( decimals == 1 )
  {
    segment_buffer_C0L |= S0L_MS_POINT_d0;
  }
  else if ( decimals >= 1u )
  {
    if ( decimals == 3 )
    {
      segment_buffer_C0H |= S0H_MS_POINT_d000;
    }
    else if ( decimals >= 3u )
    {
      if ( decimals == 4 )
        segment_buffer_C0H |= S0H_MS_POINT_d0000;
    }
    else
    {
      segment_buffer_C0H |= S0H_MS_POINT_d00;
    }
  }
}

//----- (080064C6) --------------------------------------------------------
void __fastcall scr_update_decimal_point()
{
  curr_scr_decimal_place = calc_decimal_place_for_mode_range(curr_meas_mode, curr_meas_range);
  scr_set_decimal_point(curr_scr_decimal_place);
  update_lcd_if_appropriate();
}
// 20003AE3: using guessed type char curr_scr_decimal_place;

//----- (080064EE) --------------------------------------------------------
void scr_refresh_meas_units_and_icons(void)
{
  scr_need_to_refresh_meas_units_and_icons = 0;
  scr_update_status_icons();
  scr_turn_off_units();
  scr_update_units(curr_meas_mode, curr_meas_range, lowz_measuring_ac, lowz_active_cause_of_enough_volts);
  scr_reset_bargraph();
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;
// 20003AFC: using guessed type char scr_need_to_refresh_meas_units_and_icons;
// 20003B32: using guessed type char lowz_measuring_ac;
// 20003B33: using guessed type char lowz_active_cause_of_enough_volts;

//----- (0800652A) --------------------------------------------------------
void __fastcall scr_update_status_icons()
{
  scr_update_apo_status(0);
  scr_update_low_batt_icon(0);
  scr_update_bt_icon(0);
  scr_update_autorange_icon(0);
  scr_update_hold_icons(0);
  scr_update_min_max_icons(0);
  scr_update_rel_meas_icon(0);
  scr_update_1ms_peak_icon(0);
  scr_update_lpf_icon();
  scr_update_main_acdc_icons();
  scr_update_danger_icon();
  scr_update_temp_unit();
  scr_update_mem_icon(0);
}

//----- (08006574) --------------------------------------------------------
void __fastcall scr_update_units(meter_meas_mode mode, unsigned __int8 range, char f_lowz_ac, unsigned __int8 f_lowz_active)
{
  *(_DWORD *)&mode = mode;
  if ( mode )
  {
    switch ( mode )
    {
      case MM_DCV:
        segment_buffer_C2L |= S2L_MS_VOLTS;
        break;
      case MM_ACV:
        segment_buffer_C2L |= S2L_MS_VOLTS;
        break;
      case MM_DCmV:
        segment_buffer_C1L |= S1L_MS_MILLI;
        segment_buffer_C2L |= S2L_MS_VOLTS;
        break;
      case MM_ACmV:
        segment_buffer_C1L |= S1L_MS_MILLI;
        segment_buffer_C2L |= S2L_MS_VOLTS;
        break;
      case MM_HZ:
        scr_update_hz_units(range);
        break;
      case MM_mSEC:
        segment_buffer_C3L |= S3L_MS_mSEC;
        break;
      case MM_DUTY:
        segment_buffer_C0L |= S0L_MS_DUTY_PERCENT;
        break;
      case MM_OHMS:
        scr_update_ohm_units(range);
        break;
      case MM_CONTINUITY:
        segment_buffer_C2L |= S2L_ICON_CONTINUITY;
        segment_buffer_C1L |= S1L_MS_OHMS;
        break;
      case MM_DIODE:
        segment_buffer_C3L |= S3L_ICON_DIODE;
        segment_buffer_C2L |= S2L_MS_VOLTS;
        break;
      case MM_CAP:
        scr_update_cap_units(range);
        break;
      case MM_ACuVA:
        segment_buffer_C0L |= S0L_MS_MICRO;
        segment_buffer_C2L |= S2L_MS_VOLTS;
        segment_buffer_C3L |= S3L_MS_AMPS;
        segment_buffer_C0H |= S0H_MS_AC;
        break;
      case MM_ACmVA:
        segment_buffer_C1L |= S1L_MS_MILLI;
        segment_buffer_C2L |= S2L_MS_VOLTS;
        segment_buffer_C3L |= S3L_MS_AMPS;
        segment_buffer_C0H |= S0H_MS_AC;
        break;
      case MM_ACVA:
        if ( (signed int)range < 2 )
          segment_buffer_C1L |= S1L_MS_MILLI;
        segment_buffer_C2L |= S2L_MS_VOLTS;
        segment_buffer_C3L |= S3L_MS_AMPS;
        segment_buffer_C0H |= S0H_MS_AC;
        break;
      case MM_ACuA:
        segment_buffer_C0L |= S0L_MS_MICRO;
        segment_buffer_C3L |= S3L_MS_AMPS;
        break;
      case MM_DCuA:
        segment_buffer_C0L |= S0L_MS_MICRO;
        segment_buffer_C3L |= S3L_MS_AMPS;
        break;
      case MM_ACmA:
        segment_buffer_C1L |= S1L_MS_MILLI;
        segment_buffer_C3L |= S3L_MS_AMPS;
        break;
      case MM_DCmA:
        segment_buffer_C1L |= S1L_MS_MILLI;
        segment_buffer_C3L |= S3L_MS_AMPS;
        break;
      case MM_ACA:
        if ( !range )
          segment_buffer_C1L |= S1L_MS_MILLI;
        segment_buffer_C3L |= S3L_MS_AMPS;
        break;
      case MM_DCA:
        if ( !range )
          segment_buffer_C1L |= S1L_MS_MILLI;
        segment_buffer_C3L |= S3L_MS_AMPS;
        break;
      case MM_DCuVA:
        segment_buffer_C0L |= S0L_MS_MICRO;
        segment_buffer_C2L |= S2L_MS_VOLTS;
        segment_buffer_C3L |= S3L_MS_AMPS;
        segment_buffer_C2H |= S2H_MS_DC;
        break;
      case MM_DCmVA:
        segment_buffer_C1L |= S1L_MS_MILLI;
        segment_buffer_C2L |= S2L_MS_VOLTS;
        segment_buffer_C3L |= S3L_MS_AMPS;
        segment_buffer_C2H |= S2H_MS_DC;
        break;
      case MM_DCVA:
        if ( (signed int)range < 2 )
          segment_buffer_C1L |= S1L_MS_MILLI;
        segment_buffer_C2L |= S2L_MS_VOLTS;
        segment_buffer_C3L |= S3L_MS_AMPS;
        segment_buffer_C2H |= S2H_MS_DC;
        break;
    }
  }
  else                                          // MM_LOWZ
  {
    segment_buffer_C1H = 2 * ((unsigned int)segment_buffer_C1H >> 1);// S1H_MS_PLUS_OF_AC_DC
    if ( f_lowz_active )
    {
      if ( f_lowz_ac )
        segment_buffer_C0H |= S0H_MS_AC;
      else
        segment_buffer_C2H |= S2H_MS_DC;
    }
    else
    {
      segment_buffer_C2H = 2 * ((unsigned int)segment_buffer_C2H >> 1);// S2H_MS_DC
      segment_buffer_C0H = 2 * ((unsigned int)segment_buffer_C0H >> 1);// S0H_MS_AC
    }
    segment_buffer_C0L |= S0L_ICON_LOWZ;
    segment_buffer_C2L |= S2L_MS_VOLTS;
  }
}

//----- (080069B8) --------------------------------------------------------
void __fastcall scr_update_milli_for_VA(meter_meas_mode mode, unsigned __int8 range)
{
  if ( mode == MM_DCVA || mode == MM_ACVA )
  {
    if ( (signed int)range < 2 )
      segment_buffer_C1L |= S1L_MS_MILLI;
    else
      segment_buffer_C1L &= ~S1L_MS_MILLI;
  }
}

//----- (080069E6) --------------------------------------------------------
void scr_update_for_playback()
{
  logged_meas_decimal_place = calc_decimal_place_for_mode_range(logged_meas_mode, (unsigned __int8)logged_meas_range);
  scr_update_status_icons();
  scr_turn_off_units();
  scr_update_units(
    logged_meas_mode,
    logged_meas_range,
    log_rdsamp_lowz_measuring_ac,
    log_rdsamp_lowz_active_cause_of_enough_volts);
  scr_turn_off_bargraph();
  update_lcd_if_appropriate();
}
// 20003AA1: using guessed type char log_rdsamp_lowz_measuring_ac;
// 20003AA2: using guessed type char log_rdsamp_lowz_active_cause_of_enough_volts;
// 20003AA8: using guessed type char logged_meas_range;
// 20003AA9: using guessed type char logged_meas_decimal_place;

//----- (08006A26) --------------------------------------------------------
void scr_update_units_in_certain_modes(void)
{
  scr_need_to_update_units_in_certain_modes = 0;
  switch ( curr_meas_mode )
  {
    case MM_HZ:
      scr_update_hz_units(curr_meas_range);
      break;
    case MM_OHMS:
      scr_update_ohm_units(curr_meas_range);
      break;
    case MM_CAP:
      scr_update_cap_units(curr_meas_range);
      break;
  }
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;
// 20003AFD: using guessed type char scr_need_to_update_units_in_certain_modes;

//----- (08006A64) --------------------------------------------------------
void __fastcall scr_update_cap_units(unsigned __int8 range)
{
  if ( (signed int)range >= 2 )
  {
    segment_buffer_C0L |= S0L_MS_MICRO;
    segment_buffer_C1L &= ~S1L_MS_NANO;
  }
  else
  {
    segment_buffer_C0L &= ~S0L_MS_MICRO;
    segment_buffer_C1L |= S1L_MS_NANO;
  }
  segment_buffer_C2L |= S2L_MS_FARADS;
}

//----- (08006AAA) --------------------------------------------------------
void __fastcall scr_update_ohm_units(unsigned __int8 range)
{
  if ( (signed int)range < 5 )
  {
    if ( (signed int)range < 2 )
    {
      segment_buffer_C0L &= ~S0L_MS_KILO;
      segment_buffer_C0L &= ~S0L_MS_MEGA;
    }
    else
    {
      segment_buffer_C0L |= S0L_MS_KILO;
      segment_buffer_C0L &= ~S0L_MS_MEGA;
    }
  }
  else
  {
    segment_buffer_C0L &= ~S0L_MS_KILO;
    segment_buffer_C0L |= S0L_MS_MEGA;
  }
  segment_buffer_C1L |= S1L_MS_OHMS;
}

//----- (08006B10) --------------------------------------------------------
void __fastcall scr_update_hz_units(unsigned __int8 range)
{
  if ( (signed int)range < 5 )
  {
    if ( (signed int)range < 2 )
    {
      segment_buffer_C0L &= ~S0L_MS_KILO;
      segment_buffer_C0L &= ~S0L_MS_MEGA;
    }
    else
    {
      segment_buffer_C0L |= S0L_MS_KILO;
      segment_buffer_C0L &= ~S0L_MS_MEGA;
    }
  }
  else
  {
    segment_buffer_C0L &= ~S0L_MS_KILO;
    segment_buffer_C0L |= S0L_MS_MEGA;
  }
  segment_buffer_C2L |= S2L_MS_HERTZ;
}

//----- (08006C10) --------------------------------------------------------
void __fastcall update_subscr()
{
  unsigned __int8 v0; // r5@11
  int v1; // r4@11
  signed int v2; // r4@33

  need_to_update_subscr = 0;
  if ( need_to_display_logging_ended )
  {
    show_msg_logging_ended();
  }
  else if ( curr_sys_error )
  {
    if ( curr_sys_error == 20 )
      show_low_batt();
    else
      show_sd_error(curr_sys_error);
  }
  else if ( curr_sub_mode == SM_LOG_POS )
  {
    if ( logging_active )
    {
      if ( (unsigned int)log_total_samples >= 100000 )
      {
        v0 = 2;
        v1 = log_total_samples / 10u;
        segment_buffer_C2L |= S2L_SS_KILO;
      }
      else
      {
        v0 = 0;
        v1 = log_total_samples;
        segment_buffer_C2L &= ~S2L_SS_KILO;
      }
      subscr_show_num(v1, v0, 0);
    }
    else
    {
      subscr_show_num((unsigned __int16)log_playback_pos, 0, 0);
    }
  }
  else if ( (unsigned __int8)setup_currently_editing & (unsigned __int8)(blink_value_being_edited ^ 1) )
  {
    erase_part_of_screen_in_order_to_blink_value_being_edited();
  }
  else if ( !meter_in_cal_mode || cal_switch_to_temp_on_subscr_delay )
  {
    if ( meter_in_cal_mode && cal_switch_to_temp_on_subscr_delay )
    {
      --cal_switch_to_temp_on_subscr_delay;
      curr_sub_mode = SM_TEMP;
    }
    switch ( curr_sub_mode )
    {
      case SM_SPL3:
        if ( (curr_meas_mode == MM_ACuVA
           || curr_meas_mode == MM_ACmVA
           || curr_meas_mode == MM_ACVA
           || curr_meas_mode == MM_DCuVA
           || curr_meas_mode == MM_DCmVA
           || curr_meas_mode == MM_DCVA)
          && burden_enabled_for_power_ranges )
        {
          if ( curr_power_amps_range )
            v2 = 10 * meter_power_amps;
          else
            v2 = 100 * meter_power_amps;
          subscr_disp_burden_voltage(v2, curr_power_amps_range);
        }
        else if ( (curr_meas_mode == MM_ACuA || curr_meas_mode == MM_ACmA || curr_meas_mode == MM_ACA)
               && burden_enabled_for_current_ranges )
        {
          subscr_show_ac_input_hz();
        }
        break;
      case SM_SPL2:
        if ( curr_meas_mode == MM_ACV )
        {
          subscr_show_dBm();
        }
        else if ( curr_meas_mode != MM_ACuVA
               && curr_meas_mode != MM_ACmVA
               && curr_meas_mode != MM_ACVA
               && curr_meas_mode != MM_DCuVA
               && curr_meas_mode != MM_DCmVA
               && curr_meas_mode != MM_DCVA )
        {
          if ( (curr_meas_mode == MM_ACuA
             || curr_meas_mode == MM_ACmA
             || curr_meas_mode == MM_ACA
             || curr_meas_mode == MM_DCuA
             || curr_meas_mode == MM_DCmA
             || curr_meas_mode == MM_DCA)
            && burden_enabled_for_current_ranges )
          {
            subscr_disp_burden_voltage(burden_last_volts, 100);
          }
          else if ( (curr_meas_mode == MM_ACuA || curr_meas_mode == MM_ACmA || curr_meas_mode == MM_ACA)
                 && !burden_enabled_for_current_ranges )
          {
            subscr_show_ac_input_hz();
          }
        }
        else
        {
          show_burden_display_status(edit_burden_enabled_for_power_ranges);
        }
        break;
      case SM_SPL1:
        if ( curr_meas_mode != MM_ACuVA
          && curr_meas_mode != MM_ACmVA
          && curr_meas_mode != MM_ACVA
          && curr_meas_mode != MM_DCuVA
          && curr_meas_mode != MM_DCmVA
          && curr_meas_mode != MM_DCVA )
        {
          if ( curr_meas_mode == MM_DIODE )
          {
            show_diode_voltage();
          }
          else if ( curr_meas_mode == MM_CONTINUITY )
          {
            show_continuity_threshold(curr_continuity_threshold);
          }
          else if ( curr_meas_mode != MM_ACuA
                 && curr_meas_mode != MM_ACmA
                 && curr_meas_mode != MM_ACA
                 && curr_meas_mode != MM_DCuA
                 && curr_meas_mode != MM_DCmA
                 && curr_meas_mode != MM_DCA )
          {
            if ( (curr_meas_mode != MM_ACV || meter_mode_acv_dcv) && curr_meas_mode != MM_ACmV )
            {
              curr_sub_mode = 0;
              show_temperature(curr_internal_temperature);
            }
            else
            {
              subscr_show_ac_input_hz();
            }
          }
          else
          {
            show_burden_display_status(edit_burden_enabled_for_current_ranges);
          }
        }
        else if ( subscr_showing_power_amps )
        {
          subscr_calc_power_amp_point();
          if ( curr_power_amps_overflow )
            show_overload(1);
          else
            subscr_show_digits(meter_power_amps);
        }
        else
        {
          if ( curr_power_volts_range )
            curr_subscr_decimal_loc = 3;
          else
            curr_subscr_decimal_loc = 4;
          if ( curr_power_volts_overflow )
            show_overload(1);
          else
            subscr_show_digits(meter_power_volts);
        }
        break;
      case SM_CONTRAST:
        show_contrast(curr_lcd_contrast);
        break;
      case SM_HOUR_MINUTE:
        if ( setup_currently_editing )
          show_two_nums_on_subscreen_with_dash(0, edit_hour, edit_minute);
        else
          show_two_nums_on_subscreen_with_dash(0, curr_hour, curr_minute);
        break;
      case SM_MONTH_DAY:
        if ( setup_currently_editing )
          show_two_nums_on_subscreen(0, edit_month, edit_day);
        else
          show_two_nums_on_subscreen(0, curr_month, curr_day);
        break;
      case SM_YEAR:
        if ( setup_currently_editing )
          show_year_on_subscreen(0, edit_year);
        else
          show_year_on_subscreen(0, curr_year);
        break;
      case SM_METER_SERIAL:
        show_meter_serial(1);
        break;
      case SM_LOG_INTERVAL:
        if ( setup_currently_editing )
          show_logging_interval(edit_logging_interval);
        else
          show_logging_interval(curr_logging_interval);
        break;
      case SM_APO:
        show_apo_status(curr_apo_off);
        break;
      case SM_BATTERY:
        segment_buffer_C1L |= 0x20000u;
        segment_buffer_C2L &= 0xFFFFF7FF;
        segment_buffer_C3L &= 0xFFFFF7FF;
        show_batt_charge(curr_batt_charge);
        break;
      default:                                  // temperature
        curr_sub_mode = 0;
        show_temperature(curr_internal_temperature);
        break;
    }
  }
  else
  {
    show_cal_mode_msg_on_subscr();
  }
}
// 20000222: using guessed type char curr_lcd_contrast;
// 20003830: using guessed type int log_total_samples;
// 2000394C: using guessed type int burden_last_volts;
// 2000398C: using guessed type int meter_power_volts;
// 20003990: using guessed type int meter_power_amps;
// 20003A54: using guessed type __int16 log_playback_pos;
// 20003A5E: using guessed type __int16 edit_logging_interval;
// 20003A6E: using guessed type __int16 curr_batt_charge;
// 20003A7E: using guessed type __int16 curr_internal_temperature;
// 20003AC5: using guessed type char need_to_display_logging_ended;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B0A: using guessed type char setup_currently_editing;
// 20003B0B: using guessed type char blink_value_being_edited;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B31: using guessed type char cal_switch_to_temp_on_subscr_delay;
// 20003B3D: using guessed type char burden_enabled_for_current_ranges;
// 20003B3E: using guessed type char edit_burden_enabled_for_current_ranges;
// 20003B40: using guessed type char burden_enabled_for_power_ranges;
// 20003B41: using guessed type char edit_burden_enabled_for_power_ranges;
// 20003B4E: using guessed type char curr_continuity_threshold;
// 20003B52: using guessed type char meter_mode_acv_dcv;
// 20003B57: using guessed type char subscr_showing_power_amps;
// 20003B5B: using guessed type char curr_power_volts_range;
// 20003B5C: using guessed type char curr_power_amps_range;
// 20003B5D: using guessed type char curr_power_volts_overflow;
// 20003B5E: using guessed type char curr_power_amps_overflow;
// 20003B6F: using guessed type char edit_year;
// 20003B70: using guessed type char edit_month;
// 20003B71: using guessed type char edit_day;
// 20003B72: using guessed type char edit_hour;
// 20003B73: using guessed type char edit_minute;

//----- (080071A2) --------------------------------------------------------
void __fastcall subscr_show_num(int num, unsigned __int8 point, char update_now)
{
  // show a decimal number on the main screen
  // num is the digits, point is where the . goes
  // point is 'number of digits to right of decimal point'
  if ( num >= 0 )
  {
    segment_buffer_C2L &= ~S2L_SS_NEGATIVE;
  }
  else
  {
    num = -num;
    segment_buffer_C2L |= S2L_SS_NEGATIVE;
  }
  subscr_set_decimal_point(point);
  conv_uint_to_bcd_tmp(num);
  conv_bcd_tmp_to_scr(point);
  put_msg_on_scr(1, scr_msg_tmp);
  if ( update_now )
    update_lcd_if_appropriate();
  else
    lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (0800720E) --------------------------------------------------------
void subscr_show_ac_input_hz(void)
{
  set_point_for_ac_input_hz();
  subscr_show_num(ac_input_freq / 10, curr_subscr_decimal_loc, 0);
}
// 20003870: using guessed type int ac_input_freq;

//----- (0800722E) --------------------------------------------------------
void __fastcall subscr_set_decimal_point(unsigned __int8 decimals)
{
  // input is number of places to the right of the dec point
  // e.g. decimals = 1 -> 0000.0
  segment_buffer_C0L &= ~(S0L_SS_POINT_d0000|S0L_SS_POINT_d000|S0L_SS_POINT_d00|S0L_SS_POINT_d0);
  *(_DWORD *)&decimals = decimals;
  if ( decimals == 1 )
  {
    segment_buffer_C0L |= S0L_SS_POINT_d0;
  }
  else if ( decimals >= 1u )
  {
    if ( decimals == 3 )
    {
      segment_buffer_C0L |= S0L_SS_POINT_d000;
    }
    else if ( decimals >= 3u )
    {
      if ( decimals == 4 )
        segment_buffer_C0L |= S0L_SS_POINT_d0000;
    }
    else
    {
      segment_buffer_C0L |= S0L_SS_POINT_d00;
    }
  }
}

//----- (08007298) --------------------------------------------------------
void subscr_calc_power_amp_point()
{
  if ( curr_meas_mode != MM_ACuVA && curr_meas_mode != MM_DCuVA )
  {
    if ( curr_meas_mode != MM_ACmVA && curr_meas_mode != MM_DCmVA )
    {
      if ( curr_power_amps_range )
        curr_subscr_decimal_loc = 3;
      else
        curr_subscr_decimal_loc = 2;
    }
    else if ( curr_power_amps_range )
    {
      curr_subscr_decimal_loc = 3;
    }
    else
    {
      curr_subscr_decimal_loc = 4;
    }
  }
  else
  {
    curr_subscr_decimal_loc = 4;
  }
}
// 20003B5C: using guessed type char curr_power_amps_range;

//----- (08007306) --------------------------------------------------------
void set_point_for_ac_input_hz(void)
{
  curr_subscr_decimal_loc = 0;
  if ( curr_meas_mode == MM_ACuA
    || curr_meas_mode == MM_ACmA
    || curr_meas_mode == MM_ACA
    || curr_meas_mode == MM_ACV
    || curr_meas_mode == MM_ACmV )
    curr_subscr_decimal_loc = calc_point_for_ac_hz(ac_input_freq_range);
  subscr_set_decimal_point(curr_subscr_decimal_loc);
}

//----- (0800735E) --------------------------------------------------------
unsigned __int8 __fastcall calc_point_for_ac_hz(unsigned __int8 a1)
{
  unsigned __int8 v1; // r1@1
  unsigned __int8 result; // r0@1

  v1 = a1;
  result = 0;
  if ( v1 )
  {
    if ( v1 == 2 )
    {
      result = 3;
    }
    else if ( v1 >= 2u )
    {
      if ( v1 == 4 )
      {
        result = 1;
      }
      else if ( v1 < 4u )
      {
        result = 2;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = 2;
  }
  return result;
}

//----- (08007396) --------------------------------------------------------
void erase_part_of_screen_in_order_to_blink_value_being_edited(void)
{
  segment_buffer_C2L &= ~S2L_SS_NEGATIVE;
  subscr_set_decimal_point(0);
  if ( curr_sub_mode != SM_HOUR_MINUTE && curr_sub_mode != SM_MONTH_DAY )
  {
    if ( curr_sub_mode == SM_METER_SERIAL )
      put_chr_on_scr_at_offset(4 - setup_serial_selected_digit, (unsigned __int8 *)" ");
    else
      put_msg_on_scr(1, "     ");
  }
  else if ( editing_rightside_time_val )
  {
    put_2_chrs_on_scr_at_offset(3u, (unsigned __int8 *)"  ");
  }
  else
  {
    put_2_chrs_on_scr_at_offset(0, (unsigned __int8 *)"  ");
  }
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;
// 20003B0D: using guessed type char setup_serial_selected_digit;
// 20003B68: using guessed type char editing_rightside_time_val;

//----- (08007410) --------------------------------------------------------
void __fastcall subscr_show_digits(int digits)
{
  if ( digits >= 0 )
  {
    segment_buffer_C2L &= ~S2L_SS_NEGATIVE;
  }
  else
  {
    segment_buffer_C2L |= S2L_SS_NEGATIVE;
    digits = -digits;
  }
  subscr_set_decimal_point(curr_subscr_decimal_loc);
  conv_uint_to_bcd_tmp(digits);
  conv_bcd_tmp_to_scr(curr_subscr_decimal_loc);
  put_msg_on_scr(1, scr_msg_tmp);
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (0800747C) --------------------------------------------------------
void __fastcall subscr_disp_burden_voltage(signed int meas, char a2)
{
  signed int v2; // r8@1
  signed int v3; // r6@3
  char v4; // r5@5
  int v5; // r7@6

  v2 = 0;
  if ( burden_active_msg_showing_timer_1s )
  {
    show_burden_msg();
  }
  else
  {
    v3 = meas;
    if ( meas < 0 )
    {
      v3 = -meas;
      v2 = 1;
    }
    v4 = a2;
    if ( a2 == 100 )
    {
      v5 = v3;
    }
    else
    {
      v4 = a2;
      if ( a2 )
      {
        v5 = v3 / 100;
        if ( v3 % 100 >= 50 )
          ++v5;
      }
      else
      {
        v5 = v3 / 1000;
        if ( v3 % 1000 >= 500 )
          ++v5;
      }
    }
    curr_burden_voltage = v5;
    if ( v2 )
      curr_burden_voltage = -curr_burden_voltage;
    if ( v4 == 100 && burden_overflow )
    {
      scr_msg_tmp[1] = ' ';
      scr_msg_tmp[2] = 'O';
      scr_msg_tmp[3] = 'F';
      scr_msg_tmp[4] = 'L';
    }
    else
    {
      conv_uint_to_bcd_tmp(v5);
      curr_subscr_decimal_loc = 1;
      subscr_set_decimal_point(1u);
      conv_bcd_tmp_to_scr(curr_subscr_decimal_loc);
    }
    if ( v2 )
      segment_buffer_C2L |= S2L_SS_NEGATIVE;
    else
      segment_buffer_C2L &= ~S2L_SS_NEGATIVE;
    scr_msg_tmp[0] = 'b';
    put_msg_on_scr(1, scr_msg_tmp);
  }
  lcd_needs_update = 1;
}
// 20003A7C: using guessed type __int16 curr_burden_voltage;
// 20003AF7: using guessed type char lcd_needs_update;
// 20003B3F: using guessed type char burden_overflow;
// 20003B42: using guessed type char burden_active_msg_showing_timer_1s;

//----- (080075AA) --------------------------------------------------------
void __fastcall show_burden_msg()
{
  subscr_set_decimal_point(0);
  scr_msg_tmp[0] = 'b';
  scr_msg_tmp[1] = 'u';
  scr_msg_tmp[2] = 'r';
  scr_msg_tmp[3] = 'd';
  scr_msg_tmp[4] = 'n';
  put_msg_on_scr(1, scr_msg_tmp);
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (080075EE) --------------------------------------------------------
void __fastcall show_batt_charge(signed __int16 percent)
{
  signed __int16 v1; // r4@1

  v1 = percent;
  curr_subscr_decimal_loc = 1;
  subscr_set_decimal_point(1u);
  if ( (signed int)(unsigned __int16)v1 >= 100 )
    v1 = 99;
  conv_uint_to_bcd_tmp((unsigned __int16)v1);
  scr_msg_tmp[0] = 'B';
  scr_msg_tmp[1] = 'A';
  scr_msg_tmp[2] = 'T';
  scr_msg_tmp[3] = LOBYTE(disp_bcd_tmp[3]) + 48;
  scr_msg_tmp[4] = LOBYTE(disp_bcd_tmp[4]) + 48;
  put_msg_on_scr(1, scr_msg_tmp);
  lcd_needs_update = 1;
}
// 20003890: using guessed type int disp_bcd_tmp[5];
// 20003AF7: using guessed type char lcd_needs_update;

//----- (08007664) --------------------------------------------------------
void __fastcall show_contrast(char contrast)
{
  subscr_set_decimal_point(0);
  scr_msg_tmp[0] = 'L';
  scr_msg_tmp[1] = 'c';
  scr_msg_tmp[2] = 'd';
  scr_msg_tmp[3] = '-';
  scr_msg_tmp[4] = contrast + 38;
  put_msg_on_scr(1, scr_msg_tmp);
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (080076B4) --------------------------------------------------------
void __fastcall show_apo_status(char is_off)
{
  subscr_set_decimal_point(2u);
  if ( is_off )
    put_msg_on_scr(1, "APOoF");
  else
    put_msg_on_scr(1, "APOoN");
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (080076E4) --------------------------------------------------------
void __fastcall show_logging_interval(unsigned __int16 interval)
{
  unsigned __int16 v1; // r4@1
  int v2; // r5@1

  v1 = interval;
  LOWORD(v2) = interval;
  subscr_set_decimal_point(0);
  scr_msg_tmp[0] = 'I';
  scr_msg_tmp[1] = 'n';
  if ( (signed int)v1 < 100 )
  {
    scr_msg_tmp[2] = 0x20;
  }
  else
  {
    scr_msg_tmp[2] = (unsigned __int16)v2 / 100 + 48;
    v2 = (unsigned __int16)v2 % 100;
  }
  if ( (signed int)v1 < 10 )
    scr_msg_tmp[3] = 32;
  else
    scr_msg_tmp[3] = (unsigned __int16)v2 / 10 + 48;
  scr_msg_tmp[4] = (unsigned __int16)v2 % 10 + 48;
  put_msg_on_scr(1, scr_msg_tmp);
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (0800779C) --------------------------------------------------------
void __fastcall subscr_show_dBm()
{
  unsigned __int8 cf; // cf@3
  float v1; // r4@4
  char zf; // zf@6
  int v3; // r5@7
  float v4; // r0@9
  float v5; // r0@11
  float v6; // r0@12

  if ( curr_scr_overflow )
  {
    show_overload(1);
  }
  else
  {
    fp_compare_c_ge(curr_subscr_dBm, 0.0);
    if ( cf )                                   // >= 0
    {
      segment_buffer_C2L &= ~S2L_SS_NEGATIVE;
      v1 = curr_subscr_dBm;
    }
    else
    {
      segment_buffer_C2L |= S2L_SS_NEGATIVE;
      LODWORD(v1) = LODWORD(curr_subscr_dBm) ^ 0x80000000;
    }
    fp_compare_c_le(v1, 1000.0);
    if ( !zf & cf )                             // v5 < 1000
    {
      fp_compare_c_le(v1, 100.0);
      if ( !zf & cf )                           // v5 < 100
      {
        fp_compare_c_le(v1, 10.0);
        if ( !zf & cf )                         // v5 < 10
        {
          curr_subscr_decimal_loc = 3;
          v6 = fp_mul(1000.0, v1);
          v3 = fp_to_uint(v6);
        }
        else
        {
          curr_subscr_decimal_loc = 2;
          v5 = fp_mul(100.0, v1);
          v3 = fp_to_uint(v5);
        }
      }
      else
      {
        curr_subscr_decimal_loc = 1;
        v4 = fp_mul(10.0, v1);
        v3 = fp_to_uint(v4);
      }
    }
    else
    {
      curr_subscr_decimal_loc = 0;
      v3 = fp_to_uint(v1);
    }
    fp_compare_c_ge(curr_subscr_dBm, 0.0);
    if ( cf )                                   // >= 0
      curr_subscr_digits = v3;
    else
      curr_subscr_digits = -v3;
    subscr_set_decimal_point(curr_subscr_decimal_loc);
    conv_uint_to_bcd_tmp(v3);
    conv_bcd_tmp_to_scr(curr_subscr_decimal_loc);
    put_msg_on_scr(1, scr_msg_tmp);
    lcd_needs_update = 1;
  }
}
// 20003978: using guessed type int curr_subscr_digits;
// 20003AF7: using guessed type char lcd_needs_update;

//----- (080078C0) --------------------------------------------------------
void __fastcall show_burden_display_status(char on)
{
  char v1; // r4@1

  v1 = on;
  subscr_set_decimal_point(3u);
  if ( v1 )
    put_msg_on_scr(1, "bdOn ");
  else
    put_msg_on_scr(1, "bdOFF");
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (080078F8) --------------------------------------------------------
void show_diode_voltage()
{
  subscr_set_decimal_point(0);
  if ( high_voltage_diode )
    put_msg_on_scr(1, "   15");
  else
    put_msg_on_scr(1, "    3");
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;
// 20003B4B: using guessed type char high_voltage_diode;

//----- (08007934) --------------------------------------------------------
void __fastcall show_continuity_threshold(unsigned __int8 threshold)
{
  unsigned __int8 v1; // r4@1

  v1 = threshold;
  segment_buffer_C2L &= ~S2L_SS_NEGATIVE;
  subscr_set_decimal_point(0);
  if ( v1 )
  {
    if ( v1 == 2 )
    {
      put_msg_on_scr(1, "DN300");
    }
    else if ( v1 >= 2u )
    {
      if ( v1 == 3 )
        put_msg_on_scr(1, "UP300");
    }
    else
    {
      put_msg_on_scr(1, "UP 30");
    }
  }
  else
  {
    put_msg_on_scr(1, "DN 30");
  }
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (0800799C) --------------------------------------------------------
void __fastcall show_year_on_subscreen(char update_now, unsigned __int8 year_offset)
{
  char v2; // r4@1
  unsigned int v3; // r6@1

  v2 = update_now;
  v3 = year_offset + 2000;
  subscr_set_decimal_point(0);
  conv_uint_to_bcd_tmp(v3);
  conv_bcd_tmp_to_scr(0);
  put_msg_on_scr(1, scr_msg_tmp);
  if ( v2 )
    update_lcd_if_appropriate();
  else
    lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (080079E0) --------------------------------------------------------
void __fastcall show_two_nums_on_subscreen(char update_now, unsigned __int8 left, unsigned __int8 right)
{
  char v3; // r4@1
  unsigned __int8 v4; // r7@1
  unsigned int v5; // r8@1

  v3 = update_now;
  v4 = left;
  v5 = right;
  subscr_set_decimal_point(0);
  conv_uint_to_bcd_tmp(v4);
  disp_bcd_tmp[3] += 48;
  scr_msg_tmp[0] = LOBYTE(disp_bcd_tmp[3]);
  disp_bcd_tmp[4] += 48;
  scr_msg_tmp[1] = LOBYTE(disp_bcd_tmp[4]);
  scr_msg_tmp[2] = 45;
  conv_uint_to_bcd_tmp(v5);
  disp_bcd_tmp[3] += 48;
  scr_msg_tmp[3] = LOBYTE(disp_bcd_tmp[3]);
  disp_bcd_tmp[4] += 48;
  scr_msg_tmp[4] = LOBYTE(disp_bcd_tmp[4]);
  put_msg_on_scr(1, scr_msg_tmp);
  if ( v3 )
    update_lcd_if_appropriate();
  else
    lcd_needs_update = 1;
}
// 20003890: using guessed type int disp_bcd_tmp[5];
// 20003AF7: using guessed type char lcd_needs_update;

//----- (08007A88) --------------------------------------------------------
void __fastcall show_two_nums_on_subscreen_with_dash(char update_now, unsigned __int8 left, unsigned __int8 right)
{
  char v3; // r4@1
  unsigned __int8 v4; // r7@1
  unsigned int v5; // r8@1

  v3 = update_now;
  v4 = left;
  v5 = right;
  subscr_set_decimal_point(0);
  conv_uint_to_bcd_tmp(v4);
  disp_bcd_tmp[3] += 48;
  scr_msg_tmp[0] = LOBYTE(disp_bcd_tmp[3]);
  disp_bcd_tmp[4] += 48;
  scr_msg_tmp[1] = LOBYTE(disp_bcd_tmp[4]);
  if ( blink_dash_for_hour_minute )
    scr_msg_tmp[2] = '-';
  else
    scr_msg_tmp[2] = 32;
  conv_uint_to_bcd_tmp(v5);
  disp_bcd_tmp[3] += 48;
  scr_msg_tmp[3] = LOBYTE(disp_bcd_tmp[3]);
  disp_bcd_tmp[4] += 48;
  scr_msg_tmp[4] = LOBYTE(disp_bcd_tmp[4]);
  put_msg_on_scr(1, scr_msg_tmp);
  if ( v3 )
    update_lcd_if_appropriate();
  else
    lcd_needs_update = 1;
}
// 20003890: using guessed type int disp_bcd_tmp[5];
// 20003AF7: using guessed type char lcd_needs_update;
// 20003B67: using guessed type char blink_dash_for_hour_minute;

//----- (08007B34) --------------------------------------------------------
void __fastcall show_hour_min_on_subscr(char update_now)
{
  if ( setup_currently_editing )
    show_two_nums_on_subscreen_with_dash(update_now, edit_hour, edit_minute);
  else
    show_two_nums_on_subscreen_with_dash(update_now, curr_hour, curr_minute);
}
// 20003B0A: using guessed type char setup_currently_editing;
// 20003B72: using guessed type char edit_hour;
// 20003B73: using guessed type char edit_minute;

//----- (08007B78) --------------------------------------------------------
void __fastcall show_meter_serial(char update_now)
{
  char v1; // r4@1

  v1 = update_now;
  subscr_set_decimal_point(0);
  conv_uint_to_bcd_tmp(edit_meter_serial);
  conv_bcd_tmp_to_scr(4u);
  put_msg_on_scr(1, scr_msg_tmp);
  if ( v1 )
    update_lcd_if_appropriate();
  else
    lcd_needs_update = 1;
}
// 20003810: using guessed type int edit_meter_serial;
// 20003AF7: using guessed type char lcd_needs_update;

//----- (08007BD8) --------------------------------------------------------
void __fastcall show_temperature(__int16 measurement)
{
  int v1; // r6@1
  char v2; // r5@4

  segment_buffer_C2L &= ~S2L_SS_NEGATIVE;
  LOWORD(v1) = convert_temp_and_round(measurement);
  if ( there_was_a_temp_error )
  {
    subscr_set_decimal_point(0);
    show_temp_error(1);
  }
  else
  {
    subscr_set_decimal_point(2u);
    if ( (signed __int16)v1 >= 0 )
    {
      v2 = 0;
    }
    else
    {
      v2 = 1;
      v1 = -(signed __int16)v1;
    }
    conv_uint_to_bcd_tmp(10 * (signed __int16)v1);
    conv_bcd_tmp_to_scr(2u);
    if ( v2 == 1 )
    {
      if ( disp_bcd_tmp[1] == 32 )
        scr_msg_tmp[1] = '-';
      else
        scr_msg_tmp[0] = '-';
    }
    if ( scr_msg_tmp[0] == 32 )
    {
      scr_msg_tmp[0] = 0;
      if ( scr_msg_tmp[1] == 32 )
        scr_msg_tmp[1] = 0;
    }
    if ( temp_in_c )
      scr_msg_tmp[4] = 'c';
    else
      scr_msg_tmp[4] = 'F';
    put_msg_on_scr(1, scr_msg_tmp);
    lcd_needs_update = 1;
  }
}
// 20003890: using guessed type int disp_bcd_tmp[5];
// 20003AF7: using guessed type char lcd_needs_update;
// 20003B43: using guessed type char temp_in_c;
// 20003B46: using guessed type char there_was_a_temp_error;

//----- (08007CA0) --------------------------------------------------------
__int16 __fastcall convert_temp_and_round(signed __int16 a1)
{
  signed __int16 v1; // r5@2
  int v2; // r5@4

  if ( temp_in_c )
    v1 = a1;
  else
    v1 = temp_conv_c_to_f(a1);
  v2 = v1 / 10;
  if ( v2 % 10 >= 5 )
    LOWORD(v2) = v2 + 1;
  return v2;
}
// 20003B43: using guessed type char temp_in_c;

//----- (08007CDC) --------------------------------------------------------
void update_bargraph_if_in_appropriate_range(void)
{
  need_to_update_bargraph = 0;
  if ( (curr_meas_mode < (signed int)MM_HZ || curr_meas_mode >= (signed int)MM_OHMS)
    && curr_meas_mode != MM_CAP
    && curr_meas_mode != MM_TEMP )
    scr_update_bargraph();
}
// 20003AFA: using guessed type char need_to_update_bargraph;

//----- (08007D40) --------------------------------------------------------
void __fastcall scr_update_bargraph()
{
  calc_bargraph_pos_for_mode();
  if ( curr_bargraph_bars )
    segment_buffer_C1L |= S1L_BG_B1;
  else
    scr_clear_bargraph_bars(25u, 1);
  if ( (signed int)curr_bargraph_bars < 2 )
    scr_clear_bargraph_bars(25u, 2);
  else
    segment_buffer_C2L |= S2L_BG_B2;
  if ( (signed int)curr_bargraph_bars < 3 )
    scr_clear_bargraph_bars(25u, 3);
  else
    segment_buffer_C3L |= S3L_BG_B3;
  if ( (signed int)curr_bargraph_bars < 4 )
    scr_clear_bargraph_bars(25u, 4);
  else
    segment_buffer_C3L |= S3L_BG_B4;
  if ( (signed int)curr_bargraph_bars < 5 )
    scr_clear_bargraph_bars(25u, 5);
  else
    segment_buffer_C2L |= S2L_BG_B5;
  if ( (signed int)curr_bargraph_bars < 6 )
    scr_clear_bargraph_bars(25u, 6);
  else
    segment_buffer_C1L |= S1L_BG_B6;
  if ( (signed int)curr_bargraph_bars < 7 )
    scr_clear_bargraph_bars(25u, 7);
  else
    segment_buffer_C0L |= S0L_BG_B7;
  if ( (signed int)curr_bargraph_bars < 8 )
    scr_clear_bargraph_bars(25u, 8);
  else
    segment_buffer_C0L |= S0L_BG_B8;
  if ( (signed int)curr_bargraph_bars < 9 )
    scr_clear_bargraph_bars(25u, 9);
  else
    segment_buffer_C1L |= S1L_BG_B9;
  if ( (signed int)curr_bargraph_bars < 10 )
    scr_clear_bargraph_bars(25u, 10);
  else
    segment_buffer_C2L |= S2L_BG_B10;
  if ( (signed int)curr_bargraph_bars < 11 )
    scr_clear_bargraph_bars(25u, 11);
  else
    segment_buffer_C3L |= S3L_BG_B11;
  if ( (signed int)curr_bargraph_bars < 12 )
    scr_clear_bargraph_bars(25u, 12);
  else
    segment_buffer_C3L |= S3L_BG_B12;
  if ( (signed int)curr_bargraph_bars < 13 )
    scr_clear_bargraph_bars(25u, 13);
  else
    segment_buffer_C2L |= S2L_BG_B13;
  if ( (signed int)curr_bargraph_bars < 14 )
    scr_clear_bargraph_bars(25u, 14);
  else
    segment_buffer_C1L |= S1L_BG_B14;
  if ( (signed int)curr_bargraph_bars < 15 )
    scr_clear_bargraph_bars(25u, 15);
  else
    segment_buffer_C0L |= S0L_BG_B15;
  if ( (signed int)curr_bargraph_bars < 16 )
    scr_clear_bargraph_bars(25u, 16);
  else
    segment_buffer_C0L |= S0L_BG_B16;
  if ( (signed int)curr_bargraph_bars < 17 )
    scr_clear_bargraph_bars(25u, 17);
  else
    segment_buffer_C1L |= S1L_BG_B17;
  if ( (signed int)curr_bargraph_bars < 18 )
    scr_clear_bargraph_bars(25u, 18);
  else
    segment_buffer_C2L |= S2L_BG_B18;
  if ( (signed int)curr_bargraph_bars < 19 )
    scr_clear_bargraph_bars(25u, 19);
  else
    segment_buffer_C3L |= S3L_BG_B19;
  if ( (signed int)curr_bargraph_bars < 20 )
    scr_clear_bargraph_bars(25u, 20);
  else
    segment_buffer_C3L |= S3L_BG_B20;
  if ( (signed int)curr_bargraph_bars < 21 )
    scr_clear_bargraph_bars(25u, 21);
  else
    segment_buffer_C2L |= S2L_BG_B21;
  if ( (signed int)curr_bargraph_bars < 22 )
    scr_clear_bargraph_bars(25u, 22);
  else
    segment_buffer_C1L |= S1L_BG_B22;
  if ( (signed int)curr_bargraph_bars < 23 )
    scr_clear_bargraph_bars(25u, 23);
  else
    segment_buffer_C0L |= S0L_BG_B23;
  if ( (signed int)curr_bargraph_bars < 24 )
    scr_clear_bargraph_bars(25u, 24);
  else
    segment_buffer_C0L |= S0L_BG_B24;
  if ( (signed int)curr_bargraph_bars < 25 )
    scr_clear_bargraph_bars(25u, 25);
  else
    segment_buffer_C1L |= S1L_BG_B25;
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (080080DC) --------------------------------------------------------
void calc_bargraph_pos_for_mode(void)
{
  int v0; // r0@4
  int v1; // r0@5
  int v2; // r0@6

  if ( curr_meas_mode )
  {
    if ( (unsigned int)(unsigned __int8)curr_meas_mode - MM_DCV <= 3 )
    {
      if ( curr_meas_range == 3 )
        calc_bargraph_pos(1);
      else
        calc_bargraph_pos(0);
    }
    else
    {
      if ( (unsigned int)(unsigned __int8)curr_meas_mode - MM_OHMS <= 2 )
        goto LABEL_20;
      v0 = (unsigned __int8)curr_meas_mode - MM_ACuVA;
      if ( (unsigned int)v0 <= 2 )
      {
LABEL_8:
        calc_bargraph_pos(0);
        return;
      }
      v1 = (unsigned __int8)curr_meas_mode - MM_ACuA;
      if ( (unsigned int)v1 <= 3 )
      {
LABEL_20:
        calc_bargraph_pos(0);
      }
      else
      {
        v2 = (unsigned __int8)curr_meas_mode - MM_ACA;
        if ( (unsigned int)v2 > 1 )
        {
          if ( (unsigned int)(unsigned __int8)curr_meas_mode - MM_DCuVA > 2 )
            return;
          goto LABEL_8;
        }
        if ( curr_meas_range == 2 )
          calc_bargraph_pos(1);
        else
          calc_bargraph_pos(0);
      }
    }
  }
  else
  {
    calc_bargraph_pos(1);
  }
}

//----- (08008160) --------------------------------------------------------
void __fastcall calc_bargraph_pos(char range)
{
  signed __int16 v1; // r5@10
  signed int v2; // r6@13

  if ( (curr_meas_mode < (signed int)MM_HZ || curr_meas_mode >= (signed int)MM_OHMS)
    && curr_meas_mode != MM_CAP
    && curr_meas_mode != MM_TEMP )
  {
    if ( curr_bargraph_digits >= 0 )
    {
      segment_buffer_C2L = 2 * ((unsigned int)segment_buffer_C2L >> 1);// S1L_BG_NEGATIVE
      segment_buffer_C1L |= S1L_BG_POSITIVE;
    }
    else
    {
      segment_buffer_C2L |= S2L_BG_NEGATIVE;
      segment_buffer_C1L = 2 * ((unsigned int)segment_buffer_C1L >> 1);// S1L_BG_POSITIVE
    }
    if ( range == 1 )
    {
      segment_buffer_C0L &= ~S0L_BG_SCALE_5;
      segment_buffer_C0L |= S0L_BG_SCALE_10;
      scr_update_bargraph_range(1);
      v1 = 400;
    }
    else
    {
      segment_buffer_C0L |= S0L_BG_SCALE_5;
      segment_buffer_C0L &= ~S0L_BG_SCALE_10;
      scr_update_bargraph_range(0);
      v1 = 2000;
    }
    segment_buffer_C0L |= S0L_BG_SCALE;
    if ( curr_bargraph_digits >= 0 )
      v2 = curr_bargraph_digits;
    else
      v2 = -curr_bargraph_digits;
    curr_bargraph_bars = v2 / (unsigned __int16)v1;
    if ( curr_scr_overflow )
      curr_bargraph_bars = 25;
    if ( curr_meas_mode == MM_DIODE && (signed int)curr_bargraph_bars >= 16 )
      curr_bargraph_bars = 15;
  }
}
// 2000385C: using guessed type int curr_bargraph_digits;

//----- (080082B4) --------------------------------------------------------
void __fastcall scr_update_bargraph_range(char a1)
{
  int v1; // r0@9

  if ( a1 == 1 )
  {
    segment_buffer_C3L |= S3L_BG_RANGE_1000;
    bargraph_range = 3;
    segment_buffer_C2L &= ~S2L_BG_RANGE_5;
    segment_buffer_C3L &= ~S3L_BG_RANGE_0_FOR_50;
    segment_buffer_C1L &= ~S1L_BG_RANGE_0_FOR_500;
    return;
  }
  segment_buffer_C3L &= ~S3L_BG_RANGE_1000;
  segment_buffer_C2L |= S2L_BG_RANGE_5;
  bargraph_range = 0;
  if ( (unsigned int)(unsigned __int8)curr_meas_mode - 1 <= 1 )
    goto LABEL_15;
  if ( (unsigned int)(unsigned __int8)curr_meas_mode - 3 <= 1 )
    goto LABEL_25;
  if ( curr_meas_mode == 9 )
  {
    if ( (signed int)curr_meas_range >= 2 )
    {
      if ( (signed int)curr_meas_range >= 5 )
        scr_update_bargraph_range_5s(curr_meas_range - 5);
      else
        scr_update_bargraph_range_5s(curr_meas_range - 2);
    }
    else
    {
      scr_update_bargraph_range_5s(curr_meas_range + 1);
    }
    return;
  }
  if ( curr_meas_mode == 10 )
  {
    scr_update_bargraph_range_5s(2u);
    return;
  }
  if ( curr_meas_mode == MM_DIODE )
  {
LABEL_15:
    scr_update_bargraph_range_5s(curr_meas_range);
    return;
  }
  if ( (unsigned int)(unsigned __int8)curr_meas_mode - 16 <= 1 )
  {
LABEL_25:
    scr_update_bargraph_range_5s(curr_meas_range + 1);
    return;
  }
  v1 = (unsigned __int8)curr_meas_mode - 18;
  if ( (unsigned int)v1 <= 1 )
    goto LABEL_15;
  if ( (unsigned int)(unsigned __int8)curr_meas_mode - 20 <= 1 )
  {
    if ( curr_meas_range )
      scr_update_bargraph_range_5s(0);
    else
      scr_update_bargraph_range_5s(2u);
  }
}
// 20003AED: using guessed type char bargraph_range;

//----- (080083F0) --------------------------------------------------------
void __fastcall scr_update_bargraph_range_5s(unsigned __int8 bargraph_range_in)
{
  *(_DWORD *)&bargraph_range_in = bargraph_range_in;
  if ( bargraph_range_in )
  {
    if ( bargraph_range_in == 2 )
    {
      segment_buffer_C3L |= S3L_BG_RANGE_0_FOR_50;
      segment_buffer_C1L |= S1L_BG_RANGE_0_FOR_500;
      bargraph_range = 2;
    }
    else if ( bargraph_range_in < 2u )
    {
      segment_buffer_C3L |= S3L_BG_RANGE_0_FOR_50;
      segment_buffer_C1L &= ~S1L_BG_RANGE_0_FOR_500;
      bargraph_range = 1;
    }
  }
  else
  {
    segment_buffer_C3L &= ~S3L_BG_RANGE_0_FOR_50;
    segment_buffer_C1L &= ~S1L_BG_RANGE_0_FOR_500;
    bargraph_range = 0;
  }
}
// 20003AED: using guessed type char bargraph_range;

//----- (08008480) --------------------------------------------------------
void scr_reset_bargraph()
{
  if ( (curr_meas_mode < (signed int)MM_HZ || curr_meas_mode >= (signed int)MM_OHMS)
    && curr_meas_mode != MM_CAP
    && curr_meas_mode != MM_TEMP )
  {
    curr_bargraph_digits = 0;
    curr_bargraph_bars = 0;
    calc_bargraph_pos_for_mode();
    scr_clear_bargraph_bars(25u, 1);
    lcd_needs_update = 1;
  }
  else
  {
    scr_turn_off_bargraph();
  }
}
// 2000385C: using guessed type int curr_bargraph_digits;
// 20003AF7: using guessed type char lcd_needs_update;

//----- (080084DC) --------------------------------------------------------
void scr_turn_off_bargraph(void)
{
  segment_buffer_C2L = 2 * ((unsigned int)segment_buffer_C2L >> 1);// S2L_BG_NEGATIVE
  segment_buffer_C1L = 2 * ((unsigned int)segment_buffer_C1L >> 1);// S1L_BG_POSITIVE
  segment_buffer_C0L &= ~S0L_BG_SCALE_5;
  segment_buffer_C0L &= ~S0L_BG_SCALE_10;
  segment_buffer_C3L &= ~S3L_BG_RANGE_1000;
  segment_buffer_C2L &= ~S2L_BG_RANGE_5;
  segment_buffer_C3L &= ~S3L_BG_RANGE_0_FOR_50;
  segment_buffer_C1L &= ~S1L_BG_RANGE_0_FOR_500;
  scr_clear_bargraph_bars(25u, 0);
}

//----- (08008588) --------------------------------------------------------
void __fastcall scr_clear_bargraph_bars(unsigned __int8 end, char start)
{
  // turn off the bargraph segments >= start and <= end
  *(_DWORD *)&end = end;
  if ( !end )
  {
LABEL_52:
    segment_buffer_C0L &= ~S0L_BG_SCALE;
    return;
  }
  if ( end == 2 )
    goto LABEL_50;
  if ( end < 2u )
    goto LABEL_51;
  if ( end == 4 )
    goto LABEL_48;
  if ( end < 4u )
    goto LABEL_49;
  if ( end == 6 )
    goto LABEL_46;
  if ( end < 6u )
    goto LABEL_47;
  if ( end == 8 )
    goto LABEL_44;
  if ( end < 8u )
    goto LABEL_45;
  if ( end == 10 )
    goto LABEL_42;
  if ( end < 0xAu )
    goto LABEL_43;
  if ( end == 12 )
    goto LABEL_40;
  if ( end < 0xCu )
    goto LABEL_41;
  if ( end == 14 )
    goto LABEL_38;
  if ( end < 0xEu )
    goto LABEL_39;
  if ( end == 16 )
    goto LABEL_36;
  if ( end < 0x10u )
    goto LABEL_37;
  if ( end == 18 )
    goto LABEL_34;
  if ( end < 0x12u )
    goto LABEL_35;
  if ( end == 20 )
    goto LABEL_32;
  if ( end < 0x14u )
    goto LABEL_33;
  if ( end == 22 )
    goto LABEL_30;
  if ( end < 0x16u )
    goto LABEL_31;
  if ( end == 24 )
    goto LABEL_55;
  if ( end < 0x18u )
    goto LABEL_29;
  if ( end == 25 )
  {
    segment_buffer_C1L &= ~S1L_BG_B25;
    if ( start != 25 )
    {
LABEL_55:
      segment_buffer_C0L &= ~S0L_BG_B24;
      if ( start == 24 )
        return;
LABEL_29:
      segment_buffer_C0L &= ~S0L_BG_B23;
      if ( start == 23 )
        return;
LABEL_30:
      segment_buffer_C1L &= ~S1L_BG_B22;
      if ( start == 22 )
        return;
LABEL_31:
      segment_buffer_C2L &= ~S2L_BG_B21;
      if ( start == 21 )
        return;
LABEL_32:
      segment_buffer_C3L &= ~S3L_BG_B20;
      if ( start == 20 )
        return;
LABEL_33:
      segment_buffer_C3L &= ~S3L_BG_B19;
      if ( start == 19 )
        return;
LABEL_34:
      segment_buffer_C2L &= ~S2L_BG_B18;
      if ( start == 18 )
        return;
LABEL_35:
      segment_buffer_C1L &= ~S1L_BG_B17;
      if ( start == 17 )
        return;
LABEL_36:
      segment_buffer_C0L &= ~S0L_BG_B16;
      if ( start == 16 )
        return;
LABEL_37:
      segment_buffer_C0L &= ~S0L_BG_B15;
      if ( start == 15 )
        return;
LABEL_38:
      segment_buffer_C1L &= ~S1L_BG_B14;
      if ( start == 14 )
        return;
LABEL_39:
      segment_buffer_C2L &= ~S2L_BG_B13;
      if ( start == 13 )
        return;
LABEL_40:
      segment_buffer_C3L &= ~S3L_BG_B12;
      if ( start == 12 )
        return;
LABEL_41:
      segment_buffer_C3L &= ~S3L_BG_B11;
      if ( start == 11 )
        return;
LABEL_42:
      segment_buffer_C2L &= ~S2L_BG_B10;
      if ( start == 10 )
        return;
LABEL_43:
      segment_buffer_C1L &= ~S1L_BG_B9;
      if ( start == 9 )
        return;
LABEL_44:
      segment_buffer_C0L &= ~S0L_BG_B8;
      if ( start == 8 )
        return;
LABEL_45:
      segment_buffer_C0L &= ~S0L_BG_B7;
      if ( start == 7 )
        return;
LABEL_46:
      segment_buffer_C1L &= ~S1L_BG_B6;
      if ( start == 6 )
        return;
LABEL_47:
      segment_buffer_C2L &= ~S2L_BG_B5;
      if ( start == 5 )
        return;
LABEL_48:
      segment_buffer_C3L &= ~S3L_BG_B4;
      if ( start == 4 )
        return;
LABEL_49:
      segment_buffer_C3L &= ~S3L_BG_B3;
      if ( start == 3 )
        return;
LABEL_50:
      segment_buffer_C2L &= ~S2L_BG_B2;
      if ( start == 2 )
        return;
LABEL_51:
      segment_buffer_C1L &= ~S1L_BG_B1;
      if ( start == 1 )
        return;
      goto LABEL_52;
    }
  }
}

//----- (0800880C) --------------------------------------------------------
void __fastcall show_cal_msg_countdown(unsigned __int8 a1)
{
  char v1; // r5@1

  v1 = cal_countdown_timer;
  segment_buffer_C1H &= 0xFFFFFF7F;
  scr_msg_tmp[0] = '-';
  if ( a1 )
  {
    if ( a1 == 2 )
    {
      scr_msg_tmp[1] = '4';
    }
    else if ( a1 >= 2u )
    {
      if ( a1 == 4 )
      {
        scr_msg_tmp[1] = '3';
      }
      else if ( a1 < 4u )
      {
        scr_msg_tmp[1] = '5';
      }
    }
    else
    {
      scr_msg_tmp[1] = 'G';
    }
  }
  else
  {
    scr_msg_tmp[1] = 'O';
  }
  scr_msg_tmp[2] = '-';
  if ( (signed int)(unsigned __int8)cal_countdown_timer < 10 )
  {
    scr_msg_tmp[3] = '0';
  }
  else
  {
    scr_msg_tmp[3] = (unsigned __int8)cal_countdown_timer / 10 + 48;
    v1 = cal_countdown_timer - 10;
  }
  scr_msg_tmp[4] = v1 + 48;
  put_msg_on_scr(0, scr_msg_tmp);
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;
// 20003B2F: using guessed type char cal_countdown_timer;

//----- (080088C0) --------------------------------------------------------
void __fastcall show_cal_msg_end(unsigned __int8 a1)
{
  segment_buffer_C1H &= 0xFFFFFF7F;
  if ( a1 )
  {
    if ( a1 == 2 )
    {
      put_msg_on_scr(0, "400-E");
    }
    else if ( a1 >= 2u )
    {
      if ( a1 == 3 )
        put_msg_on_scr(0, "5KEND");
    }
    else
    {
      put_msg_on_scr(0, "G-END");
    }
  }
  else
  {
    put_msg_on_scr(0, "OFF-E");
  }
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (08008920) --------------------------------------------------------
void __fastcall show_sdcal_msg()
{
  segment_buffer_C1H &= ~S1H_MS_NEGATIVE;
  put_msg_on_scr(0, "SdCAL");
  scr_set_decimal_point(3u);
  update_lcd_if_appropriate();
}

//----- (08008944) --------------------------------------------------------
void __fastcall show_sdsav_msg()
{
  segment_buffer_C1H &= ~S1H_MS_NEGATIVE;
  put_msg_on_scr(0, "SdSAv");
  scr_set_decimal_point(3u);
  update_lcd_if_appropriate();
}

//----- (08008968) --------------------------------------------------------
void __fastcall show_sdset_msg()
{
  segment_buffer_C1H &= ~S1H_MS_NEGATIVE;
  put_msg_on_scr(0, "SdSEt");
  scr_set_decimal_point(3u);
  update_lcd_if_appropriate();
}

//----- (0800898C) --------------------------------------------------------
void __fastcall show_sd_cal_success()
{
  segment_buffer_C1H &= ~S1H_MS_NEGATIVE;
  put_msg_on_scr(0, "SAvEd");
  scr_set_decimal_point(0);
  update_lcd_if_appropriate();
}

//----- (080089B4) --------------------------------------------------------
void __fastcall show_sd_cal_err()
{
  segment_buffer_C1H &= ~S1H_MS_NEGATIVE;
  put_msg_on_scr(0, "-Err-");
  scr_set_decimal_point(0);
  update_lcd_if_appropriate();
}

//----- (080089DC) --------------------------------------------------------
void __fastcall show_cal_mode_msg()
{
  segment_buffer_C1H &= ~S1H_MS_NEGATIVE;
  put_msg_on_scr(0, " CAL1");
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (08008A04) --------------------------------------------------------
void show_cal_mode_msg_on_subscr()
{
  segment_buffer_C2L &= ~S2L_SS_NEGATIVE;
  subscr_set_decimal_point(0);
  put_msg_on_scr(1, " CAL ");
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (08008A34) --------------------------------------------------------
void __fastcall show_low_batt()
{
  segment_buffer_C2L &= ~S2L_SS_KILO;           // might be into kilo log samples
  scr_msg_tmp[0] = 'L';
  scr_msg_tmp[1] = 'o';
  scr_msg_tmp[2] = 'B';
  scr_msg_tmp[3] = 'A';
  scr_msg_tmp[4] = 't';
  put_msg_on_scr(1, scr_msg_tmp);
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (08008A84) --------------------------------------------------------
void __fastcall show_msg_logging_ended()
{
  segment_buffer_C2L &= ~S2L_SS_KILO;           // might be into kilo log samples
  scr_msg_tmp[0] = 'S';
  scr_msg_tmp[1] = 'd';
  scr_msg_tmp[2] = 'E';
  scr_msg_tmp[3] = 'n';
  scr_msg_tmp[4] = 'd';
  put_msg_on_scr(1, scr_msg_tmp);
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (08008AD0) --------------------------------------------------------
void __fastcall show_sd_error(unsigned __int8 error)
{
  segment_buffer_C2L &= ~S2L_SS_KILO;
  scr_msg_tmp[0] = 'S';
  scr_msg_tmp[1] = 'd';
  scr_msg_tmp[2] = 'E';
  if ( (signed int)error < 10 )
  {
    scr_msg_tmp[3] = '0';
  }
  else
  {
    scr_msg_tmp[3] = error / 10 + 48;
    error -= 10;
  }
  scr_msg_tmp[4] = error + 48;
  put_msg_on_scr(1, scr_msg_tmp);
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (08008B3C) --------------------------------------------------------
void __fastcall show_overload(char on_subscr)
{
  if ( on_subscr || !meter_amp_leads_incorrect )
  {
    if ( on_subscr == 1 )
      segment_buffer_C2L &= ~S2L_SS_NEGATIVE;
    else
      segment_buffer_C1H &= ~S1H_MS_NEGATIVE;
    put_msg_on_scr(on_subscr, " OFL ");
  }
  else
  {
    show_lead_err(0);
  }
}
// 20003B12: using guessed type char meter_amp_leads_incorrect;

//----- (08008B8E) --------------------------------------------------------
void __fastcall show_temp_error(char on_subscr)
{
  if ( on_subscr || !meter_amp_leads_incorrect )
  {
    if ( on_subscr == 1 )
      segment_buffer_C2L &= ~S2L_SS_NEGATIVE;
    else
      segment_buffer_C1H &= ~S1H_MS_NEGATIVE;
    put_msg_on_scr(on_subscr, " OPEN");
  }
  else
  {
    show_lead_err(0);
  }
}
// 20003B12: using guessed type char meter_amp_leads_incorrect;

//----- (08008BE0) --------------------------------------------------------
void __fastcall show_lead_err(char on_subscr)
{
  put_msg_on_scr(on_subscr, " LEAD");
}

//----- (08008BF2) --------------------------------------------------------
void scr_erase(char subscr)
{
  meter_overflow_was_negative = 0;
  if ( subscr == 1 )
    segment_buffer_C2L &= ~S2L_SS_NEGATIVE;
  else
    segment_buffer_C1H &= ~S1H_MS_NEGATIVE;
  put_msg_on_scr(subscr, "     ");
}
// 20003AE7: using guessed type char meter_overflow_was_negative;

//----- (08008C34) --------------------------------------------------------
void __fastcall put_msg_on_scr(char on_subscr, char *msg)
{
  unsigned __int8 *v2; // r5@1
  int v3; // r6@1
  unsigned __int8 v4; // r7@2

  v2 = (unsigned __int8 *)msg;
  v3 = 0;
  if ( on_subscr )
    v4 = 0;
  else
    v4 = 5;
  while ( 1 )
  {
    set_7seg(*v2, v4);
    ++v3;
    if ( (signed int)(unsigned __int8)v3 >= 5 )
      break;
    ++v2;
    ++v4;
  }
}

//----- (08008C68) --------------------------------------------------------
void __fastcall put_chr_on_scr_at_offset(unsigned __int8 where, unsigned __int8 *chr)
{
  set_7seg(*chr, where);
}

//----- (08008C7A) --------------------------------------------------------
void __fastcall put_2_chrs_on_scr_at_offset(unsigned __int8 offset, unsigned __int8 *a2)
{
  unsigned __int8 *v2; // r5@1
  int v3; // r6@1
  unsigned __int8 i; // r7@1

  v2 = a2;
  v3 = 0;
  for ( i = offset; ; ++i )
  {
    set_7seg(*v2, i);
    ++v3;
    if ( (signed int)(unsigned __int8)v3 >= 2 )
      break;
    ++v2;
  }
}

//----- (08008CA0) --------------------------------------------------------
void __fastcall scr_turn_off_units()
{
  segment_buffer_C0L &= ~S0L_ICON_TEST;
  segment_buffer_C0L &= ~S0L_ICON_LOWZ;
  segment_buffer_C2L &= ~S2L_MS_HERTZ;
  segment_buffer_C2L = 2 * segment_buffer_C2L >> 1;// S2L_ICON_CONTINUITY
  segment_buffer_C3L = 2 * segment_buffer_C3L >> 1;// S3L_ICON_DIODE
  segment_buffer_C0L &= ~S0L_MS_KILO;
  segment_buffer_C1L &= ~S1L_MS_OHMS;
  segment_buffer_C0L &= ~S0L_MS_MEGA;
  segment_buffer_C3L &= ~S3L_MS_AMPS;
  segment_buffer_C1L &= ~S1L_MS_MILLI;
  segment_buffer_C2L &= ~S2L_MS_VOLTS;
  segment_buffer_C1L &= ~S1L_MS_NANO;
  segment_buffer_C0L &= ~S0L_MS_MICRO;
  segment_buffer_C2L &= ~S2L_MS_FARADS;
  if ( !input_1ms_peak_enabled )
    segment_buffer_C3L = 2 * ((unsigned int)segment_buffer_C3L >> 1);// S3L_MS_mSEC
  segment_buffer_C0L &= ~S0L_MS_DUTY_PERCENT;
}
// 20003B4F: using guessed type char input_1ms_peak_enabled;

//----- (08008DB0) --------------------------------------------------------
void __fastcall scr_update_apo_status(char update_now)
{
  if ( curr_apo_off | logging_active )
    segment_buffer_C2H &= ~S2H_ICON_APO;
  else
    segment_buffer_C2H |= S2H_ICON_APO;
  if ( update_now == 1 )
    update_lcd_if_appropriate();
}
// 20003A9C: using guessed type char came_from_standby;
// 20003ADC: using guessed type char apo_woke_up;

//----- (08008DFC) --------------------------------------------------------
void __fastcall scr_update_low_batt_icon(char update_now)
{
  if ( batt_is_low_icon )
    segment_buffer_C3H |= S3H_ICON_BATT;
  else
    segment_buffer_C3H &= ~S3H_ICON_BATT;
  if ( update_now == 1 )
    update_lcd_if_appropriate();
}
// 20003ADF: using guessed type char batt_is_low_icon;

//----- (08008E38) --------------------------------------------------------
void __fastcall scr_update_bt_icon(char update_now)
{
  if ( bt_enabled )
    segment_buffer_C0L |= S0L_ICON_BT;
  else
    segment_buffer_C0L = 2 * segment_buffer_C0L >> 1;// S0L_ICON_BT
  if ( update_now == 1 )
    update_lcd_if_appropriate();
}
// 20003AD3: using guessed type char bt_enabled;

//----- (08008E78) --------------------------------------------------------
void __fastcall scr_update_autorange_icon(char update_now)
{
  int v2; // r0@1

  LOBYTE(v2) = determine_if_autoranging();
  if ( v2 )
    segment_buffer_C3H |= S3H_ICON_AUTO_RANGE;
  else
    segment_buffer_C3H = 2 * ((unsigned int)segment_buffer_C3H >> 1);// S3H_ICON_AUTO_RANGE
  if ( update_now == 1 )
    update_lcd_if_appropriate();
}

//----- (08008EB2) --------------------------------------------------------
char determine_if_autoranging(void)
{
  char autoranging; // r0@2

  if ( meter_in_cal_mode )
  {
    autoranging = 0;
  }
  else if ( logging_active & (unsigned __int8)(auto_hold_is_enabled ^ 1) )
  {
    autoranging = 0;
  }
  else if ( curr_meas_mode != MM_DIODE
         && curr_meas_mode != MM_CONTINUITY
         && curr_meas_mode != MM_TEMP
         && curr_meas_mode
         && curr_meas_mode != MM_DUTY )
  {
    autoranging = autoranging_disabled == 0;
  }
  else
  {
    autoranging = 0;
  }
  return autoranging;
}
// 20003AE6: using guessed type char autoranging_disabled;
// 20003B24: using guessed type char meter_in_cal_mode;

//----- (08008F34) --------------------------------------------------------
void __fastcall scr_update_min_max_icons(char update_now)
{
  segment_buffer_C3L &= ~S3L_ICON_MIN;
  segment_buffer_C2L &= ~S2L_ICON_MAX;
  segment_buffer_C1L &= ~S1L_ICON_AVG;
  if ( !(logging_active | log_playback_mode) )
  {
    if ( input_1ms_peak_enabled )
    {
      if ( peakdet_show_min_always_zero )
        segment_buffer_C3L |= S3L_ICON_MIN;
      else
        segment_buffer_C2L |= S2L_ICON_MAX;
    }
    else if ( meter_min_max_mode == 1 )
    {
      segment_buffer_C2L |= S2L_ICON_MAX;
    }
    else if ( meter_min_max_mode >= 1u )
    {
      if ( meter_min_max_mode == 3 )
      {
        segment_buffer_C1L |= S1L_ICON_AVG;
      }
      else if ( meter_min_max_mode >= 3u )
      {
        if ( meter_min_max_mode == 4 )
        {
          segment_buffer_C3L |= S3L_ICON_MIN;
          segment_buffer_C2L |= S2L_ICON_MAX;
          segment_buffer_C1L |= S1L_ICON_AVG;
        }
      }
      else
      {
        segment_buffer_C3L |= S3L_ICON_MIN;
      }
    }
  }
  if ( update_now == 1 )
    update_lcd_if_appropriate();
}
// 20003A9C: using guessed type char came_from_standby;
// 20003A9F: using guessed type char maybe_logging_was_active_at_some_point;
// 20003B4F: using guessed type char input_1ms_peak_enabled;
// 20003B50: using guessed type char peakdet_show_min_always_zero;

//----- (0800903E) --------------------------------------------------------
void __fastcall scr_update_rel_meas_icon(char update_now)
{
  if ( logging_active )
  {
    segment_buffer_C0L = 2 * ((unsigned int)segment_buffer_C0L >> 1);// S0L_ICON_REL
  }
  else if ( log_playback_mode )
  {
    segment_buffer_C0L = 2 * ((unsigned int)segment_buffer_C0L >> 1);// S0L_ICON_REL
  }
  else if ( rel_meas_enabled )
  {
    segment_buffer_C0L |= S0L_ICON_REL;
  }
  else
  {
    segment_buffer_C0L = 2 * ((unsigned int)segment_buffer_C0L >> 1);// S0L_ICON_REL
  }
  if ( update_now == 1 )
    update_lcd_if_appropriate();
}
// 20003AF5: using guessed type char rel_meas_enabled;

//----- (080090B2) --------------------------------------------------------
void __fastcall scr_update_hold_icons(char update_now)
{
  char hold_status; // r5@1

  hold_status = hold_get_status();
  if ( hold_status == 1 )
  {
    segment_buffer_C1L |= S1L_ICON_AUTO_OF_HOLD;
    segment_buffer_C2L |= S2L_ICON_HOLD;
  }
  else if ( hold_status == 2 )
  {
    segment_buffer_C1L &= ~S1L_ICON_AUTO_OF_HOLD;
    segment_buffer_C2L |= S2L_ICON_HOLD;
  }
  else
  {
    segment_buffer_C1L &= ~S1L_ICON_AUTO_OF_HOLD;
    segment_buffer_C2L &= ~S2L_ICON_HOLD;
  }
  if ( update_now == 1 )
    update_lcd_if_appropriate();
}

//----- (08009138) --------------------------------------------------------
char hold_get_status()
{
  char result; // r0@2

  if ( logging_active & (unsigned __int8)(auto_hold_is_enabled ^ 1) )
  {
    result = 0;
  }
  else if ( log_playback_mode )
  {
    result = 0;
  }
  else if ( manual_hold_is_enabled )
  {
    result = 2;
  }
  else
  {
    result = auto_hold_is_enabled != 0;
  }
  return result;
}

//----- (0800918C) --------------------------------------------------------
void __fastcall scr_update_1ms_peak_icon(char update_now)
{
  if ( log_playback_mode )
  {
    if ( log_rdsamp_input_1ms_peak_enabled )
    {
      segment_buffer_C3L |= S3L_ICON_ONE_OF_1ms_PEAK;
      segment_buffer_C3L |= S3L_MS_mSEC;
    }
    else
    {
      segment_buffer_C3L &= ~S3L_ICON_ONE_OF_1ms_PEAK;
      segment_buffer_C3L = 2 * ((unsigned int)segment_buffer_C3L >> 1);// S3L_MS_mSEC
    }
  }
  else if ( input_1ms_peak_enabled )
  {
    segment_buffer_C3L |= S3L_ICON_ONE_OF_1ms_PEAK;
    segment_buffer_C3L |= S3L_MS_mSEC;
  }
  else
  {
    segment_buffer_C3L &= ~S3L_ICON_ONE_OF_1ms_PEAK;
    segment_buffer_C3L = 2 * ((unsigned int)segment_buffer_C3L >> 1);// S3L_MS_mSEC
  }
  if ( update_now == 1 )
    update_lcd_if_appropriate();
}
// 20003AA4: using guessed type char log_rdsamp_input_1ms_peak_enabled;
// 20003B4F: using guessed type char input_1ms_peak_enabled;

//----- (0800923E) --------------------------------------------------------
void __fastcall scr_update_lpf_icon()
{
  if ( log_playback_mode )
  {
    if ( log_rdsamp_input_lpf_enabled )
      segment_buffer_C1L |= S1L_ICON_LPF;
    else
      segment_buffer_C1L = 2 * segment_buffer_C1L >> 1;// S1L_ICON_LPF
  }
  else if ( input_lpf_enabled )
  {
    segment_buffer_C1L |= S1L_ICON_LPF;
  }
  else
  {
    segment_buffer_C1L = 2 * segment_buffer_C1L >> 1;// S1L_ICON_LPF
  }
}
// 20003AA3: using guessed type char log_rdsamp_input_lpf_enabled;
// 20003B51: using guessed type char input_lpf_enabled;

//----- (0800929C) --------------------------------------------------------
void scr_update_main_acdc_icons()
{
  if ( log_playback_mode )
  {
    if ( log_rdsamp_in_ac_dc_mode )
    {
      segment_buffer_C2H |= S2H_MS_DC;
      segment_buffer_C1H |= S1H_MS_PLUS_OF_AC_DC;
      segment_buffer_C0H |= S0H_MS_AC;
    }
    else
    {
      segment_buffer_C2H = 2 * ((unsigned int)segment_buffer_C2H >> 1);// S2H_MS_DC
      segment_buffer_C1H = 2 * ((unsigned int)segment_buffer_C1H >> 1);// S2H_MS_PLUS_OF_AC_DC
      segment_buffer_C0H = 2 * ((unsigned int)segment_buffer_C0H >> 1);// S0H_MS_AC
      if ( logged_meas_mode == MM_ACuA
        || logged_meas_mode == MM_ACmA
        || logged_meas_mode == MM_ACA
        || logged_meas_mode == MM_ACV
        || logged_meas_mode == MM_ACmV )
        segment_buffer_C0H |= S0H_MS_AC;
      if ( logged_meas_mode == MM_DCuA
        || logged_meas_mode == MM_DCmA
        || logged_meas_mode == MM_DCA
        || logged_meas_mode == MM_DCV
        || logged_meas_mode == MM_DCmV )
        segment_buffer_C2H |= S2H_MS_DC;
    }
  }
  else if ( meter_mode_acv_dcv )
  {
    segment_buffer_C2H |= S2H_MS_DC;
    segment_buffer_C1H |= S1H_MS_PLUS_OF_AC_DC;
    segment_buffer_C0H |= S0H_MS_AC;
  }
  else
  {
    segment_buffer_C2H = 2 * ((unsigned int)segment_buffer_C2H >> 1);// S2H_MS_DC
    segment_buffer_C1H = 2 * ((unsigned int)segment_buffer_C1H >> 1);// S1H_MS_PLUS_OF_AC_DC
    segment_buffer_C0H = 2 * ((unsigned int)segment_buffer_C0H >> 1);// S0H_MS_AC
    if ( curr_meas_mode == MM_ACuA
      || curr_meas_mode == MM_ACmA
      || curr_meas_mode == MM_ACA
      || curr_meas_mode == MM_ACV
      || curr_meas_mode == MM_ACmV )
      segment_buffer_C0H |= S0H_MS_AC;
    if ( curr_meas_mode == MM_DCuA
      || curr_meas_mode == MM_DCmA
      || curr_meas_mode == MM_DCA
      || curr_meas_mode == MM_DCV
      || curr_meas_mode == MM_DCmV )
      segment_buffer_C2H |= S2H_MS_DC;
  }
}
// 20003AA5: using guessed type char log_rdsamp_in_ac_dc_mode;
// 20003B52: using guessed type char meter_mode_acv_dcv;

//----- (0800945C) --------------------------------------------------------
void __fastcall scr_update_mem_icon(char update_now)
{
  if ( (unsigned __int8)(logging_active & maybe_logging_was_active_at_some_point) | log_playback_mode )
    segment_buffer_C0L |= S0L_ICON_MEM;
  else
    segment_buffer_C0L &= ~S0L_ICON_MEM;
  if ( update_now == 1 )
    update_lcd_if_appropriate();
}
// 20003A9C: using guessed type char came_from_standby;
// 20003A9F: using guessed type char maybe_logging_was_active_at_some_point;

//----- (080094A2) --------------------------------------------------------
void scr_update_danger_icon()
{
  if ( meter_danger_icon )
    segment_buffer_C0H |= S0H_ICON_DANGER;
  else
    segment_buffer_C0H &= ~S0H_ICON_DANGER;
}
// 20003B49: using guessed type char meter_danger_icon;

//----- (080094C8) --------------------------------------------------------
void scr_update_temp_unit()
{
  if ( curr_meas_mode == MM_TEMP )
  {
    if ( temp_in_c )
    {
      segment_buffer_C2L |= S2L_MS_DEG_C;
      segment_buffer_C3L &= ~S3L_MS_DEG_F;
    }
    else
    {
      segment_buffer_C2L &= ~S2L_MS_DEG_C;
      segment_buffer_C3L |= S3L_MS_DEG_F;
    }
  }
  else
  {
    segment_buffer_C2L &= ~S2L_MS_DEG_C;
    segment_buffer_C3L &= ~S3L_MS_DEG_F;
  }
}
// 20003B43: using guessed type char temp_in_c;

//----- (08009554) --------------------------------------------------------
void __fastcall subscr_update_units()
{
  if ( !meter_in_cal_mode )
  {
    subscr_turn_off_units();
    if ( curr_sub_mode != SM_LOG_POS )
    {
      if ( (curr_meas_mode == MM_ACuA
         || curr_meas_mode == MM_ACmA
         || curr_meas_mode == MM_ACA
         || curr_meas_mode == MM_DCuA
         || curr_meas_mode == MM_DCmA
         || curr_meas_mode == MM_DCA)
        && curr_sub_mode == SM_SPL2
        && burden_enabled_for_current_ranges )
      {
        segment_buffer_C0L |= S0L_SS_MILLI;
        segment_buffer_C1L |= S1L_SS_VOLTS;
      }
      else
      {
        switch ( curr_sub_mode )
        {
          case SM_SPL3:
            if ( (curr_meas_mode == MM_ACuA || curr_meas_mode == MM_ACmA || curr_meas_mode == MM_ACA)
              && burden_enabled_for_current_ranges )
            {
              if ( (signed int)ac_input_freq_range >= 2 )
                segment_buffer_C2L |= S2L_SS_KILO;
              segment_buffer_C3L |= S3L_SS_HERTZ;
            }
            break;
          case SM_SPL2:
            if ( curr_meas_mode == MM_ACV )
            {
              segment_buffer_C0L |= S0L_SS_dB;
              segment_buffer_C0L |= S0L_SS_MILLI;
            }
            else if ( (curr_meas_mode == MM_ACuA || curr_meas_mode == MM_ACmA || curr_meas_mode == MM_ACA)
                   && !burden_enabled_for_current_ranges )
            {
              if ( (signed int)ac_input_freq_range >= 2 )
                segment_buffer_C2L |= S2L_SS_KILO;
              segment_buffer_C3L |= S3L_SS_HERTZ;
            }
            break;
          case SM_SPL1:
            if ( curr_meas_mode == MM_DIODE )
            {
              segment_buffer_C1L |= S1L_SS_VOLTS;
              scr_update_temp_unit();
            }
            else if ( curr_meas_mode != MM_ACuVA
                   && curr_meas_mode != MM_ACmVA
                   && curr_meas_mode != MM_ACVA
                   && curr_meas_mode != MM_DCuVA
                   && curr_meas_mode != MM_DCmVA
                   && curr_meas_mode != MM_DCVA )
            {
              if ( curr_meas_mode == MM_CONTINUITY )
              {
                segment_buffer_C3L |= S3L_SS_OHMS;
              }
              else if ( curr_meas_mode != MM_ACmV && (curr_meas_mode != MM_ACV || meter_mode_acv_dcv) )
              {
                scr_update_temp_unit();
              }
              else
              {
                if ( (signed int)ac_input_freq_range >= 2 )
                  segment_buffer_C2L |= S2L_SS_KILO;
                segment_buffer_C3L |= S3L_SS_HERTZ;
              }
            }
            else if ( subscr_showing_power_amps )
            {
              subscr_set_power_amp_units();
            }
            else
            {
              segment_buffer_C1L |= S1L_SS_VOLTS;
            }
            break;
          case SM_BATTERY:
            segment_buffer_C1L |= S1L_SS_VOLTS;
            break;
          default:
            if ( curr_sub_mode != SM_APO )
              scr_update_temp_unit();
            break;
        }
      }
      lcd_needs_update = 1;
    }
  }
}
// 20003AF7: using guessed type char lcd_needs_update;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B3D: using guessed type char burden_enabled_for_current_ranges;
// 20003B52: using guessed type char meter_mode_acv_dcv;
// 20003B57: using guessed type char subscr_showing_power_amps;

//----- (080097E8) --------------------------------------------------------
void subscr_set_power_amp_units(void)
{
  if ( curr_meas_mode != MM_ACmVA
    && curr_meas_mode != MM_ACuVA
    && curr_meas_mode != MM_DCmVA
    && curr_meas_mode != MM_DCuVA )
  {
    if ( (curr_meas_mode == MM_ACVA || curr_meas_mode == MM_DCVA) && !curr_power_amps_range )
      segment_buffer_C0L |= S0L_SS_MILLI;
  }
  else
  {
    segment_buffer_C0L |= S0L_SS_MILLI;
  }
  segment_buffer_C1L |= S1L_SS_AMPS;
}
// 20003B5C: using guessed type char curr_power_amps_range;

//----- (08009864) --------------------------------------------------------
void subscr_turn_off_units()
{
  segment_buffer_C2L &= ~S2L_SS_nS;
  segment_buffer_C2L &= ~S2L_SS_NEGATIVE;
  segment_buffer_C1L &= ~S1L_SS_DC;
  segment_buffer_C3L &= ~S3L_SS_AC;
  segment_buffer_C3L &= ~S3L_SS_OHMS;
  segment_buffer_C0L &= ~S0L_SS_dB;
  segment_buffer_C0L &= ~S0L_SS_MILLI;
  segment_buffer_C1L &= ~S1L_SS_AMPS;
  segment_buffer_C1L &= ~S1L_SS_VOLTS;
  segment_buffer_C2L &= ~S2L_SS_KILO;
  segment_buffer_C3L &= ~S3L_SS_HERTZ;
}

//----- (08009920) --------------------------------------------------------
void lcd_turn_off_all_segments()
{
  unsigned __int8 i; // r4@2

  while ( read_lcd_sr(4) )                      // wait for any display update to be finished
    ;
  for ( i = 0; i < 0x10u; ++i )
    *((_DWORD *)&segment_buffer_C0L + i) = 0;
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (0800995C) --------------------------------------------------------
void __cdecl show_firmware_version()
{
  lcd_turn_off_all_segments();
  conv_uint_to_bcd_tmp(102u);
  conv_bcd_tmp_to_scr(0);
  scr_msg_tmp[0] = 'V';
  scr_msg_tmp[1] = '-';
  put_msg_on_scr(0, scr_msg_tmp);
  scr_set_decimal_point(2u);
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (080099A4) --------------------------------------------------------
void __cdecl lcd_turn_on_all_segments()
{
  segment_buffer_C0L = 0xFFFFFFFF;
  segment_buffer_C0H |= 0xFFFu;
  segment_buffer_C1L = 0xFFFFFFFF;
  segment_buffer_C1H |= 0xFFFu;
  segment_buffer_C2L = 0xFFFFFFFF;
  segment_buffer_C2H |= 0xFFFu;
  segment_buffer_C3L = 0xFFFFFFFF;
  segment_buffer_C3H |= 0xFFFu;
  lcd_needs_update = 1;
}
// 20003AF7: using guessed type char lcd_needs_update;

//----- (08009A58) --------------------------------------------------------
void __fastcall set_7seg(unsigned __int8 chr, unsigned __int8 where)
{
  unsigned int segs; // r0@1

  LOBYTE(segs) = ascii_to_segs(chr);
  // segment byte is structured
  // DxECFGAB
  // where x is unused

  // screen digits
  // subscreen: 0-4, left to right
  // main screen: 5-9, left to right
  if ( where )
  {
    if ( where == 2 )
    {
      segment_buffer_C0L &= ~S0L_SS_100_D;
      segment_buffer_C1L &= ~(S1L_SS_100_E|S1L_SS_100_C);
      segment_buffer_C2L &= ~(S2L_SS_100_F|S2L_SS_100_G);
      segment_buffer_C3L &= ~(S3L_SS_100_A|S3L_SS_100_B);
      segment_buffer_C0L |= (unsigned __int8)(segs & 0xC0) << 17;
      segment_buffer_C1L |= (segs & 0x30) << 19;
      segment_buffer_C2L |= (segs & 0xC) << 21;
      segment_buffer_C3L |= (segs & 3) << 23;
    }
    else if ( where >= 2u )
    {
      if ( where == 4 )
      {
        segment_buffer_C0L &= ~S0L_SS_1_D;
        segment_buffer_C1L &= ~(S1L_SS_1_E|S1L_SS_1_C);
        segment_buffer_C2L &= ~(S2L_SS_1_F|S2L_SS_1_G);
        segment_buffer_C3L &= ~(S3L_SS_1_A|S3L_SS_1_B);
        segment_buffer_C0L |= (unsigned __int8)(segs & 0xC0) << 13;
        segment_buffer_C1L |= (segs & 0x30) << 15;
        segment_buffer_C2L |= (segs & 0xC) << 17;
        segment_buffer_C3L |= (segs & 3) << 19;
      }
      else if ( where >= 4u )
      {
        if ( where == 6 )
        {
          segment_buffer_C0H &= ~0xFFFFF010;    // D
          segment_buffer_C1H &= ~0xFFFFF018;    // EC
          segment_buffer_C2H &= ~0xFFFFF018;    // FG
          segment_buffer_C3H &= ~0xFFFFF018;    // AB
          segment_buffer_C0H |= (segs >> 3) & 0x18;
          segment_buffer_C1H |= (segs >> 1) & 0x18;
          segment_buffer_C2H |= 2 * (segs & 0xC);
          segment_buffer_C3H |= 8 * (segs & 3);
        }
        else if ( where >= 6u )
        {
          if ( where == 8 )
          {
            segment_buffer_C0L &= ~S0L_MS_10_D;
            segment_buffer_C1L &= ~(S1L_MS_10_E|S1L_MS_10_C);
            segment_buffer_C2L &= ~(S2L_MS_10_F|S2L_MS_10_G);
            segment_buffer_C3L &= ~(S3L_MS_10_A|S3L_MS_10_B);
            segment_buffer_C0L |= (unsigned __int8)(segs & 0xC0) << 8;
            segment_buffer_C1L |= (segs & 0x30) << 10;
            segment_buffer_C2L |= (segs & 0xC) << 12;
            segment_buffer_C3L |= (segs & 3) << 14;
          }
          else if ( where >= 8u )
          {
            if ( where == 9 )
            {
              segment_buffer_C0L &= ~S0L_MS_1_D;
              segment_buffer_C1L &= ~(S1L_MS_1_E|S1L_MS_1_C);
              segment_buffer_C2L &= ~(S2L_MS_1_F|S2L_MS_1_G);
              segment_buffer_C3L &= ~(S3L_MS_1_A|S3L_MS_1_B);
              segment_buffer_C0L |= (unsigned __int8)(segs & 0xC0) << 6;
              segment_buffer_C1L |= (segs & 0x30) << 8;
              segment_buffer_C2L |= (segs & 0xC) << 10;
              segment_buffer_C3L |= (segs & 3) << 12;
            }
          }
          else
          {
            segment_buffer_C0H &= ~0xFFFFF004;  // D
            segment_buffer_C1H &= ~0xFFFFF006;  // EC
            segment_buffer_C2H &= ~0xFFFFF006;  // FG
            segment_buffer_C3H &= ~0xFFFFF006;  // AB
            segment_buffer_C0H |= (segs >> 5) & 6;
            segment_buffer_C1H |= (segs >> 3) & 6;
            segment_buffer_C2H |= (segs >> 1) & 6;
            segment_buffer_C3H |= 2 * (segs & 3);
          }
        }
        else
        {
          segment_buffer_C0H &= ~0xFFFFF040;    // D
          segment_buffer_C1H &= ~0xFFFFF060;    // EC
          segment_buffer_C2H &= ~0xFFFFF060;    // FG
          segment_buffer_C3H &= ~0xFFFFF060;    // AB
          segment_buffer_C0H |= (segs >> 1) & 0x60;
          segment_buffer_C1H |= 2 * (segs & 0x30);
          segment_buffer_C2H |= 8 * (segs & 0xC);
          segment_buffer_C3H |= 32 * (segs & 3);
        }
      }
      else
      {
        segment_buffer_C0L &= ~S0L_SS_10_D;
        segment_buffer_C1L &= ~(S1L_SS_10_E|S1L_SS_10_C);
        segment_buffer_C2L &= ~(S2L_SS_10_F|S2L_SS_10_G);
        segment_buffer_C3L &= ~(S3L_SS_10_A|S3L_SS_10_B);
        segment_buffer_C0L |= (unsigned __int8)(segs & 0xC0) << 15;
        segment_buffer_C1L |= (segs & 0x30) << 17;
        segment_buffer_C2L |= (segs & 0xC) << 19;
        segment_buffer_C3L |= (segs & 3) << 21;
      }
    }
    else
    {
      segment_buffer_C1L &= ~S1L_SS_1000_C;
      segment_buffer_C2L &= ~S2L_SS_1000_G;
      segment_buffer_C3L &= ~S3L_SS_1000_B;
      segment_buffer_C0L |= (segs & 0x40) << 19;
      segment_buffer_C1L |= (segs & 0x10) << 21;
      segment_buffer_C2L |= (segs & 4) << 23;
      segment_buffer_C3L |= (segs & 1) << 25;
      segment_buffer_C0H &= ~0xFFFFF100;        // D
      segment_buffer_C1H &= ~0xFFFFF100;        // E
      segment_buffer_C2H &= ~0xFFFFF100;        // F
      segment_buffer_C3H &= ~0xFFFFF100;        // A
      segment_buffer_C0H |= 2 * (unsigned __int8)(segs & 0x80);
      segment_buffer_C1H |= 8 * (segs & 0x20);
      segment_buffer_C2H |= 32 * (segs & 8);
      segment_buffer_C3H |= (segs & 2) << 7;
    }
  }
  else
  {
    segment_buffer_C0L &= ~S0L_SS_10000_D;
    segment_buffer_C1L &= ~(S1L_SS_10000_E|S1L_SS_10000_C);
    segment_buffer_C2L &= ~(S2L_SS_10000_F|S2L_SS_10000_G);
    segment_buffer_C3L &= ~(S3L_SS_10000_A|S3L_SS_10000_B);
    segment_buffer_C0L |= (unsigned __int8)(segs & 0xC0) << 21;
    segment_buffer_C1L |= (segs & 0x30) << 23;
    segment_buffer_C2L |= (segs & 0xC) << 25;
    segment_buffer_C3L |= (segs & 3) << 27;
  }
}

//----- (0800A104) --------------------------------------------------------
unsigned __int8 __fastcall ascii_to_segs(unsigned __int8 chr)
{
  unsigned __int8 result; // r0@1

  result = 0;
  if ( (signed int)chr < '0' || (signed int)chr >= ':' )
  {
    if ( (signed int)chr >= '[' || (signed int)chr < 'A' )
    {
      if ( (signed int)chr >= '{' || (signed int)chr < 'a' )
      {
        switch ( chr )
        {
          case ' ':
            result = 0;
            break;
          case '-':
            result = 4;
            break;
          case '=':
            result = 130;
            break;
          case '\xFF':
            result = 191;
            break;
        }
      }
      else
      {
        result = ascii_to_segs_tbl_lowercase[chr - 97];
      }
    }
    else
    {
      result = ascii_to_segs_tbl_uppercase[chr - 65];
    }
  }
  else
  {
    result = ascii_to_segs_tbl_digits[chr - 48];
  }
  return result;
}

//----- (0800A198) --------------------------------------------------------
void __fastcall conv_uint_to_bcd_tmp(unsigned int num)
{
  disp_bcd_tmp[0] = num / 10000;
  disp_bcd_tmp[1] = (signed int)(num % 10000) / 1000;
  disp_bcd_tmp[2] = (signed int)(num % 1000) / 100;
  disp_bcd_tmp[3] = (signed int)(num % 100) / 10;
  disp_bcd_tmp[4] = num % 10;
}
// 20003890: using guessed type int disp_bcd_tmp[5];

//----- (0800A238) --------------------------------------------------------
void __fastcall conv_bcd_tmp_to_scr(unsigned __int8 decimal_place)
{
  if ( disp_bcd_tmp[0] > 255 )
    disp_bcd_tmp[0] = 0;
  if ( disp_bcd_tmp[1] > 255 )
    disp_bcd_tmp[1] = 0;
  if ( disp_bcd_tmp[2] > 255 )
    disp_bcd_tmp[2] = 0;
  if ( disp_bcd_tmp[3] > 255 )
    disp_bcd_tmp[3] = 0;
  if ( disp_bcd_tmp[4] > 255 )
    disp_bcd_tmp[4] = 0;
  *(_DWORD *)&decimal_place = decimal_place;
  if ( decimal_place )
  {
    if ( decimal_place == 2 )
    {
      if ( !disp_bcd_tmp[0] )
      {
        disp_bcd_tmp[0] = 32;
        if ( !disp_bcd_tmp[1] )
          disp_bcd_tmp[1] = 32;
      }
    }
    else if ( decimal_place < 2u )
    {
      if ( !disp_bcd_tmp[0] )
      {
        disp_bcd_tmp[0] = 32;
        if ( !disp_bcd_tmp[1] )
        {
          disp_bcd_tmp[1] = 32;
          if ( !disp_bcd_tmp[2] )
            disp_bcd_tmp[2] = 32;
        }
      }
    }
    else if ( decimal_place == 3 && !disp_bcd_tmp[0] )
    {
      disp_bcd_tmp[0] = 32;
    }
  }
  else if ( !disp_bcd_tmp[0] )
  {
    disp_bcd_tmp[0] = 32;
    if ( !disp_bcd_tmp[1] )
    {
      disp_bcd_tmp[1] = 32;
      if ( !disp_bcd_tmp[2] )
      {
        disp_bcd_tmp[2] = 32;
        if ( !disp_bcd_tmp[3] )
          disp_bcd_tmp[3] = 32;
      }
    }
  }
  if ( disp_bcd_tmp[0] < 10 )
    disp_bcd_tmp[0] += 48;
  if ( disp_bcd_tmp[1] < 10 )
    disp_bcd_tmp[1] += 48;
  if ( disp_bcd_tmp[2] < 10 )
    disp_bcd_tmp[2] += 48;
  if ( disp_bcd_tmp[3] < 10 )
    disp_bcd_tmp[3] += 48;
  if ( disp_bcd_tmp[4] < 10 )
    disp_bcd_tmp[4] += 48;
  scr_msg_tmp[0] = LOBYTE(disp_bcd_tmp[0]);
  scr_msg_tmp[1] = LOBYTE(disp_bcd_tmp[1]);
  scr_msg_tmp[2] = LOBYTE(disp_bcd_tmp[2]);
  scr_msg_tmp[3] = LOBYTE(disp_bcd_tmp[3]);
  scr_msg_tmp[4] = LOBYTE(disp_bcd_tmp[4]);
}
// 20003890: using guessed type int disp_bcd_tmp[5];

//----- (0800A40C) --------------------------------------------------------
void update_lcd_if_appropriate()
{
  if ( !((unsigned __int8)(auto_hold_is_enabled & (logging_active ^ 1)) & (lcd_update_from_auto_hold ^ 1)) )
  {
    lcd_update_from_auto_hold = 0;
    while ( read_lcd_sr(4) )                    // wait for display update to be done
      ;
    LCD_RAM0L = segment_buffer_C0L;
    LCD_RAM0H = segment_buffer_C0H;
    LCD_RAM1L = segment_buffer_C1L;
    LCD_RAM1H = segment_buffer_C1H;
    LCD_RAM2L = segment_buffer_C2L;
    LCD_RAM2H = segment_buffer_C2H;
    LCD_RAM3L = segment_buffer_C3L;
    LCD_RAM3H = segment_buffer_C3H;
    set_lcd_update_request();
  }
}
// 40002414: using guessed type int LCD_RAM0L;
// 40002418: using guessed type int LCD_RAM0H;
// 4000241C: using guessed type int LCD_RAM1L;
// 40002420: using guessed type int LCD_RAM1H;
// 40002424: using guessed type int LCD_RAM2L;
// 40002428: using guessed type int LCD_RAM2H;
// 4000242C: using guessed type int LCD_RAM3L;
// 40002430: using guessed type int LCD_RAM3H;

//----- (0800A4A8) --------------------------------------------------------
void __fastcall lcd_init(unsigned __int8 contrast, char blank)
{
  int v4; // [sp+0h] [bp-20h]@1
  int v5; // [sp+4h] [bp-1Ch]@1
  int v6; // [sp+8h] [bp-18h]@1
  int v7; // [sp+Ch] [bp-14h]@1
  int v8; // [sp+10h] [bp-10h]@1

  gpio_config_lcd_pins();
  set_APB1_periph_clock(512, 1);
  v4 = 0xC00000;                                // set prescaler to LCDCLK/4
  v5 = 0;                                       // set DIV to /16
  v6 = 12;                                      // set 1/4 duty cycle
  v7 = 64;                                      // set bias to 1/3
  v8 = 0;                                       // select internal voltage generator
  lcd_set_fcr_and_cr((int)&v4);
  lcd_set_segment_multiplexing(0);
  lcd_set_contrast(contrast);
  lcd_set_dead_time(0);
  lcd_set_pulse_on_duration(64);
  lcd_wait_for_FCR_sync();
  lcd_set_enable(1u);
  while ( !read_lcd_sr(1) )                     // wait for LCD to be enabled
    ;
  while ( !read_lcd_sr(16) )                    // wait for LCD voltage to be stable
    ;
  lcd_set_blink(0, 0x4000);
  if ( blank )
    lcd_turn_off_all_segments();
  update_lcd_if_appropriate();
}

//----- (0800A52E) --------------------------------------------------------
void __fastcall gpio_config_lcd_pins()
{
  GPIO_CONFIG cfg; // [sp+0h] [bp-10h]@1

  power_all_gpio_banks();
  gpio_clear_config(&cfg);
  cfg.pins = 34766;
  cfg.mode = 2;
  gpio_config_pin(&GPIOA, &cfg);
  set_gpio_pin_func(&GPIOA, 1u, 0xBu);
  set_gpio_pin_func(&GPIOA, 2u, 0xBu);
  set_gpio_pin_func(&GPIOA, 3u, 0xBu);
  set_gpio_pin_func(&GPIOA, 6u, 0xBu);
  set_gpio_pin_func(&GPIOA, 7u, 0xBu);
  set_gpio_pin_func(&GPIOA, 8u, 0xBu);
  set_gpio_pin_func(&GPIOA, 9u, 0xBu);
  set_gpio_pin_func(&GPIOA, 10u, 0xBu);
  set_gpio_pin_func(&GPIOA, 15u, 0xBu);
  cfg.pins = 65339;
  cfg.mode = 2;
  gpio_config_pin(&GPIOB, &cfg);
  set_gpio_pin_func(&GPIOB, 0, 0xBu);
  set_gpio_pin_func(&GPIOB, 1u, 0xBu);
  set_gpio_pin_func(&GPIOB, 3u, 0xBu);
  set_gpio_pin_func(&GPIOB, 4u, 0xBu);
  set_gpio_pin_func(&GPIOB, 5u, 0xBu);
  set_gpio_pin_func(&GPIOB, 8u, 0xBu);
  set_gpio_pin_func(&GPIOB, 9u, 0xBu);
  set_gpio_pin_func(&GPIOB, 10u, 0xBu);
  set_gpio_pin_func(&GPIOB, 11u, 0xBu);
  set_gpio_pin_func(&GPIOB, 12u, 0xBu);
  set_gpio_pin_func(&GPIOB, 13u, 0xBu);
  set_gpio_pin_func(&GPIOB, 14u, 0xBu);
  set_gpio_pin_func(&GPIOB, 15u, 0xBu);
  cfg.pins = 1791;
  cfg.mode = 2;
  gpio_config_pin(&GPIOC, &cfg);
  set_gpio_pin_func(&GPIOC, 0, 0xBu);
  set_gpio_pin_func(&GPIOC, 1u, 0xBu);
  set_gpio_pin_func(&GPIOC, 2u, 0xBu);
  set_gpio_pin_func(&GPIOC, 3u, 0xBu);
  set_gpio_pin_func(&GPIOC, 4u, 0xBu);
  set_gpio_pin_func(&GPIOC, 5u, 0xBu);
  set_gpio_pin_func(&GPIOC, 6u, 0xBu);
  set_gpio_pin_func(&GPIOC, 7u, 0xBu);
  set_gpio_pin_func(&GPIOC, 9u, 0xBu);
  set_gpio_pin_func(&GPIOC, 10u, 0xBu);
  cfg.pins = 65280;
  cfg.mode = 2;
  gpio_config_pin(&GPIOD, &cfg);
  set_gpio_pin_func(&GPIOD, 8u, 0xBu);
  set_gpio_pin_func(&GPIOD, 9u, 0xBu);
  set_gpio_pin_func(&GPIOD, 10u, 0xBu);
  set_gpio_pin_func(&GPIOD, 11u, 0xBu);
  set_gpio_pin_func(&GPIOD, 12u, 0xBu);
  set_gpio_pin_func(&GPIOD, 13u, 0xBu);
  set_gpio_pin_func(&GPIOD, 14u, 0xBu);
  set_gpio_pin_func(&GPIOD, 15u, 0xBu);
  cfg.pins = 15;
  cfg.mode = 2;
  gpio_config_pin(&GPIOE, &cfg);
  set_gpio_pin_func(&GPIOE, 0, 0xBu);
  set_gpio_pin_func(&GPIOE, 1u, 0xBu);
  set_gpio_pin_func(&GPIOE, 2u, 0xBu);
  set_gpio_pin_func(&GPIOE, 3u, 0xBu);
}
// 40020400: using guessed type GPIO_REGS GPIOB;
// 40020800: using guessed type GPIO_REGS GPIOC;
// 40020C00: using guessed type GPIO_REGS GPIOD;
// 40021000: using guessed type GPIO_REGS GPIOE;

//----- (0800A75E) --------------------------------------------------------
void __fastcall lcd_set_contrast(unsigned __int8 contrast)
{
  if ( contrast == 10 )
  {
    lcd_set_contrast_reg(0);
  }
  else if ( contrast >= 0xAu )
  {
    if ( contrast == 12 )
    {
      lcd_set_contrast_reg(2048);
    }
    else if ( contrast >= 0xCu )
    {
      if ( contrast == 14 )
      {
        lcd_set_contrast_reg(0x1000);
      }
      else if ( contrast >= 0xEu )
      {
        if ( contrast == 16 )
        {
          lcd_set_contrast_reg(0x1800);
        }
        else if ( contrast >= 0x10u )
        {
          if ( contrast == 17 )
            lcd_set_contrast_reg(7168);
        }
        else
        {
          lcd_set_contrast_reg(5120);
        }
      }
      else
      {
        lcd_set_contrast_reg(3072);
      }
    }
    else
    {
      lcd_set_contrast_reg(1024);
    }
  }
}

//----- (0800A7D0) --------------------------------------------------------
void maybe_refresh_lcd_contrast_register()
{
  int v0; // r4@0

  if ( curr_lcd_contrast == 10 )
  {
    v0 = 0;
  }
  else if ( (unsigned __int8)curr_lcd_contrast >= 0xAu )
  {
    if ( curr_lcd_contrast == 12 )
    {
      v0 = LCD_FCR & 0x800;
    }
    else if ( (unsigned __int8)curr_lcd_contrast >= 0xCu )
    {
      if ( curr_lcd_contrast == 14 )
      {
        v0 = LCD_FCR & 0x1000;
      }
      else if ( (unsigned __int8)curr_lcd_contrast >= 0xEu )
      {
        if ( curr_lcd_contrast == 16 )
        {
          v0 = LCD_FCR & 0x1800;
        }
        else if ( (unsigned __int8)curr_lcd_contrast >= 0x10u )
        {
          if ( curr_lcd_contrast == 17 )
            v0 = LCD_FCR & 0x1C00;
        }
        else
        {
          v0 = LCD_FCR & 0x1400;
        }
      }
      else
      {
        v0 = LCD_FCR & 0xC00;
      }
    }
    else
    {
      v0 = LCD_FCR & 0x400;
    }
  }
  lcd_set_contrast_reg(v0);
}
// 20000222: using guessed type char curr_lcd_contrast;
// 40002404: using guessed type int LCD_FCR;

//----- (0800A8C0) --------------------------------------------------------
unsigned __int8 __fastcall read_eeprom_byte_also(int loc)
{
  return read_eeprom_byte(loc);
}

//----- (0800A8CC) --------------------------------------------------------
void __fastcall try_to_write_byte_10_times_also_also(int loc, unsigned __int8 data)
{
  try_to_write_byte_10_times_also(loc, data);
}

//----- (0800A8DE) --------------------------------------------------------
void __cdecl log_prepare_sample()
{
  log_prsamp_A_range_mode = curr_meas_mode + 32 * curr_meas_range;
  log_prsamp_B_flags = 0;
  if ( lowz_measuring_ac )
    log_prsamp_B_flags |= 1u;
  if ( lowz_active_cause_of_enough_volts )
    log_prsamp_B_flags |= 2u;
  if ( input_lpf_enabled )
    log_prsamp_B_flags |= 4u;
  if ( input_1ms_peak_enabled )
    log_prsamp_B_flags |= 8u;
  if ( meter_mode_acv_dcv )
    log_prsamp_B_flags |= 0x10u;
  if ( temp_in_c )
    log_prsamp_B_flags |= 0x20u;
  log_prepare_sample_main_measurement();
  log_prsamp_E_ex_volt_flags = 0;
  log_prsamp_D_ex_volt_range_mode = 0;
  log_prsamp_F_ex_volt_value = 0;
  if ( curr_meas_mode != MM_ACuA
    && curr_meas_mode != MM_ACmA
    && curr_meas_mode != MM_ACA
    && (curr_meas_mode != MM_ACV || meter_mode_acv_dcv)
    && curr_meas_mode != MM_ACmV )
  {
    if ( curr_meas_mode == MM_ACuVA
      || curr_meas_mode == MM_ACmVA
      || curr_meas_mode == MM_ACVA
      || curr_meas_mode == MM_DCuVA
      || curr_meas_mode == MM_DCmVA
      || curr_meas_mode == MM_DCVA )
    {
      if ( curr_meas_mode != MM_ACuVA && curr_meas_mode != MM_ACmVA && curr_meas_mode != MM_ACVA )
        log_prsamp_D_ex_volt_range_mode = MM_DCV;
      else
        log_prsamp_D_ex_volt_range_mode = MM_ACV;
      if ( curr_meas_range == 1 || curr_meas_range == 3 )
        log_prsamp_D_ex_volt_range_mode += 32;
      if ( curr_power_volts_overflow )
        log_prsamp_E_ex_volt_flags |= 0x80u;
      log_prsamp_F_ex_volt_value = meter_power_volts;
    }
  }
  else if ( (curr_meas_mode == MM_ACuA || curr_meas_mode == MM_ACmA || curr_meas_mode == MM_ACA)
         && burden_enabled_for_current_ranges )
  {
    log_prsamp_D_ex_volt_range_mode = MM_BURDEN;
    if ( burden_overflow )
      log_prsamp_E_ex_volt_flags |= 0x80u;
    log_prsamp_F_ex_volt_value = burden_last_volts;
  }
  else
  {
    log_prsamp_D_ex_volt_range_mode = 32 * ac_input_freq_range + MM_HZ;
    if ( ac_input_hz_overflow )
      log_prsamp_E_ex_volt_flags |= 0x80u;
    log_prsamp_F_ex_volt_value = ac_input_freq;
  }
  log_prsamp_H_ex_amp_flags = 0;
  log_prsamp_G_ex_amp_range_mode = 0;
  log_prsamp_I_ex_amp_value = 0;
  if ( curr_meas_mode == MM_ACuVA
    || curr_meas_mode == MM_ACmVA
    || curr_meas_mode == MM_ACVA
    || curr_meas_mode == MM_DCuVA
    || curr_meas_mode == MM_DCmVA
    || curr_meas_mode == MM_DCVA )
  {
    switch ( curr_meas_mode )
    {
      case MM_ACuVA:
        log_prsamp_G_ex_amp_range_mode = MM_ACuA;
        break;
      case MM_ACmVA:
        log_prsamp_G_ex_amp_range_mode = MM_ACmA;
        break;
      case MM_ACVA:
        log_prsamp_G_ex_amp_range_mode = MM_ACA;
        break;
      case MM_DCuVA:
        log_prsamp_G_ex_amp_range_mode = MM_DCuA;
        break;
      case MM_DCmVA:
        log_prsamp_G_ex_amp_range_mode = MM_DCmA;
        break;
      case MM_DCVA:
        log_prsamp_G_ex_amp_range_mode = MM_DCA;
        break;
    }
    if ( curr_meas_mode != MM_ACuVA )
    {
      if ( curr_meas_mode == MM_ACmVA )
        goto LABEL_75;
      if ( curr_meas_mode == MM_ACVA )
        goto LABEL_78;
      if ( curr_meas_mode != MM_DCuVA )
      {
        if ( curr_meas_mode != MM_DCmVA )
        {
          if ( curr_meas_mode != MM_DCVA )
          {
LABEL_80:
            if ( curr_power_amps_overflow )
              log_prsamp_H_ex_amp_flags |= 0x80u;
            if ( curr_meas_mode != MM_ACuVA && curr_meas_mode != MM_DCuVA )
              log_prsamp_I_ex_amp_value = meter_power_amps;
            else
              log_prsamp_I_ex_amp_value = meter_power_amps_uVA_precise;
            return;
          }
LABEL_78:
          if ( (signed int)curr_meas_range >= 2 )
            log_prsamp_G_ex_amp_range_mode += 64;
          goto LABEL_80;
        }
LABEL_75:
        if ( (signed int)curr_meas_range >= 2 )
          log_prsamp_G_ex_amp_range_mode += 32;
        goto LABEL_80;
      }
    }
    if ( (signed int)curr_meas_range >= 2 )
      log_prsamp_G_ex_amp_range_mode += 32;
    goto LABEL_80;
  }
}
// 20003824: using guessed type int log_prsamp_F_ex_volt_value;
// 20003828: using guessed type int log_prsamp_I_ex_amp_value;
// 20003870: using guessed type int ac_input_freq;
// 2000394C: using guessed type int burden_last_volts;
// 2000398C: using guessed type int meter_power_volts;
// 20003990: using guessed type int meter_power_amps;
// 20003994: using guessed type int meter_power_amps_uVA_precise;
// 20003AAA: using guessed type char log_prsamp_A_range_mode;
// 20003AAB: using guessed type char log_prsamp_B_flags;
// 20003AAC: using guessed type char log_prsamp_D_ex_volt_range_mode;
// 20003AAD: using guessed type char log_prsamp_E_ex_volt_flags;
// 20003AAE: using guessed type char log_prsamp_G_ex_amp_range_mode;
// 20003AAF: using guessed type char log_prsamp_H_ex_amp_flags;
// 20003AE9: using guessed type char ac_input_hz_overflow;
// 20003B32: using guessed type char lowz_measuring_ac;
// 20003B33: using guessed type char lowz_active_cause_of_enough_volts;
// 20003B3D: using guessed type char burden_enabled_for_current_ranges;
// 20003B3F: using guessed type char burden_overflow;
// 20003B43: using guessed type char temp_in_c;
// 20003B4F: using guessed type char input_1ms_peak_enabled;
// 20003B51: using guessed type char input_lpf_enabled;
// 20003B52: using guessed type char meter_mode_acv_dcv;
// 20003B5D: using guessed type char curr_power_volts_overflow;
// 20003B5E: using guessed type char curr_power_amps_overflow;

//----- (0800AC9C) --------------------------------------------------------
void __cdecl log_prepare_sample_main_measurement()
{
  if ( (curr_meas_mode < (signed int)MM_HZ || curr_meas_mode >= (signed int)MM_OHMS)
    && curr_meas_mode != MM_CAP
    && curr_meas_mode != MM_TEMP )
  {
    // diode and continuity use bargraph as sample
    if ( curr_bargraph_digits >= 0 )
    {
      log_prsamp_C_main_measurement = curr_bargraph_digits;
    }
    else
    {
      log_prsamp_B_flags |= 0x40u;
      log_prsamp_C_main_measurement = ~curr_bargraph_digits;
    }
  }
  else if ( curr_scr_overflow )
  {
    log_prsamp_B_flags |= 0x80u;
    log_prsamp_C_main_measurement = 0x7FFFFFFF;
    if ( meter_overflow_was_negative )
      log_prsamp_B_flags |= 0x40u;
  }
  else if ( curr_scr_digits >= 0 )
  {
    log_prsamp_C_main_measurement = curr_scr_digits;
  }
  else
  {
    log_prsamp_B_flags |= 0x40u;
    log_prsamp_C_main_measurement = ~curr_scr_digits;
  }
}
// 20003820: using guessed type int log_prsamp_C_main_measurement;
// 20003858: using guessed type int curr_scr_digits;
// 2000385C: using guessed type int curr_bargraph_digits;
// 20003AAB: using guessed type char log_prsamp_B_flags;
// 20003AE7: using guessed type char meter_overflow_was_negative;

//----- (0800AD74) --------------------------------------------------------
void __fastcall logging_begin()
{
  if ( batt_is_low_icon )
  {
    curr_sys_error = 20;
    need_to_update_subscr = 1;
  }
  else
  {
    curr_sub_mode = 100;
    if ( !auto_hold_is_enabled )
      autoranging_disabled = 1;
    rel_meas_enabled = 0;
    meter_min_max_mode = 0;
    manual_hold_is_enabled = 0;
    maybe_logging_was_active_at_some_point = 1;
    logging_interval_elapsed = 0;
    log_playback_mode = 0;
    log_playback_pos = 0;
    log_samples_in_eeprom = 0;
    log_total_samples = 0;
    log_successful_flushes = 0;
    log_file_starting_new_link = 1;
    log_need_to_flush_samples_from_eeprom = 1;
    need_to_display_logging_ended = 0;
    log_file_total_samples_written_backup = 0;
    log_file_total_samples_written = 0;
    log_file_need_to_write_header = 0;
    log_file_is_ending = 0;
    log_file_chain_idx = 0;
    logging_interval_timer_1s = curr_logging_interval - 1;
    logging_interval_maxspeed_timer_200ms = 0;
    write_logged_meas_mode_and_range_to_eeprom();
    set_log_start_time_and_write_to_eeprom_badly();
  }
}
// 2000382C: using guessed type int log_successful_flushes;
// 20003830: using guessed type int log_total_samples;
// 20003834: using guessed type int log_file_total_samples_written;
// 2000383C: using guessed type int log_file_total_samples_written_backup;
// 20003A54: using guessed type __int16 log_playback_pos;
// 20003A5C: using guessed type __int16 log_samples_in_eeprom;
// 20003A64: using guessed type __int16 log_file_chain_idx;
// 20003A9F: using guessed type char maybe_logging_was_active_at_some_point;
// 20003AB6: using guessed type char logging_interval_maxspeed_timer_200ms;
// 20003AC4: using guessed type char log_need_to_flush_samples_from_eeprom;
// 20003AC5: using guessed type char need_to_display_logging_ended;
// 20003ACC: using guessed type char log_file_starting_new_link;
// 20003ACD: using guessed type char log_file_is_ending;
// 20003ACE: using guessed type char log_file_need_to_write_header;
// 20003ADF: using guessed type char batt_is_low_icon;
// 20003AE6: using guessed type char autoranging_disabled;
// 20003AF5: using guessed type char rel_meas_enabled;
// 20003AFE: using guessed type char need_to_update_subscr;

//----- (0800AE60) --------------------------------------------------------
void __fastcall logging_end(char flush_samples)
{
  char v1; // r4@1

  v1 = flush_samples;
  meter_set_default_subscr_mode();
  save_eeprom_sample_count();
  set_log_end_time_and_write_start_time_to_eeprom_badly();
  if ( log_samples_in_eeprom && (signed int)(unsigned __int16)log_samples_in_eeprom < 60 )
    log_samples_in_eeprom_that_need_flushing = (unsigned __int16)log_samples_in_eeprom;
  log_file_is_ending = 1;
  log_file_starting_new_link = 0;
  if ( v1 == 1 )
    log_flush_samples_from_eeprom();
  log_calc_playback_window();
}
// 20003838: using guessed type int log_samples_in_eeprom_that_need_flushing;
// 20003A5C: using guessed type __int16 log_samples_in_eeprom;
// 20003ACC: using guessed type char log_file_starting_new_link;
// 20003ACD: using guessed type char log_file_is_ending;

//----- (0800AEB0) --------------------------------------------------------
void __fastcall log_save_sample()
{
  logging_interval_elapsed = 0;
  if ( (signed int)(unsigned __int16)log_samples_in_eeprom >= 60 )
    log_samples_in_eeprom = 0;
  log_write_sample_to_eeprom(log_samples_in_eeprom++);
  if ( (signed int)(unsigned __int16)log_samples_in_eeprom >= 60 )
  {
    log_need_to_flush_samples_from_eeprom = 1;
    log_samples_in_eeprom_that_need_flushing = 60;
  }
  ++log_total_samples;
  need_to_update_subscr = 1;
}
// 20003830: using guessed type int log_total_samples;
// 20003838: using guessed type int log_samples_in_eeprom_that_need_flushing;
// 20003A5C: using guessed type __int16 log_samples_in_eeprom;
// 20003AC4: using guessed type char log_need_to_flush_samples_from_eeprom;
// 20003AFE: using guessed type char need_to_update_subscr;

//----- (0800AF12) --------------------------------------------------------
void save_eeprom_sample_count()
{
  write_eeprom_2byte(1200, log_samples_in_eeprom);
  write_eeprom_4byte(1202, log_total_samples);
}
// 20003830: using guessed type int log_total_samples;
// 20003A5C: using guessed type __int16 log_samples_in_eeprom;

//----- (0800AF32) --------------------------------------------------------
void load_eeprom_sample_count()
{
  log_samples_in_eeprom = read_eeprom_2byte(1200);
  log_total_samples = read_eeprom_4byte(1202);
  if ( (signed int)(unsigned __int16)log_samples_in_eeprom >= 61 || (unsigned int)log_total_samples >= 600000 )
  {
    log_samples_in_eeprom = 0;
    log_total_samples = 0;
  }
  log_calc_playback_window();
}
// 20003830: using guessed type int log_total_samples;
// 20003A5C: using guessed type __int16 log_samples_in_eeprom;

//----- (0800AF7E) --------------------------------------------------------
void log_calc_playback_window()
{
  if ( (unsigned int)log_total_samples < 61 )
  {
    log_playback_window_start = 1;
    log_playback_window_len = log_samples_in_eeprom;
    log_playback_window_end = log_samples_in_eeprom;
  }
  else
  {
    log_playback_window_start = log_samples_in_eeprom + 1;
    log_playback_window_len = log_samples_in_eeprom;
    log_playback_window_end = 60;
  }
  log_playback_pos = 1;
}
// 20003830: using guessed type int log_total_samples;
// 20003A54: using guessed type __int16 log_playback_pos;
// 20003A5A: using guessed type __int16 log_playback_window_len;
// 20003A5C: using guessed type __int16 log_samples_in_eeprom;

//----- (0800AFD6) --------------------------------------------------------
unsigned __int16 __fastcall log_get_eeprom_idx_for_sample(unsigned __int16 sample)
{
  unsigned __int16 result; // r0@2

  if ( log_playback_window_end >= log_playback_window_start + sample - 1 )
    result = log_playback_window_start + sample - 1;
  else
    result = log_playback_window_start + sample - 1 - log_playback_window_end;
  return result;
}

//----- (0800B016) --------------------------------------------------------
void __fastcall write_logged_meas_mode_and_range_to_eeprom()
{
  try_to_write_byte_10_times_also(1208, curr_meas_mode);
  try_to_write_byte_10_times_also(1209, curr_meas_range);
}

//----- (0800B032) --------------------------------------------------------
void read_logged_meas_mode_range_from_eeprom(void)
{
  logged_meas_mode = read_eeprom_byte(1208);
  logged_meas_range = read_eeprom_byte(1209);
}
// 20003AA8: using guessed type char logged_meas_range;

//----- (0800B052) --------------------------------------------------------
void __fastcall set_log_start_time_and_write_to_eeprom_badly()
{
  log_start_year = curr_year;
  log_start_month = curr_month;
  log_start_day = curr_day;
  log_start_hour = curr_hour;
  log_start_minute = curr_minute;
  log_start_second = curr_second;
  try_to_write_byte_10_times_also(1216, curr_year);
  try_to_write_byte_10_times_also(1217, (unsigned __int8)log_start_month);
  try_to_write_byte_10_times_also(1217, (unsigned __int8)log_start_day);
  try_to_write_byte_10_times_also(1217, (unsigned __int8)log_start_hour);
  try_to_write_byte_10_times_also(1217, (unsigned __int8)log_start_minute);
  try_to_write_byte_10_times_also(1217, (unsigned __int8)log_start_second);
}
// 20003AB7: using guessed type char log_start_year;
// 20003AB8: using guessed type char log_start_month;
// 20003AB9: using guessed type char log_start_day;
// 20003ABA: using guessed type char log_start_hour;
// 20003ABB: using guessed type char log_start_minute;
// 20003ABC: using guessed type char log_start_second;

//----- (0800B0EA) --------------------------------------------------------
void __fastcall load_log_start_time_from_eeprom_badly()
{
  log_start_year = read_eeprom_byte(1216);
  log_start_month = read_eeprom_byte(1217);
  log_start_day = read_eeprom_byte(1217);
  log_start_hour = read_eeprom_byte(1217);
  log_start_minute = read_eeprom_byte(1217);
  log_start_second = read_eeprom_byte(1217);
}
// 20003AB7: using guessed type char log_start_year;
// 20003AB8: using guessed type char log_start_month;
// 20003AB9: using guessed type char log_start_day;
// 20003ABA: using guessed type char log_start_hour;
// 20003ABB: using guessed type char log_start_minute;
// 20003ABC: using guessed type char log_start_second;

//----- (0800B13A) --------------------------------------------------------
void __fastcall set_log_end_time_and_write_start_time_to_eeprom_badly()
{
  log_end_year = curr_year;
  log_end_month = curr_month;
  log_end_day = curr_day;
  log_end_hour = curr_hour;
  log_end_minute = curr_minute;
  log_end_second = curr_second;
  try_to_write_byte_10_times_also(1222, (unsigned __int8)log_start_year);
  try_to_write_byte_10_times_also(1223, (unsigned __int8)log_start_month);
  try_to_write_byte_10_times_also(1223, (unsigned __int8)log_start_day);
  try_to_write_byte_10_times_also(1223, (unsigned __int8)log_start_hour);
  try_to_write_byte_10_times_also(1223, (unsigned __int8)log_start_minute);
  try_to_write_byte_10_times_also(1223, (unsigned __int8)log_start_second);
}
// 20003AB7: using guessed type char log_start_year;
// 20003AB8: using guessed type char log_start_month;
// 20003AB9: using guessed type char log_start_day;
// 20003ABA: using guessed type char log_start_hour;
// 20003ABB: using guessed type char log_start_minute;
// 20003ABC: using guessed type char log_start_second;
// 20003ABD: using guessed type char log_end_year;
// 20003ABE: using guessed type char log_end_month;
// 20003ABF: using guessed type char log_end_day;
// 20003AC0: using guessed type char log_end_hour;
// 20003AC1: using guessed type char log_end_minute;
// 20003AC2: using guessed type char log_end_second;

//----- (0800B1D2) --------------------------------------------------------
void __fastcall load_log_end_time_from_eeprom_badly()
{
  log_end_year = read_eeprom_byte(1222);
  log_end_month = read_eeprom_byte(1223);
  log_end_day = read_eeprom_byte(1223);
  log_end_hour = read_eeprom_byte(1223);
  log_end_minute = read_eeprom_byte(1223);
  log_end_second = read_eeprom_byte(1223);
}
// 20003ABD: using guessed type char log_end_year;
// 20003ABE: using guessed type char log_end_month;
// 20003ABF: using guessed type char log_end_day;
// 20003AC0: using guessed type char log_end_hour;
// 20003AC1: using guessed type char log_end_minute;
// 20003AC2: using guessed type char log_end_second;

//----- (0800B222) --------------------------------------------------------
void __fastcall log_write_sample_to_eeprom(unsigned __int16 a1)
{
  int v1; // r5@1

  v1 = 18 * a1 + 1280;
  try_to_write_byte_10_times_also(v1, (unsigned __int8)log_prsamp_A_range_mode);
  try_to_write_byte_10_times_also(v1 + 1, (unsigned __int8)log_prsamp_B_flags);
  write_eeprom_4byte(v1 + 2, log_prsamp_C_main_measurement);
  try_to_write_byte_10_times_also(v1 + 6, (unsigned __int8)log_prsamp_D_ex_volt_range_mode);
  try_to_write_byte_10_times_also(v1 + 7, (unsigned __int8)log_prsamp_E_ex_volt_flags);
  write_eeprom_4byte(v1 + 8, log_prsamp_F_ex_volt_value);
  try_to_write_byte_10_times_also(v1 + 12, (unsigned __int8)log_prsamp_G_ex_amp_range_mode);
  try_to_write_byte_10_times_also(v1 + 13, (unsigned __int8)log_prsamp_H_ex_amp_flags);
  write_eeprom_4byte(v1 + 14, log_prsamp_I_ex_amp_value);
}
// 20003820: using guessed type int log_prsamp_C_main_measurement;
// 20003824: using guessed type int log_prsamp_F_ex_volt_value;
// 20003828: using guessed type int log_prsamp_I_ex_amp_value;
// 20003AAA: using guessed type char log_prsamp_A_range_mode;
// 20003AAB: using guessed type char log_prsamp_B_flags;
// 20003AAC: using guessed type char log_prsamp_D_ex_volt_range_mode;
// 20003AAD: using guessed type char log_prsamp_E_ex_volt_flags;
// 20003AAE: using guessed type char log_prsamp_G_ex_amp_range_mode;
// 20003AAF: using guessed type char log_prsamp_H_ex_amp_flags;

//----- (0800B2E4) --------------------------------------------------------
void __fastcall log_read_sample_from_eeprom(unsigned __int16 sample)
{
  int v1; // r5@1

  v1 = 18 * sample + 1280;
  log_rdsamp_A_range_mode = read_eeprom_byte(v1);
  log_rdsamp_mode = log_rdsamp_A_range_mode & 0x1F;
  log_rdsamp_range = (unsigned __int8)log_rdsamp_A_range_mode >> 5;
  log_rdsamp_B_flags = read_eeprom_byte(v1 + 1);
  log_rdsamp_lowz_measuring_ac = 0;
  if ( log_rdsamp_B_flags & 1 )
    log_rdsamp_lowz_measuring_ac = 1;
  log_rdsamp_lowz_active_cause_of_enough_volts = 0;
  if ( log_rdsamp_B_flags & 2 )
    log_rdsamp_lowz_active_cause_of_enough_volts = 1;
  log_rdsamp_input_lpf_enabled = 0;
  if ( log_rdsamp_B_flags & 4 )
    log_rdsamp_input_lpf_enabled = 1;
  log_rdsamp_input_1ms_peak_enabled = 0;
  if ( log_rdsamp_B_flags & 8 )
    log_rdsamp_input_1ms_peak_enabled = 1;
  log_rdsamp_in_ac_dc_mode = 0;
  if ( log_rdsamp_B_flags & 0x10 )
    log_rdsamp_in_ac_dc_mode = 1;
  log_rdsamp_temp_in_c = 0;
  if ( log_rdsamp_B_flags & 0x20 )
    log_rdsamp_temp_in_c = 1;
  log_rdsamp_C_main_measurement = read_eeprom_4byte(v1 + 2);
  log_rdsamp_D_ex_volt_range_mode = read_eeprom_byte(v1 + 6);
  log_rdsamp_ex_volt_mode = log_rdsamp_D_ex_volt_range_mode & 0x1F;
  log_rdsamp_ex_volt_range = (unsigned __int8)log_rdsamp_D_ex_volt_range_mode >> 5;
  log_rdsamp_E_ex_volt_flags = read_eeprom_byte(v1 + 7);
  log_rdsamp_F_ex_volt_value = read_eeprom_4byte(v1 + 8);
  log_rdsamp_G_ex_amp_range_mode = read_eeprom_byte(v1 + 12);
  log_rdsamp_ex_amp_mode = log_rdsamp_G_ex_amp_range_mode & 0x1F;
  log_rdsamp_ex_amp_range = (unsigned __int8)log_rdsamp_G_ex_amp_range_mode >> 5;
  log_rdsamp_H_ex_amp_flags = read_eeprom_byte(v1 + 13);
  log_rdsamp_I_ex_amp_value = read_eeprom_4byte(v1 + 14);
}
// 20003814: using guessed type int log_rdsamp_C_main_measurement;
// 20003818: using guessed type int log_rdsamp_F_ex_volt_value;
// 2000381C: using guessed type int log_rdsamp_I_ex_amp_value;
// 20003AA1: using guessed type char log_rdsamp_lowz_measuring_ac;
// 20003AA2: using guessed type char log_rdsamp_lowz_active_cause_of_enough_volts;
// 20003AA3: using guessed type char log_rdsamp_input_lpf_enabled;
// 20003AA4: using guessed type char log_rdsamp_input_1ms_peak_enabled;
// 20003AA5: using guessed type char log_rdsamp_in_ac_dc_mode;
// 20003AA6: using guessed type char log_rdsamp_temp_in_c;
// 20003AB0: using guessed type char log_rdsamp_A_range_mode;
// 20003AB1: using guessed type char log_rdsamp_B_flags;
// 20003AB2: using guessed type char log_rdsamp_D_ex_volt_range_mode;
// 20003AB3: using guessed type char log_rdsamp_E_ex_volt_flags;
// 20003AB4: using guessed type char log_rdsamp_G_ex_amp_range_mode;
// 20003AB5: using guessed type char log_rdsamp_H_ex_amp_flags;
// 20003AC7: using guessed type char log_rdsamp_range;
// 20003AC8: using guessed type char log_rdsamp_ex_volt_mode;
// 20003AC9: using guessed type char log_rdsamp_ex_volt_range;
// 20003ACA: using guessed type char log_rdsamp_ex_amp_mode;
// 20003ACB: using guessed type char log_rdsamp_ex_amp_range;

//----- (0800B496) --------------------------------------------------------
void load_curr_year_month()
{
  last_cal_year_month = read_eeprom_2byte(1);
  if ( !last_cal_year_month )
    last_cal_year_month = 1708;
}

//----- (0800B4C0) --------------------------------------------------------
void __fastcall save_last_cal_year_month()
{
  try_to_write_byte_10_times_also(1, (unsigned __int8)last_cal_year_month);
}

//----- (0800B4D8) --------------------------------------------------------
void load_meter_serial()
{
  curr_meter_serial = read_eeprom_4byte(3);
  if ( (unsigned int)curr_meter_serial >= 100000 )
    curr_meter_serial = 0;
}
// 2000380C: using guessed type int curr_meter_serial;

//----- (0800B504) --------------------------------------------------------
void save_meter_serial(void)
{
  write_eeprom_4byte(3, curr_meter_serial);
}
// 2000380C: using guessed type int curr_meter_serial;

//----- (0800B558) --------------------------------------------------------
meter_meas_mode __fastcall get_last_mode_v()
{
  meter_meas_mode v0; // r5@1
  meter_meas_mode v1; // r4@1

  v0 = MM_DCV;
  v1 = read_eeprom_byte(8);
  if ( (unsigned __int8)v1 == 130 )
  {
    v0 = MM_ACV;
    meter_enable_acv_dcv_mode();
  }
  else if ( v1 == MM_DCV || v1 == MM_ACV )
  {
    v0 = v1;
  }
  return v0;
}

//----- (0800B588) --------------------------------------------------------
meter_meas_mode get_last_mode_mv(void)
{
  meter_meas_mode v0; // r5@1
  int v1; // r4@1

  v0 = MM_DCmV;
  v1 = read_eeprom_byte(9);
  if ( v1 == MM_DCmV || (unsigned __int8)v1 == MM_ACmV || (unsigned __int8)v1 == MM_TEMP )
    v0 = (unsigned __int8)v1;
  return v0;
}

//----- (0800B5AE) --------------------------------------------------------
meter_meas_mode get_last_mode_hz(void)
{
  meter_meas_mode v0; // r5@1
  int v1; // r4@1

  v0 = MM_HZ;
  v1 = read_eeprom_byte(10);
  if ( v1 == MM_HZ || (unsigned __int8)v1 == MM_mSEC || (unsigned __int8)v1 == MM_DUTY )
    v0 = (unsigned __int8)v1;
  return v0;
}

//----- (0800B5D4) --------------------------------------------------------
meter_meas_mode get_last_mode_ohms(void)
{
  meter_meas_mode v0; // r5@1
  int v1; // r4@1

  v0 = MM_OHMS;
  v1 = read_eeprom_byte(11);
  if ( v1 == MM_OHMS
    || (unsigned __int8)v1 == MM_CONTINUITY
    || (unsigned __int8)v1 == MM_DIODE
    || (unsigned __int8)v1 == MM_CAP )
    v0 = (unsigned __int8)v1;
  return v0;
}

//----- (0800B600) --------------------------------------------------------
meter_meas_mode get_last_mode_pwr(void)
{
  meter_meas_mode v0; // r5@1
  int v1; // r4@1

  v0 = MM_DCVA;
  v1 = read_eeprom_byte(12);
  if ( v1 == MM_DCVA || (unsigned __int8)v1 == MM_ACVA )
    v0 = (unsigned __int8)v1;
  return v0;
}

//----- (0800B620) --------------------------------------------------------
meter_meas_mode get_last_mode_uA(void)
{
  meter_meas_mode v0; // r5@1
  int v1; // r4@1

  v0 = MM_DCuA;
  v1 = read_eeprom_byte(13);
  if ( v1 == MM_DCuA
    || (unsigned __int8)v1 == MM_ACuA
    || (unsigned __int8)v1 == MM_ACuVA
    || (unsigned __int8)v1 == MM_DCuVA )
    v0 = (unsigned __int8)v1;
  return v0;
}

//----- (0800B64C) --------------------------------------------------------
meter_meas_mode get_last_mode_A(void)
{
  meter_meas_mode v0; // r5@1
  unsigned __int8 v1; // r4@1

  v0 = MM_DCmA;
  v1 = read_eeprom_byte(14);
  if ( v1 != MM_DCmA && v1 != MM_DCA )
  {
    if ( v1 == MM_ACmA || v1 == MM_ACA )
      v0 = MM_ACmA;
  }
  else
  {
    v0 = MM_DCmA;
  }
  return v0;
}

//----- (0800B680) --------------------------------------------------------
void __fastcall write_curr_meas_mode_with_a_lockout_or_something(unsigned __int8 a1, char a2)
{
  char v2; // r5@1

  v2 = a2;
  if ( a1 == 8 )
  {
    v2 = a2;
    if ( a2 == 2 )
    {
      if ( meter_mode_acv_dcv )
        v2 = 130;
    }
  }
  try_to_write_byte_10_times_also(a1, (unsigned __int8)v2);
}
// 20003B52: using guessed type char meter_mode_acv_dcv;

//----- (0800B6E8) --------------------------------------------------------
void __fastcall save_curr_meas_mode()
{
  int v0; // r0@4
  int v1; // r0@7
  int v2; // r0@8

  if ( (unsigned int)(unsigned __int8)curr_meas_mode - 1 <= 1 )
  {
    write_curr_meas_mode_with_a_lockout_or_something(8u, curr_meas_mode);
    return;
  }
  if ( (unsigned int)(unsigned __int8)curr_meas_mode - 3 <= 2 )
  {
    write_curr_meas_mode_with_a_lockout_or_something(9u, curr_meas_mode);
    return;
  }
  if ( (unsigned int)(unsigned __int8)curr_meas_mode - 6 <= 2 )
  {
    write_curr_meas_mode_with_a_lockout_or_something(0xAu, curr_meas_mode);
    return;
  }
  v0 = (unsigned __int8)curr_meas_mode - 9;
  if ( (unsigned int)v0 <= 3 )
  {
    write_curr_meas_mode_with_a_lockout_or_something(0xBu, curr_meas_mode);
    return;
  }
  if ( curr_meas_mode == 13 )
    goto LABEL_21;
  if ( curr_meas_mode == 15 )
  {
LABEL_16:
    write_curr_meas_mode_with_a_lockout_or_something(0xCu, curr_meas_mode);
    return;
  }
  v1 = (unsigned __int8)curr_meas_mode - 16;
  if ( (unsigned int)v1 <= 1 )
    goto LABEL_21;
  v2 = (unsigned __int8)curr_meas_mode - 18;
  if ( (unsigned int)v2 <= 3 )
  {
    write_curr_meas_mode_with_a_lockout_or_something(0xEu, curr_meas_mode);
    return;
  }
  if ( curr_meas_mode == 22 )
  {
LABEL_21:
    write_curr_meas_mode_with_a_lockout_or_something(0xDu, curr_meas_mode);
    return;
  }
  if ( curr_meas_mode == 24 )
    goto LABEL_16;
}

//----- (0800B794) --------------------------------------------------------
void load_logging_interval()
{
  unsigned __int16 v0; // r4@1

  v0 = read_eeprom_2byte(24);
  if ( (signed int)v0 >= 1000 )
    curr_logging_interval = 1;
  else
    curr_logging_interval = v0;
}

//----- (0800B7BC) --------------------------------------------------------
void __fastcall save_logging_interval(__int16 a1)
{
  write_eeprom_2byte(24, a1);
}

//----- (0800B7CC) --------------------------------------------------------
void load_lcd_contrast()
{
  unsigned __int8 v0; // r4@1

  v0 = read_eeprom_byte(26);
  if ( (signed int)v0 < 12 || (signed int)v0 >= 18 )
    curr_lcd_contrast = 14;
  else
    curr_lcd_contrast = v0;
}
// 20000222: using guessed type char curr_lcd_contrast;

//----- (0800B7F4) --------------------------------------------------------
void __fastcall save_lcd_contrast(unsigned __int8 a1)
{
  try_to_write_byte_10_times_also(26, a1);
}

//----- (0800B804) --------------------------------------------------------
void load_curr_apo_status()
{
  unsigned __int8 v0; // r4@1

  v0 = read_eeprom_byte(22);
  if ( (signed int)v0 >= 2 )
    curr_apo_off = 0;
  else
    curr_apo_off = v0 != 0;
}

//----- (0800B832) --------------------------------------------------------
void __fastcall save_curr_apo_status(unsigned __int8 a1)
{
  try_to_write_byte_10_times_also(22, a1);
}

//----- (0800B842) --------------------------------------------------------
void load_temp_mode()
{
  unsigned __int8 v0; // r4@1

  v0 = read_eeprom_byte(16);
  if ( (signed int)v0 >= 2 )
    temp_in_c = 0;
  else
    temp_in_c = v0;
}
// 20003B43: using guessed type char temp_in_c;

//----- (0800B864) --------------------------------------------------------
void __fastcall save_curr_temp_unit(unsigned __int8 a1)
{
  try_to_write_byte_10_times_also(16, a1);
}

//----- (0800B874) --------------------------------------------------------
void load_hv_diode_mode()
{
  unsigned __int8 v0; // r4@1

  v0 = read_eeprom_byte(18);
  if ( (signed int)v0 >= 2 )
    high_voltage_diode = 0;
  else
    high_voltage_diode = v0 != 0;
}
// 20003B4B: using guessed type char high_voltage_diode;

//----- (0800B8A2) --------------------------------------------------------
void __fastcall save_diode_voltage(unsigned __int8 a1)
{
  try_to_write_byte_10_times_also(18, a1);
}

//----- (0800B8B2) --------------------------------------------------------
void load_curr_cont_threshold()
{
  unsigned __int8 v0; // r4@1

  v0 = read_eeprom_byte(20);
  if ( (signed int)v0 >= 4 )
    curr_continuity_threshold = 0;
  else
    curr_continuity_threshold = v0;
}
// 20003B4E: using guessed type char curr_continuity_threshold;

//----- (0800B8D8) --------------------------------------------------------
void __fastcall save_curr_continuity_threshold(unsigned __int8 threshold)
{
  try_to_write_byte_10_times_also(20, threshold);
}

//----- (0800B8E8) --------------------------------------------------------
void load_burden_display_enabled()
{
  burden_enabled_for_power_ranges = read_eeprom_byte(27) == 1;
}
// 20003B40: using guessed type char burden_enabled_for_power_ranges;

//----- (0800B91C) --------------------------------------------------------
void __fastcall save_burden_enabled_for_power_ranges(unsigned __int8 a1)
{
  try_to_write_byte_10_times_also(27, a1);
}

//----- (0800B92C) --------------------------------------------------------
void __fastcall cal_load_amp_rel(meter_meas_mode mode, char range)
{
  unsigned __int16 v2; // r7@8

  curr_amp_rel = 0;
  if ( (mode == MM_ACuA || mode == MM_ACmA || mode == MM_ACA || mode == MM_DCuA || mode == MM_DCmA || mode == MM_DCA)
    && !range )
  {
    v2 = calc_amp_rel_eeprom_addr(mode);
    if ( read_eeprom_byte(v2) == 165 )
      curr_amp_rel = read_eeprom_4byte(v2 + 1);
  }
}
// 200038EC: using guessed type int curr_amp_rel;

//----- (0800B9C0) --------------------------------------------------------
void __fastcall cal_save_amp_rel(meter_meas_mode mode, char range, int rel)
{
  int v3; // r6@1
  unsigned __int16 v4; // r7@8

  v3 = rel;
  if ( (mode == MM_ACuA || mode == MM_ACmA || mode == MM_ACA || mode == MM_DCuA || mode == MM_DCmA || mode == MM_DCA)
    && !range )
  {
    v4 = calc_amp_rel_eeprom_addr(mode);
    try_to_write_byte_10_times_also(v4, 165);
    write_eeprom_4byte(v4 + 1, v3);
  }
}

//----- (0800BA12) --------------------------------------------------------
void __fastcall cal_erase_amp_rel_data()
{
  cal_save_amp_rel(MM_ACuA, 0, 0);
  cal_save_amp_rel(MM_DCuA, 0, 0);
  cal_save_amp_rel(MM_ACmA, 0, 0);
  cal_save_amp_rel(MM_DCmA, 0, 0);
  cal_save_amp_rel(MM_ACA, 0, 0);
  cal_save_amp_rel(MM_DCA, 0, 0);
}

//----- (0800BA52) --------------------------------------------------------
int __fastcall calc_amp_rel_eeprom_addr(int mode)
{
  if ( (unsigned __int8)mode == MM_ACuA )
  {
    LOWORD(mode) = 1232;
  }
  else if ( (unsigned __int8)mode >= (unsigned int)MM_ACuA )
  {
    if ( (unsigned __int8)mode == MM_ACmA )
    {
      LOWORD(mode) = 1248;
    }
    else if ( (unsigned __int8)mode >= (unsigned int)MM_ACmA )
    {
      if ( (unsigned __int8)mode == MM_ACA )
      {
        LOWORD(mode) = 1264;
      }
      else if ( (unsigned __int8)mode >= (unsigned int)MM_ACA )
      {
        if ( (unsigned __int8)mode == MM_DCA )
          LOWORD(mode) = 1272;
      }
      else
      {
        LOWORD(mode) = 1256;
      }
    }
    else
    {
      LOWORD(mode) = 1240;
    }
  }
  return (unsigned __int16)mode;
}

//----- (0800BAA0) --------------------------------------------------------
int *__fastcall get_cal_factor_addr()
{
  return (int *)(unsigned __int16)(cal_factor_eeloc_tbl[(unsigned __int8)curr_meas_mode] + 16 * curr_meas_range);
}

//----- (0800BAC8) --------------------------------------------------------
unsigned __int16 *__fastcall get_ac_cal_data_addr(meter_meas_mode mode, char range)
{
  if ( mode == MM_ACuA )
  {
    range = 1;
  }
  else if ( mode == MM_ACmA )
  {
    range = 1;
  }
  return (unsigned __int16 *)(unsigned __int16)(cal_factor_eeloc_tbl[(unsigned __int8)mode]
                                              + 8
                                              + 16 * (unsigned __int8)range);
}

//----- (0800BB24) --------------------------------------------------------
void __fastcall cal_load_factors_for_mode_and_range(meter_meas_mode mode, unsigned __int8 range)
{
  unsigned int v4; // r0@41

  if ( (unsigned __int8)mode == MM_INTERNAL_THERMISTOR )
  {
    curr_cal_factor_eeloc = 0x2E0;
    cal_internal_thermistor_factor = read_eeprom_2byte(0x2E0);
    if ( cal_internal_thermistor_factor > 1000
      || (cal_internal_thermistor_factor + 1000 < 0) ^ __OFADD__(cal_internal_thermistor_factor, 1000) )
      cal_internal_thermistor_factor = 0;
  }
  else
  {
    if ( !meter_in_cal_mode && mode == MM_OHMS && curr_meas_range == 6 )
    {
      cal_ohms_50M_offset_factor = read_eeprom_4byte(376);
      cal_ohms_50M_offset_factor_validate();
    }
    if ( curr_meas_mode != MM_ACuVA && curr_meas_mode != MM_ACmVA && curr_meas_mode != MM_ACVA )
    {
      if ( curr_meas_mode != MM_DCuVA && curr_meas_mode != MM_DCmVA && curr_meas_mode != MM_DCVA )
      {
        if ( mode == MM_HZ )
        {
          curr_cal_factor_eeloc = (unsigned __int16)cal_factor_eeloc_tbl[MM_HZ];
          hy_sysclk_in_decihz = read_eeprom_4byte((unsigned __int16)cal_factor_eeloc_tbl[MM_HZ] + 4);
          if ( hy_sysclk_in_decihz >= 60000001 || hy_sysclk_in_decihz < 40000000 )
            hy_sysclk_in_decihz = 49152050;     // nominal HY3131 frequency
        }
        else
        {
          if ( mode != MM_ACV && mode != MM_ACmV || input_1ms_peak_enabled != 1 )
          {
            if...
          }
          else
          {
            curr_cal_factor_eeloc = (unsigned __int16)cal_factor_eeloc_tbl[25];
          }
          cal_curr_offset_val = read_eeprom_4byte(curr_cal_factor_eeloc);
          v4 = read_eeprom_4byte(curr_cal_factor_eeloc + 4);
          cal_curr_gain_val = fp_from_uint(v4);
          if ( mode == MM_CAP )
            cal_curr_gain_val = fp_div(cal_curr_gain_val, 100000.0);
          else
            cal_curr_gain_val = fp_div(cal_curr_gain_val, 1000000.0);
          spinloop(1u);
        }
      }
      else
      {
        cal_load_va_factors();
      }
    }
    else
    {
      cal_load_va_factors();
    }
  }
}
// 20003850: using guessed type int curr_cal_factor_eeloc;
// 200038E0: using guessed type int cal_curr_offset_val;
// 200038F4: using guessed type int cal_ohms_50M_offset_factor;
// 20003A72: using guessed type __int16 cal_internal_thermistor_factor;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B32: using guessed type char lowz_measuring_ac;
// 20003B4F: using guessed type char input_1ms_peak_enabled;
// 20003B52: using guessed type char meter_mode_acv_dcv;
// 20003B55: using guessed type char acv_dcv_measuring_dc;

//----- (0800BD92) --------------------------------------------------------
void __cdecl cal_ohms_50M_offset_factor_validate()
{
  if ( cal_ohms_50M_offset_factor >= 3001 || cal_ohms_50M_offset_factor < -3000 )
    cal_ohms_50M_offset_factor = 0;
}
// 200038F4: using guessed type int cal_ohms_50M_offset_factor;

//----- (0800BDD4) --------------------------------------------------------
void cal_load_va_factors(void)
{
  unsigned int v0; // r0@1
  unsigned int v1; // r0@1

  curr_cal_factor_eeloc = (int)get_cal_factor_addr();
  cal_curr_offset_va_volts = read_eeprom_4byte(curr_cal_factor_eeloc);
  v0 = read_eeprom_4byte(curr_cal_factor_eeloc + 4);
  cal_curr_gain_va_volts = fp_from_uint(v0);
  cal_curr_gain_va_volts = fp_div(cal_curr_gain_va_volts, 1000000.0);
  curr_cal_factor_eeloc += 8;
  cal_curr_offset_va_amps = read_eeprom_4byte(curr_cal_factor_eeloc);
  v1 = read_eeprom_4byte(curr_cal_factor_eeloc + 4);
  cal_curr_gain_va_amps = fp_from_uint(v1);
  cal_curr_gain_va_amps = fp_div(cal_curr_gain_va_amps, 1000000.0);
}
// 20003850: using guessed type int curr_cal_factor_eeloc;
// 20003904: using guessed type int cal_curr_offset_va_volts;
// 20003908: using guessed type int cal_curr_offset_va_amps;

//----- (0800BE84) --------------------------------------------------------
void __fastcall cal_validate_ac_factor(unsigned int which)
{
  which = (unsigned __int8)which;
  if ( (_BYTE)which )
  {
    if ( which == 2 )
    {
      if ( cal_ac_factor_decirange_lf >= 10001 || cal_ac_factor_decirange_lf < -10000 )
        cal_ac_factor_decirange_lf = 0;
    }
    else if ( which < 2 )
    {
      if ( cal_ac_factor_fullrange >= 20001 || cal_ac_factor_fullrange < -20000 )
        cal_ac_factor_fullrange = 0;
    }
    else if ( which == 3 && (cal_ac_factor_fullrange_lf >= 10001 || cal_ac_factor_fullrange_lf < -10000) )
    {
      cal_ac_factor_fullrange_lf = 0;
    }
  }
  else if ( cal_ac_factor_decirange >= 20001 || cal_ac_factor_decirange < -20000 )
  {
    cal_ac_factor_decirange = 0;
  }
}

//----- (0800BF44) --------------------------------------------------------
void cal_load_ac_factors(void)
{
  if ( curr_meas_mode )
    curr_cal_factor_eeloc = (int)get_ac_cal_data_addr(curr_meas_mode, curr_meas_range);
  else
    curr_cal_factor_eeloc = (int)get_ac_cal_data_addr(MM_ACV, 3);
  cal_ac_factor_decirange = read_eeprom_2byte_signed(curr_cal_factor_eeloc);
  cal_validate_ac_factor(0);
  cal_ac_factor_fullrange = read_eeprom_2byte_signed(curr_cal_factor_eeloc + 2);
  cal_validate_ac_factor(1u);
  cal_ac_factor_decirange_lf = read_eeprom_2byte_signed(curr_cal_factor_eeloc + 4);
  cal_validate_ac_factor(2u);
  cal_ac_factor_fullrange_lf = read_eeprom_2byte_signed(curr_cal_factor_eeloc + 6);
  cal_validate_ac_factor(3u);
}
// 20003850: using guessed type int curr_cal_factor_eeloc;

//----- (0800BFE8) --------------------------------------------------------
void __fastcall cal_write_factor(char factor, signed int val)
{
  float v2; // r6@33
  int v3; // r0@35
  float v4; // r0@39
  int v5; // r0@39

  if ( (unsigned __int8)factor == 0xC8 )
  {
    curr_cal_factor_eeloc = 736;
    if ( cal_internal_thermistor_factor > 1000
      || (cal_internal_thermistor_factor + 1000 < 0) ^ __OFADD__(cal_internal_thermistor_factor, 1000) )
      cal_internal_thermistor_factor = 0;
    write_eeprom_2byte(curr_cal_factor_eeloc, cal_internal_thermistor_factor);
  }
  else if ( (unsigned __int8)factor == 0x96 )
  {
    cal_ohms_50M_offset_factor_validate();
    write_eeprom_4byte(0x178, cal_ohms_50M_offset_factor);
  }
  else if ( curr_meas_mode != MM_ACuVA && curr_meas_mode != MM_ACmVA && curr_meas_mode != MM_ACVA )
  {
    if ( curr_meas_mode != MM_DCuVA && curr_meas_mode != MM_DCmVA && curr_meas_mode != MM_DCVA )
    {
      if ( factor )
      {
        switch ( factor )
        {
          case 1:
            if ( curr_meas_mode == MM_HZ )
            {
              curr_cal_factor_eeloc = (unsigned __int16)cal_factor_eeloc_tbl[(unsigned __int8)curr_meas_mode] + 4;
              write_eeprom_4byte(curr_cal_factor_eeloc, hy_sysclk_in_decihz);
            }
            else
            {
              if ( curr_meas_mode != MM_ACV && curr_meas_mode != MM_ACmV || input_1ms_peak_enabled != 1 )
              {
                curr_cal_factor_eeloc = (unsigned __int16)cal_factor_eeloc_tbl[(unsigned __int8)curr_meas_mode];
                curr_cal_factor_eeloc += 16 * curr_meas_range + 4;
              }
              else
              {
                curr_cal_factor_eeloc = (unsigned __int16)cal_factor_eeloc_tbl[MM_BURDEN] + 4;
              }
              if ( curr_meas_mode == MM_CAP )
                v2 = fp_mul(100000.0, cal_curr_gain_val);
              else
                v2 = fp_mul(1000000.0, cal_curr_gain_val);
              v3 = fp_to_int(v2);
              write_eeprom_4byte(curr_cal_factor_eeloc, v3);
            }
            break;
          case 2:
            curr_cal_factor_eeloc = (unsigned __int16)cal_factor_eeloc_tbl[(unsigned __int8)curr_meas_mode];
            curr_cal_factor_eeloc += 16 * curr_meas_range + 8;
            write_eeprom_4byte(curr_cal_factor_eeloc, val);
            break;
          case 3:
            curr_cal_factor_eeloc = (unsigned __int16)cal_factor_eeloc_tbl[(unsigned __int8)curr_meas_mode];
            curr_cal_factor_eeloc += 16 * curr_meas_range + 12;
            v4 = fp_from_int(10000 * val);
            v5 = fp_to_int(v4);
            write_eeprom_4byte(curr_cal_factor_eeloc, v5);
            break;
        }
      }
      else
      {
        if ( curr_meas_mode != MM_ACV && curr_meas_mode != MM_ACmV || input_1ms_peak_enabled != 1 )
        {
          curr_cal_factor_eeloc = (unsigned __int16)cal_factor_eeloc_tbl[(unsigned __int8)curr_meas_mode];
          curr_cal_factor_eeloc += 16 * curr_meas_range;
        }
        else
        {
          curr_cal_factor_eeloc = (unsigned __int16)cal_factor_eeloc_tbl[25];
        }
        write_eeprom_4byte(curr_cal_factor_eeloc, val);
      }
    }
    else
    {
      cal_save_va_factors(factor);
    }
  }
  else
  {
    cal_save_va_factors(factor);
  }
}
// 20003850: using guessed type int curr_cal_factor_eeloc;
// 200038F4: using guessed type int cal_ohms_50M_offset_factor;
// 20003A72: using guessed type __int16 cal_internal_thermistor_factor;
// 20003B4F: using guessed type char input_1ms_peak_enabled;

//----- (0800C252) --------------------------------------------------------
void __fastcall cal_save_va_factors(char cal_gain)
{
  float v1; // r0@4
  int v2; // r0@4
  float v3; // r0@4
  int v4; // r0@4

  if ( cal_gain )
  {
    if ( cal_gain == 1 )
    {
      curr_cal_factor_eeloc = (int)(get_cal_factor_addr() + 1);
      v1 = fp_mul(1000000.0, cal_curr_gain_va_volts);
      v2 = fp_to_int(v1);
      write_eeprom_4byte(curr_cal_factor_eeloc, v2);
      curr_cal_factor_eeloc += 8;
      v3 = fp_mul(1000000.0, cal_curr_gain_va_amps);
      v4 = fp_to_int(v3);
      write_eeprom_4byte(curr_cal_factor_eeloc, v4);
    }
  }
  else
  {
    curr_cal_factor_eeloc = (int)get_cal_factor_addr();
    write_eeprom_4byte(curr_cal_factor_eeloc, cal_curr_offset_va_volts);
    curr_cal_factor_eeloc += 8;
    write_eeprom_4byte(curr_cal_factor_eeloc, cal_curr_offset_va_amps);
  }
}
// 20003850: using guessed type int curr_cal_factor_eeloc;
// 20003904: using guessed type int cal_curr_offset_va_volts;
// 20003908: using guessed type int cal_curr_offset_va_amps;

//----- (0800C2DE) --------------------------------------------------------
void __fastcall cal_save_ac_factor(meter_meas_mode mode, char range, char which)
{
  char v3; // r6@1

  v3 = which;
  curr_cal_factor_eeloc = (int)get_ac_cal_data_addr(mode, range);
  if ( v3 == 1 || v3 == 100 )
  {
    cal_validate_ac_factor(0);
    write_eeprom_2byte(curr_cal_factor_eeloc, cal_ac_factor_decirange);
  }
  if ( v3 == 2 || v3 == 100 )
  {
    cal_validate_ac_factor(1u);
    write_eeprom_2byte(curr_cal_factor_eeloc + 2, cal_ac_factor_fullrange);
  }
  if ( v3 == 3 || v3 == 100 )
  {
    cal_validate_ac_factor(2u);
    write_eeprom_2byte(curr_cal_factor_eeloc + 4, cal_ac_factor_decirange_lf);
  }
  if ( v3 == 4 || v3 == 100 )
  {
    cal_validate_ac_factor(3u);
    write_eeprom_2byte(curr_cal_factor_eeloc + 6, cal_ac_factor_fullrange_lf);
  }
}
// 20003850: using guessed type int curr_cal_factor_eeloc;

//----- (0800C37E) --------------------------------------------------------
void cal_erase_ac_factors(void)
{
  cal_save_ac_factor_fullrange_lf = 0;
  cal_save_ac_factor_decirange_lf = 0;
  cal_save_ac_factor_fullrange = 0;
  cal_save_ac_factor_decirange = 0;
  cal_ac_factor_fullrange_lf = 0;
  cal_ac_factor_decirange_lf = 0;
  cal_ac_factor_fullrange = 0;
  cal_ac_factor_decirange = 0;
  cal_save_ac_factor(curr_meas_mode, curr_meas_range, 100);
}
// 20003B36: using guessed type char cal_save_ac_factor_decirange;
// 20003B37: using guessed type char cal_save_ac_factor_fullrange;
// 20003B38: using guessed type char cal_save_ac_factor_decirange_lf;
// 20003B39: using guessed type char cal_save_ac_factor_fullrange_lf;

//----- (0800C3BC) --------------------------------------------------------
unsigned int __fastcall read_eeprom_4byte(int loc)
{
  int idx; // r5@1
  unsigned __int8 result[4]; // [sp+0h] [bp-18h]@3

  LOBYTE(idx) = 0;
  while ( (signed int)(unsigned __int8)idx < 4 )
  {
    idx = (unsigned __int8)idx;
    result[idx] = read_eeprom_byte_core((unsigned __int8)idx + loc);
    LOBYTE(idx) = idx + 1;
  }
  return result[3] + (result[0] << 24) + (result[1] << 16) + (result[2] << 8);
}

//----- (0800C410) --------------------------------------------------------
int __fastcall read_eeprom_2byte_signed(int loc)
{
  unsigned __int16 v1; // r6@1
  int v2; // r5@2

  v1 = read_eeprom_2byte(loc);
  if ( (signed int)v1 < 0x8000 )
    v2 = v1;
  else
    v2 = v1 - 0x10000;
  return v2;
}

//----- (0800C43C) --------------------------------------------------------
unsigned __int16 __fastcall read_eeprom_2byte(int loc)
{
  int idx; // r5@1
  unsigned __int8 result[2]; // [sp+0h] [bp-18h]@3

  LOBYTE(idx) = 0;
  while ( (signed int)(unsigned __int8)idx < 2 )
  {
    idx = (unsigned __int8)idx;
    result[idx] = read_eeprom_byte_core((unsigned __int8)idx + loc);
    LOBYTE(idx) = idx + 1;
  }
  return result[1] + (result[0] << 8);
}

//----- (0800C476) --------------------------------------------------------
unsigned __int8 __fastcall read_eeprom_byte(int loc)
{
  return read_eeprom_byte_core(loc);
}

//----- (0800C488) --------------------------------------------------------
unsigned __int8 __fastcall read_eeprom_byte_core(int loc)
{
  return *(_DWORD *)(loc + 0x8080000);
}

//----- (0800C4A0) --------------------------------------------------------
void __fastcall write_eeprom_4byte(int loc, signed int val)
{
  int v2; // r4@1
  signed int v3; // r5@1

  v2 = loc;
  v3 = val;
  try_to_write_byte_10_times(loc, BYTE3(val));
  try_to_write_byte_10_times(v2 + 1, v3 >> 16);
  try_to_write_byte_10_times(v2 + 2, BYTE1(v3));
  try_to_write_byte_10_times(v2 + 3, v3);
}

//----- (0800C4E0) --------------------------------------------------------
void __fastcall write_eeprom_2byte(int loc, __int16 val)
{
  int v2; // r4@1
  unsigned __int8 v3; // r5@1

  v2 = loc;
  v3 = val;
  try_to_write_byte_10_times(loc, HIBYTE(val));
  try_to_write_byte_10_times(v2 + 1, v3);
}

//----- (0800C506) --------------------------------------------------------
void __fastcall try_to_write_byte_10_times_also(int loc, int data)
{
  try_to_write_byte_10_times(loc, data);
}

//----- (0800C528) --------------------------------------------------------
int __fastcall write_eeprom_byte_without_first_erasing(int loc, unsigned __int8 data)
{
  unsigned __int8 v2; // r5@1
  int v3; // r4@1
  unsigned __int8 v4; // r6@1

  v2 = data;
  v3 = loc + 0x8080000;
  unlock_data_eeprom();
  v4 = try_write_byte_to_eeprom_without_first_erasing(v3, v2);
  lock_data_eeprom();
  return v4;
}

//----- (0800C5E4) --------------------------------------------------------
void __fastcall try_to_write_byte_10_times(int loc, unsigned __int8 data)
{
  int v2; // r4@1
  unsigned __int8 v3; // r5@1
  signed int i; // r8@1

  v2 = loc;
  v3 = data;
  for ( i = 0; i < 10 && (unsigned __int8)write_eeprom_byte_without_first_erasing(v2, v3) != 4; ++i )
    ;
}

//----- (0800C618) --------------------------------------------------------
void __fastcall bt_echo_rx_msg()
{
  unsigned __int8 i; // r4@1

  for ( i = 0; i < (unsigned int)(unsigned __int8)bt_rx_msg_len; ++i )
    usart_write_byte(&USART2_1, bt_rx_msg[i]);
}
// 20003AD6: using guessed type char bt_rx_msg_len;

//----- (0800C640) --------------------------------------------------------
void __fastcall bt_process_received_msg()
{
  unsigned int i; // r10@1
  int v1; // r0@5
  unsigned __int8 v2; // r4@5
  int v3; // r11@5
  int v4; // r0@5
  unsigned __int8 v5; // r5@5
  int v6; // r11@5
  int v7; // r0@5
  unsigned __int8 v8; // r6@5
  int v9; // r11@5
  int v10; // r0@5
  unsigned __int8 v11; // r7@5
  int v12; // r11@5
  int v13; // r0@5
  unsigned __int8 v14; // r8@5
  int v15; // r11@5
  int v16; // r0@5
  int v17; // r0@10
  unsigned __int8 v18; // [sp+0h] [bp-28h]@5
  unsigned __int8 v19; // [sp+1h] [bp-27h]@10

  bt_new_received_msg = 0;
  for ( i = 0; i < (unsigned __int8)bt_rx_msg_len; ++i )
    bt_rx_msg[i] = bt_rx_buf[i];
  if ( (unsigned __int8)bt_rx_msg[0] == 0xF8 )  // remote time set
  {
    v18 = read_hex_digit_from_bt_rx_msg(1u);
    LOBYTE(v1) = read_hex_digit_from_bt_rx_msg(3u);
    v2 = v1;
    v3 = v1 ^ v18;
    LOBYTE(v4) = read_hex_digit_from_bt_rx_msg(5u);
    v5 = v4;
    v6 = v4 ^ v3;
    LOBYTE(v7) = read_hex_digit_from_bt_rx_msg(7u);
    v8 = v7;
    v9 = v7 ^ v6;
    LOBYTE(v10) = read_hex_digit_from_bt_rx_msg(9u);
    v11 = v10;
    v12 = v10 ^ v9;
    LOBYTE(v13) = read_hex_digit_from_bt_rx_msg(0xBu);
    v14 = v13;
    v15 = v13 ^ v12;
    LOBYTE(v16) = read_hex_digit_from_bt_rx_msg(0xDu);
    if ( v15 == v16 )
    {
      bt_echo_rx_msg();
      if ( !bt_set_the_time )
      {
        curr_year = v18;
        curr_month = v2;
        curr_day = v5;
        curr_hour = v8;
        curr_minute = v11;
        curr_second = v14;
        rtc_write_time();
        bt_set_the_time = 1;
      }
    }
    else
    {
      bt_rx_checksum_valid = 0;
    }
  }
  else if ( (unsigned __int8)bt_rx_msg[0] == 0xF4 )// press a button
  {
    v19 = read_hex_digit_from_bt_rx_msg(1u);
    LOBYTE(v17) = read_hex_digit_from_bt_rx_msg(3u);
    if ( v19 == v17 )
    {
      bt_echo_rx_msg();
      bt_new_rxed_button = 1;
      bt_pressed_keycode = v19;
    }
  }
}
// 20003AD6: using guessed type char bt_rx_msg_len;
// 20003AD7: using guessed type char bt_new_received_msg;
// 20003AD9: using guessed type char bt_set_the_time;
// 20003ADA: using guessed type char bt_rx_checksum_valid;
// 20003B05: using guessed type char bt_new_rxed_button;

//----- (0800C77E) --------------------------------------------------------
unsigned __int8 __fastcall read_hex_digit_from_bt_rx_msg(unsigned __int8 pos)
{
  unsigned __int8 v1; // r1@1
  int v2; // r0@1

  v1 = pos;
  LOBYTE(v2) = 0;
  if ( (signed int)(unsigned __int8)bt_rx_msg[v1] < 48 || (signed int)(unsigned __int8)bt_rx_msg[v1] >= 58 )
  {
    if ( (signed int)(unsigned __int8)bt_rx_msg[v1] >= 65 && (signed int)(unsigned __int8)bt_rx_msg[v1] < 71 )
      v2 = 16 * ((unsigned __int8)bt_rx_msg[v1] - 55);
  }
  else
  {
    LOBYTE(v2) = 16 * bt_rx_msg[v1];
  }
  if ( (signed int)(unsigned __int8)bt_rx_msg[v1 + 1] < 48 || (signed int)(unsigned __int8)bt_rx_msg[v1 + 1] >= 58 )
  {
    if ( (signed int)(unsigned __int8)bt_rx_msg[v1 + 1] >= 65 && (signed int)(unsigned __int8)bt_rx_msg[v1 + 1] < 71 )
      LOBYTE(v2) = bt_rx_msg[v1 + 1] - 55 + v2;
  }
  else
  {
    LOBYTE(v2) = bt_rx_msg[v1 + 1] - 48 + v2;
  }
  return v2;
}

//----- (0800C828) --------------------------------------------------------
void update_bt_power()
{
  if ( bt_enabled )
    bt_powerup();
  else
    bt_shutdown();
  scr_update_bt_icon(1);
}
// 20003AD3: using guessed type char bt_enabled;

//----- (0800C848) --------------------------------------------------------
void write_time_and_serial_to_bt_buf(void)
{
  conv_uint_to_bcd_tmp((unsigned __int16)last_cal_year_month);
  bt_buf[1] = LOBYTE(disp_bcd_tmp[1]) + 48;
  bt_buf[2] = LOBYTE(disp_bcd_tmp[2]) + 48;
  bt_buf[3] = LOBYTE(disp_bcd_tmp[3]) + 48;
  bt_buf[4] = LOBYTE(disp_bcd_tmp[4]) + 48;
  conv_uint_to_bcd_tmp(curr_meter_serial);
  bt_buf[5] = LOBYTE(disp_bcd_tmp[0]) + 48;
  bt_buf[6] = LOBYTE(disp_bcd_tmp[1]) + 48;
  bt_buf[7] = LOBYTE(disp_bcd_tmp[2]) + 48;
  bt_buf[8] = LOBYTE(disp_bcd_tmp[3]) + 48;
  bt_buf[9] = LOBYTE(disp_bcd_tmp[4]) + 48;
}
// 2000380C: using guessed type int curr_meter_serial;
// 20003890: using guessed type int disp_bcd_tmp[5];

//----- (0800C8DE) --------------------------------------------------------
void build_and_write_bt_packet_also(void)
{
  build_and_write_bt_packet();
}

//----- (0800C8E6) --------------------------------------------------------
void build_and_write_bt_packet()
{
  char v0; // r5@1
  int v1; // r6@9
  unsigned __int8 v2; // r5@32
  unsigned __int8 v3; // r5@42
  int v4; // r0@60
  unsigned __int8 v5; // r5@67
  unsigned __int8 v6; // r5@82
  char v7; // r5@105
  unsigned __int8 i; // r4@111

  bt_buf[0] = '';
  write_time_and_serial_to_bt_buf();
  bt_buf_cksum = curr_meas_mode;
  write_hex_byte_to_bt_buf(10u, curr_meas_mode);
  v0 = curr_meas_range;
  if ( curr_meas_mode == MM_DIODE && high_voltage_diode )
    v0 = 1;
  if ( scr_overload_displayed )
    v0 += 0x80u;
  if ( curr_scr_digits < 0 )
    v0 += 0x40;
  bt_buf_cksum ^= v0;
  write_hex_byte_to_bt_buf(12u, v0);
  if ( curr_scr_digits >= 0 )
    LOWORD(v1) = curr_scr_digits;
  else
    v1 = -curr_scr_digits;
  bt_buf_cksum ^= BYTE1(v1);
  write_hex_byte_to_bt_buf(0xEu, BYTE1(v1));
  bt_buf_cksum ^= v1;
  write_hex_byte_to_bt_buf(0x10u, v1);
  if ( curr_sub_mode )
  {
    switch ( curr_sub_mode )
    {
      case 1:
        bt_write_battery_sub(0x12u);
        break;
      case 2:
        bt_write_apo_sub(0x12u);
        break;
      case 3:
        bt_write_lcd_sub(0x12u);
        break;
      case 4:
        bt_write_year_sub(0x12u);
        break;
      case 5:
        bt_write_month_day_sub(0x12u);
        break;
      case 6:
        bt_write_hour_minute_sub(0x12u);
        break;
      case 9:
        bt_write_spl1_sub(0x12u);
        break;
      case 10:
        bt_write_spl2_sub(0x12u);
        break;
      case 11:
        bt_write_spl3_sub(18);
        break;
      default:
        bt_write_no_sub(0x12u);
        break;
    }
  }
  else
  {
    bt_write_temp_sub(0x12u);
  }
  // bargraph data and value
  v2 = bargraph_range;
  if ( (signed int)(unsigned __int8)curr_meas_mode >= 6 && curr_meas_mode < (signed int)MM_OHMS
    || curr_meas_mode == MM_CAP
    || curr_meas_mode == MM_TEMP )
    v2 = bargraph_range + 16;                   // bar is on
  if ( curr_bargraph_digits < 0 )
    v2 += 4;
  if ( bargraph_range == 3 )
    v2 += 8;
  bt_buf_cksum ^= v2;
  write_hex_byte_to_bt_buf(26u, v2);
  bt_buf_cksum ^= curr_bargraph_bars;
  write_hex_byte_to_bt_buf(28u, curr_bargraph_bars);
  if ( input_lpf_enabled )
    v3 = 64;
  else
    v3 = 0;
  if ( input_1ms_peak_enabled )
    v3 += 32;
  if ( meter_mode_acv_dcv )
  {
    v3 += 24;                                   // AC/DC mode
  }
  else if ( curr_meas_mode != MM_ACuA
         && curr_meas_mode != MM_ACmA
         && curr_meas_mode != MM_ACA
         && curr_meas_mode != MM_ACV
         && curr_meas_mode != MM_ACmV )
  {
    if ( curr_meas_mode == MM_DCuA
      || curr_meas_mode == MM_DCmA
      || curr_meas_mode == MM_DCA
      || curr_meas_mode == MM_DCV
      || curr_meas_mode == MM_DCmV )
      v3 += 8;                                  // DC mode
  }
  else
  {
    v3 += 16;                                   // AC mode
  }
  LOBYTE(v4) = determine_if_autoranging();
  if ( v4 )
    v3 += 4;
  if ( !curr_apo_off )
    v3 += 2;
  if ( batt_is_low_icon )
    ++v3;
  bt_buf_cksum ^= v3;
  write_hex_byte_to_bt_buf(30u, v3);
  if ( bt_enabled )
    v5 = 64;
  else
    v5 = 0;
  if ( meter_danger_icon )
    v5 += 32;
  if ( rel_meas_enabled )
    v5 += 16;
  if ( curr_meas_mode == MM_ACV && curr_sub_mode == SM_SPL2 )
    v5 += 8;
  if ( input_1ms_peak_enabled )
  {
    if ( peakdet_show_min_always_zero )
      v5 += 2;
    else
      ++v5;
  }
  else if ( meter_min_max_mode )
  {
    v5 += meter_min_max_mode;
  }
  bt_buf_cksum ^= v5;
  write_hex_byte_to_bt_buf(0x20u, v5);
  v6 = 4 * hold_get_status();
  if ( (unsigned __int8)(logging_active & maybe_logging_was_active_at_some_point) | log_playback_mode )
    v6 += 16;
  bt_buf_cksum ^= v6;
  write_hex_byte_to_bt_buf(0x22u, v6);
  if ( curr_meas_mode != 16
    && curr_meas_mode != 18
    && curr_meas_mode != 20
    && (curr_meas_mode != 2 || meter_mode_acv_dcv)
    && curr_meas_mode != 4 )
  {
    if ( curr_meas_mode != 13
      && curr_meas_mode != 14
      && curr_meas_mode != 15
      && curr_meas_mode != 22
      && curr_meas_mode != 23
      && curr_meas_mode != 24 )
      bt_write_no_sub(0x24u);
    else
      bt_write_power_volts(0x24u, 1u);
  }
  else
  {
    bt_write_hz_sub(0x24u, curr_subscr_decimal_loc, (unsigned __int8)ac_input_hz_overflow, ac_input_freq);
  }
  if ( curr_meas_mode != 13
    && curr_meas_mode != 14
    && curr_meas_mode != 15
    && curr_meas_mode != 22
    && curr_meas_mode != 23
    && curr_meas_mode != 24 )
  {
    bt_write_no_sub(0x2Cu);
  }
  else
  {
    v7 = curr_meas_range;
    if ( curr_meas_range == 1 && (curr_meas_mode == 24 || curr_meas_mode == 15) )
      v7 = 2;
    bt_write_power_amps(0x2Cu, v7);
  }
  write_hex_byte_to_bt_buf(0x34u, bt_buf_cksum);
  bt_buf[54] = 13;
  bt_buf[55] = 10;
  for ( i = 0; (signed int)i < 56; ++i )
    usart_write_byte(&USART2_1, bt_buf[i]);
}
// 20003858: using guessed type int curr_scr_digits;
// 2000385C: using guessed type int curr_bargraph_digits;
// 20003870: using guessed type int ac_input_freq;
// 20003A9C: using guessed type char came_from_standby;
// 20003A9F: using guessed type char maybe_logging_was_active_at_some_point;
// 20003AD3: using guessed type char bt_enabled;
// 20003AD8: using guessed type char bt_buf_cksum;
// 20003ADF: using guessed type char batt_is_low_icon;
// 20003AE9: using guessed type char ac_input_hz_overflow;
// 20003AEA: using guessed type char scr_overload_displayed;
// 20003AED: using guessed type char bargraph_range;
// 20003AF5: using guessed type char rel_meas_enabled;
// 20003B49: using guessed type char meter_danger_icon;
// 20003B4B: using guessed type char high_voltage_diode;
// 20003B4F: using guessed type char input_1ms_peak_enabled;
// 20003B50: using guessed type char peakdet_show_min_always_zero;
// 20003B51: using guessed type char input_lpf_enabled;
// 20003B52: using guessed type char meter_mode_acv_dcv;

//----- (0800CDA8) --------------------------------------------------------
void __fastcall bt_write_temp_sub(unsigned __int8 loc)
{
  unsigned __int8 v1; // r4@1
  unsigned __int8 v2; // r5@2
  __int16 v3; // r6@4
  unsigned __int8 v4; // r5@4

  v1 = loc;
  if ( temp_in_c )
    v2 = MM_SUB_TEMPC;
  else
    v2 = MM_SUB_TEMPF;
  bt_buf_cksum ^= v2;
  write_hex_byte_to_bt_buf(loc, v2);
  v3 = convert_temp_and_round(curr_internal_temperature);
  v4 = 1;
  if ( there_was_a_temp_error )
    v4 = 0x81u;
  if ( v3 < 0 )
    v4 += 64;
  bt_buf_cksum ^= v4;
  write_hex_byte_to_bt_buf(v1 + 2, v4);
  write_hex_2bytes_to_bt_buf(v1 + 4, v3);
}
// 20003A7E: using guessed type __int16 curr_internal_temperature;
// 20003AD8: using guessed type char bt_buf_cksum;
// 20003B43: using guessed type char temp_in_c;
// 20003B46: using guessed type char there_was_a_temp_error;

//----- (0800CE28) --------------------------------------------------------
void __fastcall bt_write_battery_sub(unsigned __int8 loc)
{
  unsigned __int8 v1; // r4@1

  v1 = loc;
  bt_buf_cksum ^= MM_SUB_BATT;
  write_hex_byte_to_bt_buf(loc, MM_SUB_BATT);
  bt_buf_cksum ^= 1u;
  write_hex_byte_to_bt_buf(v1 + 2, 1u);
  write_hex_2bytes_to_bt_buf(v1 + 4, (unsigned __int16)curr_batt_charge);
}
// 20003A6E: using guessed type __int16 curr_batt_charge;
// 20003AD8: using guessed type char bt_buf_cksum;

//----- (0800CE78) --------------------------------------------------------
void __fastcall bt_write_apo_sub(unsigned __int8 loc)
{
  unsigned __int8 v1; // r4@1
  unsigned __int8 v2; // r5@2

  v1 = loc;
  if ( curr_apo_off )
    v2 = MM_SUB_APO_OFF;
  else
    v2 = MM_SUB_APO_ON;
  bt_buf_cksum ^= v2;
  write_hex_byte_to_bt_buf(loc, v2);
  bt_buf_cksum ^= 2u;
  write_hex_byte_to_bt_buf(v1 + 2, 2u);
  write_hex_2bytes_to_bt_buf(v1 + 4, 0);
}
// 20003AD8: using guessed type char bt_buf_cksum;

//----- (0800CED4) --------------------------------------------------------
void __fastcall bt_write_lcd_sub(unsigned __int8 loc)
{
  unsigned __int8 v1; // r4@1

  v1 = loc;
  bt_buf_cksum ^= MM_SUB_CONTRAST;
  write_hex_byte_to_bt_buf(loc, MM_SUB_CONTRAST);
  write_hex_byte_to_bt_buf(v1 + 2, 0);
  write_hex_2bytes_to_bt_buf(v1 + 4, (unsigned __int8)curr_lcd_contrast - 10);
}
// 20000222: using guessed type char curr_lcd_contrast;
// 20003AD8: using guessed type char bt_buf_cksum;

//----- (0800CF28) --------------------------------------------------------
void __fastcall bt_write_year_sub(unsigned __int8 loc)
{
  unsigned __int8 v1; // r4@1

  v1 = loc;
  bt_buf_cksum ^= MM_SUB_YEAR;
  write_hex_byte_to_bt_buf(loc, MM_SUB_YEAR);
  write_hex_byte_to_bt_buf(v1 + 2, 0);
  write_hex_2bytes_to_bt_buf(v1 + 4, curr_year);
}
// 20003AD8: using guessed type char bt_buf_cksum;

//----- (0800CF76) --------------------------------------------------------
void __fastcall bt_write_month_day_sub(unsigned __int8 loc)
{
  unsigned __int8 v1; // r4@1

  v1 = loc;
  bt_buf_cksum ^= MM_SUB_DATE;
  write_hex_byte_to_bt_buf(loc, MM_SUB_DATE);
  write_hex_byte_to_bt_buf(v1 + 2, 0);
  bt_buf_cksum ^= curr_month;
  write_hex_byte_to_bt_buf(v1 + 4, curr_month);
  bt_buf_cksum ^= curr_day;
  write_hex_byte_to_bt_buf(v1 + 6, curr_day);
}
// 20003AD8: using guessed type char bt_buf_cksum;

//----- (0800CFF8) --------------------------------------------------------
void __fastcall bt_write_hour_minute_sub(unsigned __int8 loc)
{
  unsigned __int8 v1; // r4@1

  v1 = loc;
  bt_buf_cksum ^= MM_SUB_TIME;
  write_hex_byte_to_bt_buf(loc, MM_SUB_TIME);
  write_hex_byte_to_bt_buf(v1 + 2, 0);
  bt_buf_cksum ^= curr_hour;
  write_hex_byte_to_bt_buf(v1 + 4, curr_hour);
  bt_buf_cksum ^= curr_minute;
  write_hex_byte_to_bt_buf(v1 + 6, curr_minute);
}
// 20003AD8: using guessed type char bt_buf_cksum;

//----- (0800D084) --------------------------------------------------------
void __fastcall bt_write_spl1_sub(unsigned __int8 loc)
{
  unsigned __int8 v1; // r4@1

  v1 = loc;
  if ( curr_meas_mode != MM_ACmV && (curr_meas_mode != MM_ACV || meter_mode_acv_dcv) )
  {
    if ( curr_meas_mode == MM_CONTINUITY )
    {
      bt_buf_cksum ^= curr_continuity_threshold - 86;
      write_hex_byte_to_bt_buf(loc, curr_continuity_threshold - 86);
      write_hex_byte_to_bt_buf(v1 + 2, 0);
      write_hex_2bytes_to_bt_buf(v1 + 4, 0);
    }
    else if ( curr_meas_mode == MM_DIODE )
    {
      bt_buf_cksum ^= MM_DIODE;
      write_hex_byte_to_bt_buf(loc, MM_DIODE);
      write_hex_byte_to_bt_buf(v1 + 2, 0);
      if ( high_voltage_diode )
        write_hex_2bytes_to_bt_buf(v1 + 4, 15);
      else
        write_hex_2bytes_to_bt_buf(v1 + 4, 3);
    }
    else if ( curr_meas_mode != MM_ACuVA
           && curr_meas_mode != MM_ACmVA
           && curr_meas_mode != MM_ACVA
           && curr_meas_mode != MM_DCuVA
           && curr_meas_mode != MM_DCmVA
           && curr_meas_mode != MM_DCVA )
    {
      if ( curr_meas_mode != MM_ACuA
        && curr_meas_mode != MM_ACmA
        && curr_meas_mode != MM_ACA
        && curr_meas_mode != MM_DCuA
        && curr_meas_mode != MM_DCmA
        && curr_meas_mode != MM_DCA )
        bt_write_no_sub(loc);
      else
        sub_800D3DE(loc, burden_enabled_for_current_ranges);
    }
    else if ( subscr_showing_power_amps )
    {
      bt_write_power_amps(loc, curr_subscr_decimal_loc);
    }
    else
    {
      bt_write_power_volts(loc, curr_subscr_decimal_loc);
    }
  }
  else
  {
    bt_write_hz_sub(loc, curr_subscr_decimal_loc, (unsigned __int8)ac_input_hz_overflow, ac_input_freq / 10);
  }
}
// 20003870: using guessed type int ac_input_freq;
// 20003AD8: using guessed type char bt_buf_cksum;
// 20003AE9: using guessed type char ac_input_hz_overflow;
// 20003B3D: using guessed type char burden_enabled_for_current_ranges;
// 20003B4B: using guessed type char high_voltage_diode;
// 20003B4E: using guessed type char curr_continuity_threshold;
// 20003B52: using guessed type char meter_mode_acv_dcv;
// 20003B57: using guessed type char subscr_showing_power_amps;

//----- (0800D274) --------------------------------------------------------
void __fastcall bt_write_spl2_sub(unsigned __int8 loc)
{
  unsigned __int8 v1; // r4@1
  unsigned __int8 v2; // r5@2
  int v3; // r6@7

  v1 = loc;
  if ( curr_meas_mode == MM_ACV )
  {
    bt_buf_cksum ^= MM_SUB_dBm;
    write_hex_byte_to_bt_buf(loc, MM_SUB_dBm);
    v2 = curr_subscr_decimal_loc;
    if ( curr_scr_overflow )
      v2 = curr_subscr_decimal_loc + 0x80;
    if ( curr_subscr_digits < 0 )
      v2 += 64;
    bt_buf_cksum ^= v2;
    write_hex_byte_to_bt_buf(v1 + 2, v2);
    if ( curr_subscr_digits >= 0 )
      LOWORD(v3) = curr_subscr_digits;
    else
      v3 = -curr_subscr_digits;
    write_hex_2bytes_to_bt_buf(v1 + 4, (signed __int16)v3);
  }
  else if ( curr_meas_mode != MM_ACuA && curr_meas_mode != MM_ACmA && curr_meas_mode != MM_ACA
         || burden_enabled_for_current_ranges )
  {
    if ( (curr_meas_mode == MM_ACuA
       || curr_meas_mode == MM_ACmA
       || curr_meas_mode == MM_ACA
       || curr_meas_mode == MM_DCuA
       || curr_meas_mode == MM_DCmA
       || curr_meas_mode == MM_DCA)
      && burden_enabled_for_current_ranges )
    {
      bt_write_burden_sub();
    }
    else if ( curr_meas_mode != MM_ACuVA
           && curr_meas_mode != MM_ACmVA
           && curr_meas_mode != MM_ACVA
           && curr_meas_mode != MM_DCuVA
           && curr_meas_mode != MM_DCmVA
           && curr_meas_mode != MM_DCVA )
    {
      bt_write_no_sub(loc);
    }
    else
    {
      sub_800D3DE(loc, burden_enabled_for_power_ranges);
    }
  }
  else
  {
    bt_write_hz_sub(loc, curr_subscr_decimal_loc, (unsigned __int8)ac_input_hz_overflow, ac_input_freq / 10);
  }
}
// 20003870: using guessed type int ac_input_freq;
// 20003978: using guessed type int curr_subscr_digits;
// 20003AD8: using guessed type char bt_buf_cksum;
// 20003AE9: using guessed type char ac_input_hz_overflow;
// 20003B3D: using guessed type char burden_enabled_for_current_ranges;
// 20003B40: using guessed type char burden_enabled_for_power_ranges;

//----- (0800D3D4) --------------------------------------------------------
void __fastcall bt_write_spl3_sub(int loc)
{
  bt_write_burden_sub();
}

//----- (0800D3DE) --------------------------------------------------------
void __fastcall sub_800D3DE(unsigned __int8 a1, char a2)
{
  unsigned __int8 v2; // r4@1
  unsigned __int8 v3; // r6@2

  v2 = a1;
  if ( a2 )
    v3 = 155;
  else
    v3 = 156;
  bt_buf_cksum ^= v3;
  write_hex_byte_to_bt_buf(a1, v3);
  bt_buf_cksum ^= 3u;
  write_hex_byte_to_bt_buf(v2 + 2, 3u);
  write_hex_2bytes_to_bt_buf(v2 + 4, 0);
}
// 20003AD8: using guessed type char bt_buf_cksum;

//----- (0800D44C) --------------------------------------------------------
void __fastcall bt_write_hz_sub(unsigned __int8 a1, char a2, int a3, int a4)
{
  unsigned __int8 v4; // r4@1
  char v5; // r5@1
  char v6; // r6@1
  int v7; // r7@1
  char v8; // r8@1
  unsigned __int8 v9; // r8@5
  int v10; // r9@8

  v4 = a1;
  v5 = a2;
  v6 = a3;
  v7 = a4;
  bt_buf_cksum ^= MM_HZ;
  write_hex_byte_to_bt_buf(a1, MM_HZ);
  v8 = v5;
  if ( v6 )
    v8 = v5 + -128;
  if ( v7 < 0 )
    v8 += 64;
  v9 = v8 + 16;
  if ( (signed int)ac_input_freq_range >= 2 )
    v9 += 32;
  bt_buf_cksum ^= v9;
  write_hex_byte_to_bt_buf(v4 + 2, v9);
  if ( v7 >= 0 )
    v10 = v7;
  else
    v10 = -v7;
  write_hex_2bytes_to_bt_buf(v4 + 4, v10);
}
// 20003AD8: using guessed type char bt_buf_cksum;

//----- (0800D4DC) --------------------------------------------------------
void __fastcall bt_write_power_volts(unsigned __int8 a1, unsigned __int8 a2)
{
  unsigned __int8 v2; // r6@0
  unsigned __int8 v3; // r4@1
  unsigned __int8 v4; // r5@1
  unsigned __int8 v5; // r6@5
  int v6; // r7@10

  v3 = a1;
  v4 = a2;
  if ( (unsigned int)(unsigned __int8)curr_meas_mode - MM_ACuVA <= 2 )
  {
    v2 = 2;
  }
  else if ( (unsigned int)(unsigned __int8)curr_meas_mode - MM_DCuVA <= 2 )
  {
    v2 = 1;
  }
  bt_buf_cksum ^= v2;
  write_hex_byte_to_bt_buf(a1, v2);
  v5 = v4;
  if ( curr_power_volts_overflow )
    v5 = v4 + -128;
  if ( meter_power_volts < 0 )
    v5 += 64;
  bt_buf_cksum ^= v5;
  write_hex_byte_to_bt_buf(v3 + 2, v5);
  if ( meter_power_volts >= 0 )
    LOWORD(v6) = meter_power_volts;
  else
    v6 = -meter_power_volts;
  write_hex_2bytes_to_bt_buf(v3 + 4, (signed __int16)v6);
}
// 2000398C: using guessed type int meter_power_volts;
// 20003AD8: using guessed type char bt_buf_cksum;
// 20003B5D: using guessed type char curr_power_volts_overflow;

//----- (0800D588) --------------------------------------------------------
void __fastcall bt_write_power_amps(unsigned __int8 loc, unsigned __int8 a2)
{
  unsigned __int8 v2; // r6@0
  unsigned __int8 v3; // r4@1
  unsigned __int8 v4; // r5@1
  unsigned __int8 v5; // r6@14
  int v6; // r7@19

  v3 = loc;
  v4 = a2;
  switch ( curr_meas_mode )
  {
    case MM_ACuVA:
      v2 = MM_ACuA;
      break;
    case MM_ACmVA:
      v2 = MM_ACmA;
      break;
    case MM_ACVA:
      v2 = MM_ACA;
      break;
    case MM_DCuVA:
      v2 = MM_DCuA;
      break;
    case MM_DCmVA:
      v2 = MM_DCmA;
      break;
    case MM_DCVA:
      v2 = MM_DCA;
      break;
  }
  bt_buf_cksum ^= v2;
  write_hex_byte_to_bt_buf(loc, v2);
  v5 = v4;
  if ( curr_power_amps_overflow )
    v5 = v4 + -128;
  if ( meter_power_amps < 0 )
    v5 += 64;
  bt_buf_cksum ^= v5;
  write_hex_byte_to_bt_buf(v3 + 2, v5);
  if ( meter_power_amps >= 0 )
    LOWORD(v6) = meter_power_amps;
  else
    v6 = -meter_power_amps;
  write_hex_2bytes_to_bt_buf(v3 + 4, (signed __int16)v6);
}
// 20003990: using guessed type int meter_power_amps;
// 20003AD8: using guessed type char bt_buf_cksum;
// 20003B5E: using guessed type char curr_power_amps_overflow;

//----- (0800D654) --------------------------------------------------------
void __fastcall bt_write_burden_sub()
{
  unsigned __int8 v0; // r4@1
  int v1; // r5@2

  bt_buf_cksum ^= MM_SUB_BURDEN;
  write_hex_byte_to_bt_buf(0x12u, MM_SUB_BURDEN);
  v0 = 1;
  if ( curr_burden_voltage >= 0 )
  {
    LOWORD(v1) = curr_burden_voltage;
  }
  else
  {
    v0 = 65;
    v1 = -curr_burden_voltage;
  }
  bt_buf_cksum ^= v0;
  write_hex_byte_to_bt_buf(0x14u, v0);
  write_hex_2bytes_to_bt_buf(0x16u, (signed __int16)v1);
}
// 20003A7C: using guessed type __int16 curr_burden_voltage;
// 20003AD8: using guessed type char bt_buf_cksum;

//----- (0800D6C4) --------------------------------------------------------
void __fastcall bt_write_no_sub(unsigned __int8 loc)
{
  unsigned __int8 v1; // r4@1

  v1 = loc;
  write_hex_byte_to_bt_buf(loc, 0);
  write_hex_byte_to_bt_buf(v1 + 2, 0);
  write_hex_2bytes_to_bt_buf(v1 + 4, 0);
}
// 20003AD8: using guessed type char bt_buf_cksum;

//----- (0800D71C) --------------------------------------------------------
void __fastcall write_hex_2bytes_to_bt_buf(unsigned __int8 loc, int val)
{
  unsigned __int8 v2; // r4@1
  int v3; // r7@2

  v2 = loc;
  if ( val >= 0 )
    LOWORD(v3) = val;
  else
    v3 = -val;
  bt_buf_cksum ^= BYTE1(v3);
  write_hex_byte_to_bt_buf(loc, BYTE1(v3));
  bt_buf_cksum ^= v3;
  write_hex_byte_to_bt_buf(v2 + 2, v3);
}
// 20003AD8: using guessed type char bt_buf_cksum;

//----- (0800D794) --------------------------------------------------------
void __fastcall write_hex_byte_to_bt_buf(unsigned __int8 pos, unsigned __int8 num)
{
  unsigned __int8 v2; // r4@1
  unsigned __int8 v3; // r5@1

  v2 = pos;
  v3 = num;
  bt_buf[pos] = hex_digit_to_ascii(num >> 4);
  bt_buf[v2 + 1] = hex_digit_to_ascii(v3);
}

//----- (0800D7D8) --------------------------------------------------------
unsigned __int8 __fastcall hex_digit_to_ascii(char digit)
{
  int v1; // r2@1
  unsigned __int8 result; // r0@2

  v1 = digit & 0xF;
  if ( v1 >= 10 )
    result = v1 + '7';
  else
    result = v1 + '0';
  return result;
}

//----- (0800D7F6) --------------------------------------------------------
void __fastcall usart_write_byte(USART_REGS *USART, unsigned __int8 data)
{
  USART_REGS *v2; // r4@1
  unsigned __int8 v3; // r5@1

  v2 = USART;
  v3 = data;
  while ( !get_usart_status_bits(v2, 0x80u) )   // wait for tx buf to be empty
    ;
  usart_write_data_reg(v2, v3);
}

//----- (0800D816) --------------------------------------------------------
void end_setup_without_saving_after_2min_timeout(void)
{
  ++setup_edit_timeout_2min;
  if ( (signed int)(unsigned __int8)setup_edit_timeout_2min >= 241 )
  {
    setup_currently_editing = 0;
    switch ( curr_sub_mode )
    {
      case SM_METER_SERIAL:
        edit_meter_serial = curr_meter_serial;
        break;
      case SM_YEAR:
        edit_year = curr_year;
        break;
      case SM_MONTH_DAY:
        edit_month = curr_month;
        edit_day = curr_day;
        editing_rightside_time_val = 0;
        break;
      case SM_HOUR_MINUTE:
        edit_hour = curr_hour;
        edit_minute = curr_minute;
        editing_rightside_time_val = 0;
        break;
      case SM_APO:
        load_curr_apo_status();
        break;
      default:
        if ( curr_sub_mode )
        {
          if ( curr_meas_mode == MM_CONTINUITY && curr_sub_mode == MM_OHMS )
            load_curr_cont_threshold();
        }
        else
        {
          load_temp_mode();
        }
        break;
    }
    need_to_update_subscr = 1;
  }
}
// 2000380C: using guessed type int curr_meter_serial;
// 20003810: using guessed type int edit_meter_serial;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B0A: using guessed type char setup_currently_editing;
// 20003B0C: using guessed type char setup_edit_timeout_2min;
// 20003B68: using guessed type char editing_rightside_time_val;
// 20003B6F: using guessed type char edit_year;
// 20003B70: using guessed type char edit_month;
// 20003B71: using guessed type char edit_day;
// 20003B72: using guessed type char edit_hour;
// 20003B73: using guessed type char edit_minute;

//----- (0800D904) --------------------------------------------------------
void __fastcall meter_process_range_mode_changed(char should_stop_logging)
{
  some_unused_flag_always_zero = 0;
  meas_amp_burden_timer = 0;
  measuring_amps_of_va_or_volts_of_burden = 0;
  hy_AD1_new_avg = 0;
  hy_ad1_avg_ctr = 0;
  meas_va_last_volts = 0;
  meas_va_last_amps = 0;
  ac_input_freq_lowz = 0;
  ac_input_freq_range_lowz = 0;
  if ( meter_mode_changed )
  {
    curr_power_volts_range = 0;
    curr_power_amps_range = 0;
    subscr_showing_power_amps = 0;
    autoranging_disabled = curr_meas_mode == MM_DIODE;
    meter_set_default_subscr_mode();
    edit_burden_enabled_for_current_ranges = 0;
    burden_enabled_for_current_ranges = 0;
    setup_currently_editing = 0;
    if ( (curr_meas_mode != MM_ACV || meter_mode_acv_dcv) && curr_meas_mode != MM_ACmV )
    {
      if ( curr_meas_mode != MM_OHMS || meter_in_cal_mode )
        curr_meas_range = 0;
      else
        curr_meas_range = 6;
    }
    else if ( input_1ms_peak_enabled )
    {
      autoranging_disabled = 1;
    }
    else
    {
      curr_meas_range = 0;
    }
    auto_hold_is_enabled = 0;
    if ( should_stop_logging == 1 && logging_active )
    {
      logging_end(1);
      logging_active = 0;
    }
    log_playback_mode_stop();
  }
  hy_change_CTA_val_timer = 0;
  freq_input_timeout_timer_10ms_unit = 0;
  meter_danger_icon = 0;
  meter_overload = 0;
  if ( curr_meas_mode != MM_ACV && curr_meas_mode != MM_ACmV )
    input_lpf_enabled = 0;
  if ( curr_meas_mode != MM_ACV )
    meter_mode_acv_dcv = 0;
  rel_meas_enabled = 0;
  meter_min_max_mode = 0;
  if ( (curr_meas_mode != MM_ACV || meter_mode_acv_dcv) && curr_meas_mode != MM_ACmV )
    input_1ms_peak_enabled = 0;
  peakhold_max_value = 0;
  peakhold_min_value = 0;
  subscr_need_to_update_units = 1;
  scr_need_to_refresh_meas_units_and_icons = 1;
  need_to_update_subscr = 1;
  if ( !__PAIR__(auto_hold_is_enabled, manual_hold_is_enabled) )
    force_new_measurement_available_on_range_mode_change = 1;
  meter_set_mode_range_change_delay();
  scr_update_decimal_point();
  update_max_digits_in_range();
  meas_prepare_for_new_mode_range(1u);
  curr_scr_digits = 0;
  curr_bargraph_digits = 0;
  meas_setup_hw(curr_meas_mode, curr_meas_range);
  if ( meter_mode_changed )
  {
    reset_apo_timeout();
    beep_ms(0x12Cu);
  }
  meter_mode_changed = 0;
  meter_range_changed = 0;
}
// 20003858: using guessed type int curr_scr_digits;
// 2000385C: using guessed type int curr_bargraph_digits;
// 20003868: using guessed type int meas_va_last_volts;
// 2000386C: using guessed type int meas_va_last_amps;
// 20003944: using guessed type int ac_input_freq_lowz;
// 2000396C: using guessed type int peakhold_max_value;
// 20003970: using guessed type int peakhold_min_value;
// 20003A74: using guessed type __int16 freq_input_timeout_timer_10ms_unit;
// 20003AE6: using guessed type char autoranging_disabled;
// 20003AEC: using guessed type char meter_range_changed;
// 20003AF5: using guessed type char rel_meas_enabled;
// 20003AFC: using guessed type char scr_need_to_refresh_meas_units_and_icons;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003AFF: using guessed type char subscr_need_to_update_units;
// 20003B0A: using guessed type char setup_currently_editing;
// 20003B1B: using guessed type char hy_ad1_avg_ctr;
// 20003B1C: using guessed type char hy_AD1_new_avg;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B34: using guessed type char some_unused_flag_always_zero;
// 20003B3B: using guessed type char ac_input_freq_range_lowz;
// 20003B3D: using guessed type char burden_enabled_for_current_ranges;
// 20003B3E: using guessed type char edit_burden_enabled_for_current_ranges;
// 20003B49: using guessed type char meter_danger_icon;
// 20003B4A: using guessed type char meter_overload;
// 20003B4F: using guessed type char input_1ms_peak_enabled;
// 20003B51: using guessed type char input_lpf_enabled;
// 20003B52: using guessed type char meter_mode_acv_dcv;
// 20003B57: using guessed type char subscr_showing_power_amps;
// 20003B59: using guessed type char measuring_amps_of_va_or_volts_of_burden;
// 20003B5A: using guessed type char meas_amp_burden_timer;
// 20003B5B: using guessed type char curr_power_volts_range;
// 20003B5C: using guessed type char curr_power_amps_range;

//----- (0800DB44) --------------------------------------------------------
void __cdecl update_max_digits_in_range()
{
  if ( curr_meas_mode == MM_DIODE )
  {
    if ( high_voltage_diode )
      max_digits_in_range = max_digits_in_range_tbl[(unsigned __int8)curr_meas_mode][1];
    else
      max_digits_in_range = max_digits_in_range_tbl[(unsigned __int8)curr_meas_mode][0];
  }
  else
  {
    max_digits_in_range = max_digits_in_range_tbl[(unsigned __int8)curr_meas_mode][curr_meas_range];
  }
}
// 20003854: using guessed type int max_digits_in_range;
// 20003B4B: using guessed type char high_voltage_diode;

//----- (0800DBAC) --------------------------------------------------------
void __cdecl subscr_periodically_switch_between_amps_and_volts_for_power()
{
  if ( curr_meas_mode == MM_ACuVA
    || curr_meas_mode == MM_ACmVA
    || curr_meas_mode == MM_ACVA
    || curr_meas_mode == MM_DCuVA
    || curr_meas_mode == MM_DCmVA
    || curr_meas_mode == MM_DCVA )
  {
    ++subscr_power_v_a_switch_timer;
    if ( (signed int)subscr_power_v_a_switch_timer >= 300 )// switch every 3 seconds
    {
      subscr_showing_power_amps = subscr_showing_power_amps != 1;
      subscr_update_power_amps_or_volts_display();
    }
  }
}
// 20003B57: using guessed type char subscr_showing_power_amps;

//----- (0800DC1C) --------------------------------------------------------
void __cdecl subscr_update_power_amps_or_volts_display()
{
  if ( subscr_showing_power_amps )
    subscr_calc_power_amp_point();
  else
    curr_subscr_decimal_loc = 3;
  subscr_power_v_a_switch_timer = 0;
  subscr_need_to_update_units = 1;
  need_to_update_subscr = 1;
}
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003AFF: using guessed type char subscr_need_to_update_units;
// 20003B57: using guessed type char subscr_showing_power_amps;

//----- (0800DC58) --------------------------------------------------------
void meter_set_default_subscr_mode()
{
  if ( setting_last_cal_year_month )
  {
    curr_sub_mode = SM_YEAR;
  }
  else if ( curr_meas_mode != MM_ACV || meter_mode_acv_dcv )
  {
    if ( curr_meas_mode == MM_ACmV )
    {
      curr_sub_mode = SM_SPL1;
    }
    else if ( curr_meas_mode != MM_ACuVA
           && curr_meas_mode != MM_ACmVA
           && curr_meas_mode != MM_ACVA
           && curr_meas_mode != MM_DCuVA
           && curr_meas_mode != MM_DCmVA
           && curr_meas_mode != MM_DCVA )
    {
      if ( curr_meas_mode != MM_ACuA
        && curr_meas_mode != MM_ACmA
        && curr_meas_mode != MM_ACA
        && curr_meas_mode != MM_DCuA
        && curr_meas_mode != MM_DCmA
        && curr_meas_mode != MM_DCA )
      {
        curr_sub_mode = 0;
      }
      else
      {
        curr_sub_mode = 9;
        burden_active_msg_showing_timer_1s = 100;
      }
    }
    else
    {
      curr_sub_mode = 9;
    }
  }
  else
  {
    curr_sub_mode = 9;
  }
}
// 20003B25: using guessed type char setting_last_cal_year_month;
// 20003B42: using guessed type char burden_active_msg_showing_timer_1s;
// 20003B52: using guessed type char meter_mode_acv_dcv;

//----- (0800DD3C) --------------------------------------------------------
void __fastcall meas_prepare_for_new_mode_range(unsigned __int8 should_load_cal_factors)
{
  meas_config_hy_and_load_cal_factors(should_load_cal_factors);
  meas_cap_reset_no_reading_timeout_timer();
}

//----- (0800DD4E) --------------------------------------------------------
void __fastcall meas_config_hy_and_load_cal_factors(char should_load_factors)
{
  char v1; // r4@1

  v1 = should_load_factors;
  config_hy_based_on_mode_range(curr_meas_mode, curr_meas_range);
  if ( v1 == 1 )
  {
    cal_load_factors_for_mode_and_range(curr_meas_mode, curr_meas_range);
    cal_load_amp_rel(curr_meas_mode, curr_meas_range);
  }
  if ( v1 == 1 && curr_meas_mode != MM_HZ )
    cal_load_factors_for_mode_and_range(MM_HZ, 0);
  if ( v1 == 1
    && (curr_meas_mode == MM_ACuA
     || curr_meas_mode == MM_ACmA
     || curr_meas_mode == MM_ACA
     || curr_meas_mode == MM_ACV
     || curr_meas_mode == MM_ACmV) )
    cal_load_ac_factors();
  if ( v1 == 1 && curr_meas_mode == MM_LOW_Z )
    cal_load_ac_factors();
}

//----- (0800DDF8) --------------------------------------------------------
void __fastcall update_stuff_based_on_new_power_range()
{
  meas_va_never_processed = 1;
  meas_amp_burden_timer = 0;
  measuring_amps_of_va_or_volts_of_burden = 0;
  meas_prepare_for_new_mode_range(1u);
  meas_hw_set_amp_x10(curr_meas_mode, curr_meas_range);
  meter_set_mode_range_change_delay();
  scr_update_milli_for_VA(curr_meas_mode, curr_meas_range);
  scr_update_decimal_point();
}
// 20003B58: using guessed type char meas_va_never_processed;
// 20003B59: using guessed type char measuring_amps_of_va_or_volts_of_burden;
// 20003B5A: using guessed type char meas_amp_burden_timer;

//----- (0800DE54) --------------------------------------------------------
signed int __fastcall calc_decimal_place_for_mode_range(meter_meas_mode mode, unsigned int range)
{
  char v2; // r3@1

  v2 = 0;
  if ( mode == MM_BURDEN )
    return 1;
  if ( mode == MM_LOW_Z )
    goto LABEL_117;
  if ( mode == MM_ACV || mode < (unsigned int)MM_ACV )
    goto LABEL_73;
  if ( mode == MM_ACmV || mode < (unsigned int)MM_ACmV || mode == MM_HZ )
    goto LABEL_85;
  if ( mode >= (unsigned int)MM_HZ && mode != MM_DUTY )
  {
    if ( mode < (unsigned int)MM_DUTY )
      goto LABEL_73;
    if ( mode != MM_CONTINUITY )
    {
      if ( mode >= (unsigned int)MM_CONTINUITY )
      {
        if ( mode == MM_CAP )
        {
          range = (unsigned __int8)range;
          if ( (_BYTE)range )
          {
            if ( range == 2 )
            {
              v2 = 3;
            }
            else if ( range >= 2 )
            {
              if ( range == 4 )
              {
                v2 = 1;
              }
              else if ( range >= 4 )
              {
                if ( range == 5 )
                  v2 = 0;
              }
              else
              {
                v2 = 2;
              }
            }
            else
            {
              v2 = 1;
            }
          }
          else
          {
            v2 = 2;
          }
          return (unsigned __int8)v2;
        }
        if ( mode < (unsigned int)MM_CAP )
        {
          if ( high_voltage_diode )
            v2 = 3;
          else
            v2 = 4;
          return (unsigned __int8)v2;
        }
        if ( mode == MM_ACmVA )
          goto LABEL_39;
        if ( mode < (unsigned int)MM_ACmVA )
          goto LABEL_49;
        if ( mode != MM_ACuA )
        {
          if ( mode < (unsigned int)MM_ACuA )
            goto LABEL_29;
          if ( mode == MM_ACmA )
            goto LABEL_73;
          if ( mode >= (unsigned int)MM_ACmA )
          {
            if ( mode == MM_ACA )
              goto LABEL_65;
            if ( mode >= (unsigned int)MM_ACA )
            {
              if ( mode != MM_DCuVA )
              {
                if ( mode >= (unsigned int)MM_DCuVA )
                {
                  if ( mode != MM_DCVA )
                  {
                    if ( mode >= (unsigned int)MM_DCVA )
                      return (unsigned __int8)v2;
LABEL_39:
                    range = (unsigned __int8)range;
                    if ( (_BYTE)range )
                    {
                      if ( range == 2 )
                      {
                        v2 = 2;
                      }
                      else if ( range >= 2 )
                      {
                        if ( range == 3 )
                          v2 = 1;
                      }
                      else
                      {
                        v2 = 2;
                      }
                    }
                    else
                    {
                      v2 = 3;
                    }
                    return (unsigned __int8)v2;
                  }
LABEL_29:
                  range = (unsigned __int8)range;
                  if ( (_BYTE)range )
                  {
                    if ( range == 2 )
                    {
                      v2 = 3;
                    }
                    else if ( range >= 2 )
                    {
                      if ( range == 3 )
                        v2 = 2;
                    }
                    else
                    {
                      v2 = 0;
                    }
                  }
                  else
                  {
                    v2 = 1;
                  }
                  return (unsigned __int8)v2;
                }
LABEL_65:
                range = (unsigned __int8)range;
                if ( (_BYTE)range )
                {
                  if ( range == 2 )
                  {
                    v2 = 3;
                  }
                  else if ( range < 2 )
                  {
                    v2 = 4;
                  }
                }
                else
                {
                  v2 = 2;
                }
                return (unsigned __int8)v2;
              }
LABEL_49:
              range = (unsigned __int8)range;
              if ( (_BYTE)range )
              {
                if ( range == 2 )
                {
                  v2 = 1;
                }
                else if ( range >= 2 )
                {
                  if ( range == 3 )
                    v2 = 0;
                }
                else
                {
                  v2 = 1;
                }
              }
              else
              {
                v2 = 2;
              }
              return (unsigned __int8)v2;
            }
LABEL_73:
            range = (unsigned __int8)range;
            if ( (_BYTE)range )
            {
              if ( range == 2 )
              {
                v2 = 2;
              }
              else if ( range >= 2 )
              {
                if ( range == 4 )
                {
                  v2 = 2;
                }
                else if ( range < 4 )
                {
                  v2 = 1;
                }
              }
              else
              {
                v2 = 3;
              }
            }
            else
            {
              v2 = 4;
            }
            return (unsigned __int8)v2;
          }
        }
      }
LABEL_85:
      range = (unsigned __int8)range;
      if ( (_BYTE)range )
      {
        if ( range == 2 )
        {
          v2 = 4;
        }
        else if ( range >= 2 )
        {
          if ( range == 4 )
          {
            v2 = 2;
          }
          else if ( range >= 4 )
          {
            if ( range == 6 )
            {
              v2 = 3;
            }
            else if ( range < 6 )
            {
              v2 = 4;
            }
          }
          else
          {
            v2 = 3;
          }
        }
        else
        {
          v2 = 2;
        }
      }
      else
      {
        v2 = 3;
      }
      return (unsigned __int8)v2;
    }
    v2 = 2;
  }
  else
  {
LABEL_117:
    v2 = 1;
  }
  return (unsigned __int8)v2;
}
// 20003B4B: using guessed type char high_voltage_diode;

//----- (0800E044) --------------------------------------------------------
void __fastcall meter_set_mode_range_change_delay()
{
  if ( (curr_meas_mode == MM_ACuA
     || curr_meas_mode == MM_ACmA
     || curr_meas_mode == MM_ACA
     || curr_meas_mode == MM_DCuA
     || curr_meas_mode == MM_DCmA
     || curr_meas_mode == MM_DCA)
    && burden_enabled_for_current_ranges )
  {
    meter_mode_range_change_delay = 0;
  }
  else if ( curr_meas_mode == MM_ACV )
  {
    meter_mode_range_change_delay = 3;
  }
  else if ( curr_meas_mode == MM_ACmV )
  {
    meter_mode_range_change_delay = 4;
  }
  else if ( curr_meas_mode != MM_HZ && curr_meas_mode != MM_mSEC && curr_meas_mode != MM_DUTY )
  {
    switch ( curr_meas_mode )
    {
      case MM_OHMS:
        if ( (signed int)curr_meas_range < 5 )
          meter_mode_range_change_delay = 1;
        else
          meter_mode_range_change_delay = 2;
        break;
      case MM_CONTINUITY:
        meter_mode_range_change_delay = 0;
        break;
      case MM_DCV:
        meter_mode_range_change_delay = 2;
        break;
      case MM_DCmV:
        meter_mode_range_change_delay = 1;
        break;
      default:
        if ( curr_meas_mode || lowz_measuring_ac )
        {
          if ( curr_meas_mode != MM_CAP || (signed int)curr_meas_range >= 2 )
          {
            if ( curr_meas_mode != MM_CAP || (signed int)curr_meas_range < 2 || (signed int)curr_meas_range >= 5 )
            {
              if ( curr_meas_mode != MM_CAP || curr_meas_range != 5 )
                meter_mode_range_change_delay = 3;
              else
                meter_mode_range_change_delay = 1;
            }
            else
            {
              meter_mode_range_change_delay = 1;
            }
          }
          else
          {
            meter_mode_range_change_delay = 2;
          }
        }
        else
        {
          meter_mode_range_change_delay = 5;
        }
        break;
    }
  }
  else
  {
    meter_mode_range_change_delay = 0;
  }
  if ( curr_meas_mode == MM_ACV && meter_mode_acv_dcv )
    meter_mode_range_change_delay = 1;
  if ( curr_meas_mode == MM_ACV )
  {
    if ( input_1ms_peak_enabled )
      meter_mode_range_change_delay = 5;
  }
}
// 20000223: using guessed type char meter_mode_range_change_delay;
// 20003B32: using guessed type char lowz_measuring_ac;
// 20003B3D: using guessed type char burden_enabled_for_current_ranges;
// 20003B4F: using guessed type char input_1ms_peak_enabled;
// 20003B52: using guessed type char meter_mode_acv_dcv;

//----- (0800E1FE) --------------------------------------------------------
void meter_process_new_meas(void)
{
  meter_process_autorange();
  if ( !meter_mode_range_change_delay )
    meter_process_overload();
  meter_process_hold();
  meter_process_rel_meas();
  meter_process_min_max();
  scr_overload_displayed = curr_scr_overflow != 0;
}
// 20000223: using guessed type char meter_mode_range_change_delay;
// 20003AEA: using guessed type char scr_overload_displayed;

//----- (0800E308) --------------------------------------------------------
void meter_process_autorange()
{
  unsigned int max_value; // r1@27
  unsigned int min_value; // r2@33
  int scr_digits; // r0@44

  if ( curr_meas_mode != MM_HZ
    && curr_meas_mode != MM_mSEC
    && curr_meas_mode != MM_DUTY
    && curr_meas_mode != MM_ACuVA
    && curr_meas_mode != MM_ACmVA
    && curr_meas_mode != MM_ACVA
    && curr_meas_mode != MM_DCuVA
    && curr_meas_mode != MM_DCmVA
    && curr_meas_mode != MM_DCVA )
    curr_scr_overflow = 0;
  if ( meter_mode_range_change_delay )
  {
    --meter_mode_range_change_delay;
    autorange_overflowed_last_time = 0;
    autorange_changed_range = 1;
  }
  else
  {
    autorange_changed_range = 0;
    if ( meter_in_cal_mode )
    {
      autorange_overflowed_last_time = 0;
    }
    else if ( curr_meas_mode != MM_ACuVA
           && curr_meas_mode != MM_ACmVA
           && curr_meas_mode != MM_ACVA
           && curr_meas_mode != MM_DCuVA
           && curr_meas_mode != MM_DCmVA
           && curr_meas_mode != MM_DCVA )
    {
      if ( curr_meas_mode != MM_HZ && curr_meas_mode != MM_mSEC && curr_meas_mode != MM_DUTY )
      {
        if ( curr_meas_mode == MM_DIODE )
        {
          max_value = max_digits_in_range;
        }
        else if ( autorange_overflowed_last_time )
        {
          max_value = max_digits_in_range / 12u + max_digits_in_range;
        }
        else
        {
          max_value = max_digits_in_range / 10u + max_digits_in_range;
        }
        if ( curr_meas_mode != MM_CAP || curr_meas_range != 5 )
          min_value = max_digits_in_range / 10u - 2 * (max_digits_in_range / 100u);
        else
          min_value = max_digits_in_range / 100u - 2 * (max_digits_in_range / 1000u);
        if ( curr_meas_mode != MM_ACV && curr_meas_mode != MM_DCV )
        {
          if ( (curr_meas_mode == MM_ACA || curr_meas_mode == MM_DCA) && curr_meas_range == 2 )
            min_value *= 5;
        }
        else if ( curr_meas_range == MM_DCmV )
        {
          min_value *= 10;
        }
        if ( curr_scr_digits >= 0 )
        {
          scr_digits = curr_scr_digits;
          meter_overflow_was_negative = 0;
        }
        else
        {
          scr_digits = -curr_scr_digits;
          meter_overflow_was_negative = 1;
        }
        if ( meter_min_max_mode
          || autoranging_disabled
          || (signed int)ranges_in_mode[(unsigned __int8)curr_meas_mode] < 2 )
        {
          if ( curr_meas_mode == MM_TEMP )
          {
            if ( temp_meas_sign == 1 )
            {
              meter_overflow_was_negative = 0;
              curr_scr_overflow = 1;
            }
            else if ( temp_meas_sign == 2 )
            {
              meter_overflow_was_negative = 1;
              curr_scr_overflow = 1;
            }
          }
          else if ( max_value < scr_digits )
          {
            curr_scr_overflow = 1;
          }
        }
        else
        {
          if ( max_value >= scr_digits )
          {
            if ( scr_digits < min_value && !manual_hold_is_enabled && curr_meas_range )
            {
              --curr_meas_range;
              meter_range_changed = 1;
              autorange_changed_range = 1;
            }
          }
          else if ( manual_hold_is_enabled
                 && (!auto_hold_is_enabled
                  || curr_meas_mode == MM_HZ
                  || curr_meas_mode == MM_mSEC
                  || curr_meas_mode == MM_DUTY
                  || curr_meas_mode == MM_CAP)
                 || curr_meas_range >= ranges_in_mode[(unsigned __int8)curr_meas_mode] - 1 )
          {
            curr_scr_overflow = 1;
          }
          else
          {
            ++curr_meas_range;
            meter_range_changed = 1;
            autorange_changed_range = 1;
          }
          autorange_overflowed_last_time = curr_scr_overflow != 0;
        }
      }
      else
      {
        meter_overflow_was_negative = 0;
      }
    }
  }
}
// 20000223: using guessed type char meter_mode_range_change_delay;
// 20003854: using guessed type int max_digits_in_range;
// 20003858: using guessed type int curr_scr_digits;
// 20003A9A: using guessed type char autorange_overflowed_last_time;
// 20003AE6: using guessed type char autoranging_disabled;
// 20003AE7: using guessed type char meter_overflow_was_negative;
// 20003AEC: using guessed type char meter_range_changed;
// 20003AF8: using guessed type char autorange_changed_range;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B45: using guessed type char temp_meas_sign;

//----- (0800E654) --------------------------------------------------------
void __fastcall meter_process_hold()
{
  signed int v0; // r4@1
  unsigned int v1; // r5@29

  v0 = 0;
  if ( __PAIR__(auto_hold_is_enabled, manual_hold_is_enabled)
    && curr_meas_mode != MM_HZ
    && curr_meas_mode != MM_mSEC
    && curr_meas_mode != MM_DUTY
    && curr_meas_mode != MM_CAP
    && !autorange_changed_range )
  {
    if ( curr_meas_mode != MM_OHMS && curr_meas_mode != MM_CONTINUITY )
      v0 = 1000;
    if ( curr_scr_digits < v0 && -v0 < curr_scr_digits )
    {
      auto_hold_holding = 1;
      auto_hold_need_to_unhold = 0;
      TIM2_auto_hold_unhold_timer_1s = 0;
      meas_was_updated = 0;
    }
    else if ( auto_hold_holding )
    {
      auto_hold_holding = 0;
      auto_hold_need_to_unhold = 0;
      TIM2_auto_hold_unhold_timer_1s = 0;
    }
    else if ( auto_hold_need_to_unhold | curr_scr_overflow )
    {
      if ( curr_meas_mode == MM_OHMS || curr_meas_mode == MM_CONTINUITY || !curr_scr_overflow )
      {
        if ( (curr_meas_mode == MM_OHMS || curr_meas_mode == MM_CONTINUITY) && curr_scr_overflow )
        {
          meas_was_updated = 0;
          hold_last_value_for_auto = 1000000;
        }
        else if ( mode_range_just_got_changed_for_hold_purposes & (unsigned __int8)(curr_scr_overflow ^ 1)
               || curr_scr_digits >= hold_last_value_for_auto + 400
               || hold_last_value_for_auto - 400 >= curr_scr_digits )
        {
          mode_range_just_got_changed_for_hold_purposes = 0;
          if ( curr_scr_digits >= 0 )
            v1 = curr_scr_digits;
          else
            v1 = -curr_scr_digits;
          if ( max_digits_in_range / 0xAu + max_digits_in_range >= v1 )
          {
            lcd_update_from_auto_hold = 1;
            if ( logging_active )
              logging_interval_elapsed = 1;
            hold_last_value_for_auto = curr_scr_digits;
            beep_ms(50u);
          }
        }
        else
        {
          meas_was_updated = 0;
        }
        auto_hold_need_to_unhold = 0;
        TIM2_auto_hold_unhold_timer_1s = 0;
      }
    }
    else
    {
      meas_was_updated = 0;
    }
  }
}
// 20003854: using guessed type int max_digits_in_range;
// 20003858: using guessed type int curr_scr_digits;
// 20003888: using guessed type int hold_last_value_for_auto;
// 20003A66: using guessed type __int16 TIM2_auto_hold_unhold_timer_1s;
// 20003AE7: using guessed type char meter_overflow_was_negative;
// 20003AF2: using guessed type char auto_hold_holding;
// 20003AF8: using guessed type char autorange_changed_range;

//----- (0800E834) --------------------------------------------------------
void __fastcall meter_process_rel_meas()
{
  if ( rel_meas_enabled && !curr_scr_overflow )
  {
    if ( !rel_meas_got_rel_val )
    {
      rel_meas_got_rel_val = 1;
      rel_meas_rel_val = curr_scr_digits;
    }
    curr_scr_digits -= rel_meas_rel_val;
  }
}
// 20003858: using guessed type int curr_scr_digits;
// 2000388C: using guessed type int rel_meas_rel_val;
// 20003AF5: using guessed type char rel_meas_enabled;
// 20003AF6: using guessed type char rel_meas_got_rel_val;

//----- (0800E87C) --------------------------------------------------------
void __fastcall meter_process_min_max()
{
  int v0; // r0@7

  if ( meter_min_max_mode )
  {
    if ( curr_scr_overflow )
    {
      if ( meter_overflow_was_negative )
        meter_min_max_minval = -100000;
      else
        meter_min_max_maxval = 100000;
    }
    else
    {
      v0 = curr_scr_digits;
      if ( meter_min_max_maxval < curr_scr_digits )
        meter_min_max_maxval = curr_scr_digits;
      if ( curr_scr_digits < meter_min_max_minval )
        meter_min_max_minval = curr_scr_digits;
      if ( meter_min_max_avg_count )
      {
        ++meter_min_max_avg_count;
        if ( meter_min_max_avg_count >= 1000001 )
          meter_min_max_avg_count = 1000000;
        meter_min_max_avg_diff += curr_scr_digits - meter_min_max_avg;
        meter_min_max_avg += meter_min_max_avg_diff / meter_min_max_avg_count;
        v0 = meter_min_max_avg_diff - meter_min_max_avg_count * (meter_min_max_avg_diff / meter_min_max_avg_count);
        meter_min_max_avg_diff -= meter_min_max_avg_count * (meter_min_max_avg_diff / meter_min_max_avg_count);
      }
      else
      {
        meter_min_max_avg_count = 1;
        meter_min_max_avg = curr_scr_digits;
        meter_min_max_avg_diff = 0;
      }
      if ( meter_min_max_mode == 1 )
      {
        v0 = meter_min_max_maxval;
        if ( meter_min_max_maxval >= 100000 )
        {
          meter_overflow_was_negative = 0;
          curr_scr_overflow = 1;
        }
      }
      else if ( meter_min_max_mode >= 1u )
      {
        if ( meter_min_max_mode == 3 )
        {
          v0 = meter_min_max_avg;
        }
        else if ( meter_min_max_mode < 3u )
        {
          v0 = meter_min_max_minval;
          if ( meter_min_max_minval < -99999 )
          {
            meter_overflow_was_negative = 1;
            curr_scr_overflow = 1;
          }
        }
      }
      if ( (signed int)meter_min_max_mode < 4 )
        curr_scr_digits = v0;
    }
  }
}
// 20003858: using guessed type int curr_scr_digits;
// 20003874: using guessed type int meter_min_max_maxval;
// 20003878: using guessed type int meter_min_max_minval;
// 2000387C: using guessed type int meter_min_max_avg;
// 20003880: using guessed type int meter_min_max_avg_diff;
// 20003884: using guessed type int meter_min_max_avg_count;
// 20003AE7: using guessed type char meter_overflow_was_negative;

//----- (0800E9E8) --------------------------------------------------------
void meter_process_overload()
{
  meter_overload = 0;
  meter_danger_icon = 0;
  if ( curr_meas_mode != MM_DCV && curr_meas_mode != MM_ACV || curr_meas_range != MM_DCmV )
  {
    if ( curr_meas_mode == MM_LOW_Z )
    {
      meter_overload = is_abs_out_of_range(curr_scr_digits, 6000);
      if ( curr_scr_overflow )
        meter_overload = 1;
    }
  }
  else
  {
    meter_overload = is_abs_out_of_range(curr_scr_digits, 6000);
    if ( curr_scr_overflow )
      meter_overload = 1;
  }
  if ( curr_meas_mode != MM_DCV && curr_meas_mode != MM_ACV )
  {
    if ( curr_meas_mode != MM_ACuVA
      && curr_meas_mode != MM_ACmVA
      && curr_meas_mode != MM_ACVA
      && curr_meas_mode != MM_DCuVA
      && curr_meas_mode != MM_DCmVA
      && curr_meas_mode != MM_DCVA )
    {
      if ( curr_meas_mode == MM_LOW_Z )
      {
        meter_danger_icon = is_abs_out_of_range(curr_scr_digits, 300);
        if ( curr_scr_overflow )
          meter_danger_icon = 1;
      }
    }
    else if ( curr_meas_range == MM_DCV || curr_meas_range == MM_DCmV )
    {
      meter_danger_icon = is_abs_out_of_range(meas_va_last_volts, 30000);
      if ( curr_power_volts_overflow )
        meter_danger_icon = 1;
    }
  }
  else
  {
    if ( curr_meas_range )
    {
      if ( curr_meas_range == 2 )
      {
        meter_danger_icon = is_abs_out_of_range(curr_scr_digits, 3000);
      }
      else if ( curr_meas_range >= 2u )
      {
        if ( curr_meas_range == MM_DCmV )
          meter_danger_icon = is_abs_out_of_range(curr_scr_digits, 300);
      }
      else
      {
        meter_danger_icon = is_abs_out_of_range(curr_scr_digits, 30000);
      }
    }
    if ( curr_meas_range && curr_scr_overflow )
      meter_danger_icon = 1;
  }
  scr_update_danger_icon();
}
// 20003858: using guessed type int curr_scr_digits;
// 20003868: using guessed type int meas_va_last_volts;
// 20003B49: using guessed type char meter_danger_icon;
// 20003B4A: using guessed type char meter_overload;
// 20003B5D: using guessed type char curr_power_volts_overflow;

//----- (0800EBAC) --------------------------------------------------------
bool __fastcall is_abs_out_of_range(bool num, int range)
{
  int v2; // r2@1

  v2 = num;
  LOBYTE(num) = 0;
  if ( v2 >= range || -range >= v2 )
    LOBYTE(num) = 1;
  return num;
}

//----- (0800EBC2) --------------------------------------------------------
void __cdecl finish_sys_init_and_handle_boot_buttons()
{
  int v0; // r0@22

  meas_hw_turn_on_4V_supply();
  high_voltage_diode = 0;
  meas_hw_set_hv_diode(MM_LOW_Z);
  meas_hw_set_va_ctl_useless(MM_LOW_Z);
  meas_hw_set_temp_ctl(MM_LOW_Z);
  meas_hw_set_fre_ctl(MM_LOW_Z);
  meas_hw_set_amp_amplifier_power(MM_LOW_Z);
  meas_hw_set_amp_x10(MM_LOW_Z, 0);
  show_firmware_version();
  update_lcd_if_appropriate();
  sys_boot_button_delay_timer_1ms_unit = 2000;
  config_hy_based_on_mode_range(MM_TEMP, 0);
  while ( sys_boot_button_delay_timer_1ms_unit || cal_sd_state == 4 )
  {
    if ( TIM2_10ms_interrupt )
    {
      TIM2_10ms_interrupt = 0;
      read_buttons_then_update();
      if ( cal_manual_state )
      {
        if ( cal_manual_state == 1 )
        {
          show_cal_mode_msg();
          show_cal_mode_msg_on_subscr();
          update_lcd_if_appropriate();
        }
        else
        {
          if ( cal_manual_state == 2 )
          {
            meter_in_cal_mode = 1;
            need_to_update_subscr = 1;
            cal_erase_amp_rel_data();
            sys_boot_button_delay_timer_1ms_unit = 0;
            break;
          }
          if ( cal_manual_state == 3 )
          {
            setting_last_cal_year_month = 1;
            need_to_update_subscr = 1;
            edit_year = curr_year;
            sys_boot_button_delay_timer_1ms_unit = 0;
            break;
          }
        }
      }
      else if ( cal_sd_state )
      {
        switch ( cal_sd_state )
        {
          case 1:
            show_sdcal_msg();
            break;
          case 2:
            if ( cal_mode_save_to_sd )
            {
              show_sdsav_msg();
            }
            else if ( cal_mode_load_from_sd )
            {
              show_sdset_msg();
            }
            break;
          case 3:
            if ( cal_mode_save_to_sd )
            {
              cal_save_to_sd();
              if ( v0 )
              {
                show_sd_cal_err();
                cal_sd_state = 4;
              }
              else
              {
                show_sd_cal_success();
                cal_sd_state = 4;
              }
            }
            else if ( cal_mode_load_from_sd )
            {
              if ( cal_load_from_sd() )
              {
                show_sd_cal_err();
                cal_sd_state = 4;
              }
              else
              {
                show_sd_cal_success();
                cal_sd_state = 4;
              }
            }
            break;
        }
      }
    }
  }
  cal_sd_state = 0;
  cal_manual_state = 0;
  sys_boot_button_delay_timer_1ms_unit = 0;
  cal_mode_load_from_sd = 0;
  cal_mode_save_to_sd = 0;
  lcd_turn_off_all_segments();
  update_lcd_if_appropriate();
}
// 8012438: using guessed type int cal_load_from_sd(void);
// 2000021A: using guessed type __int16 sys_boot_button_delay_timer_1ms_unit;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B22: using guessed type char cal_mode_save_to_sd;
// 20003B23: using guessed type char cal_mode_load_from_sd;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B25: using guessed type char setting_last_cal_year_month;
// 20003B4B: using guessed type char high_voltage_diode;
// 20003B5F: using guessed type char cal_manual_state;
// 20003B60: using guessed type char cal_sd_state;
// 20003B62: using guessed type char TIM2_10ms_interrupt;
// 20003B6F: using guessed type char edit_year;

//----- (0800ED94) --------------------------------------------------------
void meas_cap_reset_no_reading_timeout_timer()
{
  int v0; // r0@3

  if ( curr_meas_mode == MM_CAP )
  {
    meas_cap_no_reading_timeout_elapsed = 0;
    meas_cap_some_other_timer_unused = 0;
    if ( curr_meas_range <= 1u )
    {
      mes_cap_no_reading_timeout_timer_10ms_unit = 200;
    }
    else
    {
      v0 = curr_meas_range - 2;
      if ( (unsigned int)v0 <= 2 )
      {
        mes_cap_no_reading_timeout_timer_10ms_unit = 200;
      }
      else if ( v0 == 3 )
      {
        mes_cap_no_reading_timeout_timer_10ms_unit = 300;
      }
    }
  }
}
// 20003A78: using guessed type __int16 mes_cap_no_reading_timeout_timer_10ms_unit;
// 20003A7A: using guessed type __int16 meas_cap_some_other_timer_unused;
// 20003B3C: using guessed type char meas_cap_no_reading_timeout_elapsed;

//----- (0800EDE2) --------------------------------------------------------
void __fastcall spinloop(unsigned int amount)
{
  unsigned int i; // r1@1

  for ( i = 0; i < amount; ++i )
    ;
}

//----- (0800EDF2) --------------------------------------------------------
void __fastcall SysTick_Handler_real()
{
  if ( SysTickTimer )
    --SysTickTimer;
}
// 20003808: using guessed type int SysTickTimer;

//----- (0800EE18) --------------------------------------------------------
void reset_apo_timeout()
{
  if ( meter_min_max_mode )
    apo_timeout_sec = 3600;
  else
    apo_timeout_sec = 1800;
}
// 2000021C: using guessed type __int16 apo_timeout_sec;

//----- (0800EE48) --------------------------------------------------------
void __fastcall hy_change_CTA_val_for_ac_freq()
{
  signed __int16 v0; // r4@11

  if ( !burden_enabled_for_current_ranges
    && ((curr_meas_mode == MM_ACuA
      || curr_meas_mode == MM_ACmA
      || curr_meas_mode == MM_ACA
      || curr_meas_mode == MM_ACV
      || curr_meas_mode == MM_ACmV)
     && !meter_mode_acv_dcv
     || curr_meas_mode == MM_LOW_Z && lowz_measuring_ac) )
  {
    if ( curr_meas_mode )
      v0 = 100;
    else
      v0 = 500;
    ++hy_change_CTA_val_timer;
    if ( (unsigned __int16)v0 < (unsigned int)hy_change_CTA_val_timer )
    {
      hy_change_CTA_val_timer = 0;
      hy_change_CTA_val_next = hy_change_CTA_val_next != 1;
      if ( hy_change_CTA_val_next )
        hy_CTA_initial_val = 0x8000;
      else
        hy_CTA_initial_val = 0xE000;
      config_hy_based_on_mode_range(curr_meas_mode, curr_meas_range);
    }
  }
}
// 2000020C: using guessed type int hy_CTA_initial_val;
// 20003B32: using guessed type char lowz_measuring_ac;
// 20003B35: using guessed type char hy_change_CTA_val_next;
// 20003B3D: using guessed type char burden_enabled_for_current_ranges;
// 20003B52: using guessed type char meter_mode_acv_dcv;

//----- (0800EF18) --------------------------------------------------------
void __cdecl beep_contentedly()
{
  beep_and_reset_apo_timeout_if_asked(1, 1, 100);
}

//----- (0800EF26) --------------------------------------------------------
void beep_excitedly()
{
  beep_and_reset_apo_timeout_if_asked(1, 1, 200);
}

//----- (0800EF34) --------------------------------------------------------
void __fastcall beep_angrily()
{
  beep_and_reset_apo_timeout_if_asked(1, 3, 50);
}

//----- (0800EF42) --------------------------------------------------------
void __fastcall beep_and_reset_apo_timeout_if_asked(char should_reset_apo_timeout, char num, __int16 ms)
{
  if ( should_reset_apo_timeout == 1 )
    reset_apo_timeout();
  beep_num_beeps = num;
  beep_time = ms;
  beep_ms(ms);
}
// 20003A6A: using guessed type __int16 beep_time;

//----- (0800EF74) --------------------------------------------------------
void __fastcall beep_ms(unsigned __int16 ms)
{
  beep_currently_beeping = 1;
  beep_timer_1ms = ms;
  LOWORD(GPIOE.BSRR) = 128;
}
// 20003A68: using guessed type __int16 beep_timer_1ms;
// 20003B14: using guessed type char beep_currently_beeping;
// 40021000: using guessed type GPIO_REGS GPIOE;

//----- (0800EF94) --------------------------------------------------------
int __fastcall meas_apply_offset_adj(int a1)
{
  int v1; // r5@2

  if ( curr_meas_mode == MM_DIODE )
  {
    v1 = a1;
  }
  else if ( calibrating_offset )
  {
    v1 = cal_update_curr_offset_accu(a1);
  }
  else
  {
    v1 = meas_perform_offset_adj(a1);
  }
  return v1;
}
// 20003B26: using guessed type char calibrating_offset;

//----- (0800EFD4) --------------------------------------------------------
int __fastcall cal_update_curr_offset_accu(int a1)
{
  signed int v1; // r6@1

  v1 = 16;
  if ( cal_countdown_timer == 16 )
  {
    cal_curr_offset_accu = a1;
  }
  else if ( curr_meas_mode != MM_OHMS || (signed int)curr_meas_range < 5 )
  {
    cal_curr_offset_accu += a1;
  }
  else if ( (signed int)(unsigned __int8)cal_countdown_timer < 9 )
  {
    cal_curr_offset_accu += a1;
  }
  else
  {
    cal_curr_offset_accu = 0;
  }
  --cal_countdown_timer;
  if ( !cal_countdown_timer )
  {
    calibrating_offset = 0;
    calibrating_offset_finished = 1;
    meas_was_updated = 1;
    if ( curr_meas_mode == MM_OHMS && (signed int)curr_meas_range >= 5 )
      v1 = 8;
    cal_curr_offset_val = cal_curr_offset_accu / v1;
    cal_write_factor(0, cal_curr_offset_accu / v1);
  }
  return 0;
}
// 200038E0: using guessed type int cal_curr_offset_val;
// 200038FC: using guessed type int cal_curr_offset_accu;
// 20003B26: using guessed type char calibrating_offset;
// 20003B27: using guessed type char calibrating_offset_finished;
// 20003B2F: using guessed type char cal_countdown_timer;

//----- (0800F098) --------------------------------------------------------
int __fastcall cal_update_cap_offset_accu(unsigned int a1)
{
  int result; // r0@2

  cal_curr_gain_accu += a1;
  --cal_countdown_timer;
  if ( cal_countdown_timer )
  {
    result = 0;
  }
  else
  {
    calibrating_offset = 0;
    calibrating_offset_finished = 1;
    meas_was_updated = 1;
    result = int64_div(cal_curr_gain_accu, 16LL);
    cal_offset_val_unused = result;
  }
  return result;
}
// 200038DC: using guessed type int cal_offset_val_unused;
// 20003B26: using guessed type char calibrating_offset;
// 20003B27: using guessed type char calibrating_offset_finished;
// 20003B2F: using guessed type char cal_countdown_timer;

//----- (0800F108) --------------------------------------------------------
int __fastcall cal_update_ac_offset_accu(int a1)
{
  int v1; // r1@1
  int result; // r0@1

  v1 = a1;
  result = 0;
  if ( cal_countdown_timer == 16 )
    cal_curr_offset_accu = v1;
  else
    cal_curr_offset_accu += v1;
  --cal_countdown_timer;
  if ( !cal_countdown_timer )
  {
    calibrating_offset = 0;
    calibrating_offset_finished = 1;
    result = cal_curr_offset_accu / 16;
    cal_curr_offset_accu_div_by_16_never_read = cal_curr_offset_accu / 16;
  }
  meas_was_updated = 1;
  return result;
}
// 200038E4: using guessed type int cal_curr_offset_accu_div_by_16_never_read;
// 200038FC: using guessed type int cal_curr_offset_accu;
// 20003B26: using guessed type char calibrating_offset;
// 20003B27: using guessed type char calibrating_offset_finished;
// 20003B2F: using guessed type char cal_countdown_timer;

//----- (0800F1A8) --------------------------------------------------------
signed int __fastcall cal_prepare_ac_factor_calibration(char cal_gain)
{
  char v2; // r5@1
  signed int hz; // r6@7

  v2 = 0;
  if ( curr_meas_mode != MM_ACuA
    && curr_meas_mode != MM_ACmA
    && curr_meas_mode != MM_ACA
    && curr_meas_mode != MM_ACV
    && curr_meas_mode != MM_ACmV )
    return 0;
  hz = ac_input_freq_to_hz(ac_input_freq_range, ac_input_freq);
  if ( curr_meas_mode != MM_ACV || (signed int)curr_meas_range < 2 || hz < 8000 || hz >= 12001 )
  {
    if ( curr_meas_mode != MM_ACV && curr_meas_mode != MM_ACmV || hz < 90000 )
    {
      if ( curr_meas_mode != MM_ACV && curr_meas_mode != MM_ACmV || hz < 18000 || hz >= 22001 )
      {
        if ( curr_meas_mode != MM_ACuA && curr_meas_mode != MM_ACmA && curr_meas_mode != MM_ACA
          || hz < 8000
          || hz >= 12001 )
        {
          if ( !cal_gain )
            cal_erase_ac_factors();
        }
        else
        {
          if ( curr_meas_mode == MM_ACA )
            return 2;
          if ( curr_meas_mode == MM_ACuA && !curr_meas_range )
            return 2;
          if ( curr_meas_mode == MM_ACmA && !curr_meas_range )
            return 2;
          if ( cal_gain )
            cal_save_ac_factor_fullrange = 1;
          else
            cal_save_ac_factor_decirange = 1;
          v2 = 1;
          meter_mode_range_change_delay = 5;
        }
      }
      else
      {
        if ( curr_meas_mode == MM_ACmV )
          return 2;
        if ( cal_gain )
          cal_save_ac_factor_fullrange_lf = 1;
        else
          cal_save_ac_factor_decirange_lf = 1;
        v2 = 1;
        meter_mode_range_change_delay = 5;
      }
    }
    else
    {
      if ( cal_gain )
        cal_save_ac_factor_fullrange = 1;
      else
        cal_save_ac_factor_decirange = 1;
      v2 = 1;
      meter_mode_range_change_delay = 5;
    }
  }
  else
  {
    if ( cal_gain )
      cal_save_ac_factor_fullrange = 1;
    else
      cal_save_ac_factor_decirange = 1;
    v2 = 1;
    meter_mode_range_change_delay = 5;
  }
  return (unsigned __int8)v2;
}
// 20000223: using guessed type char meter_mode_range_change_delay;
// 20003870: using guessed type int ac_input_freq;
// 20003B36: using guessed type char cal_save_ac_factor_decirange;
// 20003B37: using guessed type char cal_save_ac_factor_fullrange;
// 20003B38: using guessed type char cal_save_ac_factor_decirange_lf;
// 20003B39: using guessed type char cal_save_ac_factor_fullrange_lf;

//----- (0800F38C) --------------------------------------------------------
int __fastcall meas_perform_offset_adj(int a1)
{
  int result; // r0@8

  if ( curr_meas_mode != MM_ACuVA
    && curr_meas_mode != MM_ACmVA
    && curr_meas_mode != MM_ACVA
    && curr_meas_mode != MM_DCuVA
    && curr_meas_mode != MM_DCmVA
    && curr_meas_mode != MM_DCVA )
  {
    result = a1 - cal_curr_offset_val;
  }
  else if ( measuring_amps_of_va_or_volts_of_burden )
  {
    result = a1 - cal_curr_offset_va_amps;
  }
  else
  {
    result = a1 - cal_curr_offset_va_volts;
  }
  return result;
}
// 200038E0: using guessed type int cal_curr_offset_val;
// 20003904: using guessed type int cal_curr_offset_va_volts;
// 20003908: using guessed type int cal_curr_offset_va_amps;
// 20003B59: using guessed type char measuring_amps_of_va_or_volts_of_burden;

//----- (0800F3FC) --------------------------------------------------------
int __fastcall meas_perform_offset_adj_ac(int a1)
{
  int result; // r0@1

  result = a1 - cal_curr_offset_val;
  if ( result < 1 )
    result = 0;
  return result;
}
// 200038E0: using guessed type int cal_curr_offset_val;

//----- (0800F412) --------------------------------------------------------
int __fastcall meas_apply_gain_adj(int a1)
{
  int v1; // r5@2

  if ( calibrating_ohms_50M_offset )
  {
    v1 = cal_update_curr_gain_accu(a1);
  }
  else if ( calibrating_gain )
  {
    v1 = cal_update_curr_gain_accu(a1);
  }
  else
  {
    v1 = meas_perform_gain_adj(a1);
  }
  return v1;
}
// 20003B28: using guessed type char calibrating_gain;
// 20003B2A: using guessed type char calibrating_ohms_50M_offset;

//----- (0800F450) --------------------------------------------------------
int __fastcall meas_perform_gain_adj(int a1)
{
  int v1; // r4@1
  float v2; // r6@1
  char zf; // zf@1
  float v4; // r0@2
  float v5; // r5@2
  double v6; // r0@4
  double v7; // r0@4

  v1 = a1;
  v2 = meas_get_gain_adj();
  fp_equals(v2, 0.0);
  if ( zf )
  {
    v5 = 0.0;
  }
  else
  {
    v4 = fp_from_int(v1);
    v5 = fp_div(v4, v2);
  }
  v6 = dp_from_fp(v5);
  v7 = dp_add(v6, 0.5);
  return dp_to_int(v7);
}

//----- (0800F4A0) --------------------------------------------------------
int __fastcall cal_update_curr_gain_accu(int num)
{
  int v1; // r6@1
  signed int v2; // r4@1
  int v3; // r0@6
  float v4; // r0@6
  float v5; // r0@6
  int result; // r0@7
  int v7; // r0@18
  int v8; // r0@18
  float v9; // r0@18
  float v10; // r0@18
  int v11; // r5@18
  float v12; // r0@19
  double v13; // r0@19
  double v14; // r0@19

  v1 = num;
  v2 = 16;
  if ( calibrating_ohms_50M_offset )
  {
    if ( (signed int)(unsigned __int8)cal_countdown_timer < 9 )
      cal_curr_gain_accu += num;
    else
      cal_curr_gain_accu = 0LL;
    --cal_countdown_timer;
    if ( !cal_countdown_timer )
    {
      calibrating_ohms_50M_offset = 0;
      v3 = int64_div(cal_curr_gain_accu, 8LL);
      v4 = fp_from_int(v3);
      v5 = fp_div(v4, cal_curr_gain_val);
      cal_ohms_50M_offset_factor = fp_to_int(v5) - 30000;
      cal_write_factor(0x96, cal_ohms_50M_offset_factor);
      meter_mode_range_change_delay = 5;
    }
    result = 0;
  }
  else
  {
    if ( curr_meas_mode != MM_OHMS || (signed int)curr_meas_range < 5 )
    {
      cal_curr_gain_accu += num;
    }
    else if ( (signed int)(unsigned __int8)cal_countdown_timer < 9 )
    {
      cal_curr_gain_accu += num;
    }
    else
    {
      cal_curr_gain_accu = 0LL;
    }
    --cal_countdown_timer;
    if ( cal_countdown_timer )
    {
      v12 = fp_from_int(num);
      v13 = dp_from_fp(v12);
      v14 = dp_div(v13, 60.80732);
      v11 = dp_to_int(v14);
    }
    else
    {
      calibrating_gain = 0;
      calibrating_gain_finished = 1;
      meas_was_updated = 1;
      if ( curr_meas_mode == MM_OHMS && (signed int)curr_meas_range >= 5 )
        v2 = 8;
      v7 = int64_div(cal_curr_gain_accu, v2);
      cal_curr_gain_accu_float = fp_from_int(v7);
      cal_calc_gain_from_gain_accu();
      v8 = fp_to_int(cal_curr_gain_val);
      cal_write_factor(1, v8);
      v9 = fp_from_int(v1);
      v10 = fp_div(v9, cal_curr_gain_val);
      v11 = fp_to_int(v10);
    }
    result = v11;
  }
  return result;
}
// 20000223: using guessed type char meter_mode_range_change_delay;
// 200038F4: using guessed type int cal_ohms_50M_offset_factor;
// 20003B28: using guessed type char calibrating_gain;
// 20003B29: using guessed type char calibrating_gain_finished;
// 20003B2A: using guessed type char calibrating_ohms_50M_offset;
// 20003B2F: using guessed type char cal_countdown_timer;

//----- (0800F65C) --------------------------------------------------------
float __cdecl meas_get_gain_adj()
{
  float result; // r0@8

  if ( curr_meas_mode != MM_ACuVA
    && curr_meas_mode != MM_ACmVA
    && curr_meas_mode != MM_ACVA
    && curr_meas_mode != MM_DCuVA
    && curr_meas_mode != MM_DCmVA
    && curr_meas_mode != MM_DCVA )
  {
    result = cal_curr_gain_val;
  }
  else if ( measuring_amps_of_va_or_volts_of_burden )
  {
    result = cal_curr_gain_va_amps;
  }
  else
  {
    result = cal_curr_gain_va_volts;
  }
  return result;
}
// 20003B59: using guessed type char measuring_amps_of_va_or_volts_of_burden;

//----- (0800F6E4) --------------------------------------------------------
void __fastcall cal_update_cap_gain_accu(unsigned int gain, int last_offset)
{
  int v2; // r5@1
  int v3; // r6@2
  float v4; // r0@3
  int v5; // r0@5

  v2 = last_offset;
  cal_curr_gain_accu += gain;
  --cal_countdown_timer;
  if ( !cal_countdown_timer )
  {
    calibrating_gain = 0;
    calibrating_gain_finished = 1;
    meas_was_updated = 1;
    v3 = int64_div(cal_curr_gain_accu, 16LL);
    cal_curr_offset_val = v2 - (v3 - v2) / 9u;
    cal_write_factor(0, cal_curr_offset_val);
    if ( curr_meas_mode == MM_CAP )
    {
      v4 = fp_from_uint(curr_cap_val - cal_curr_offset_val);
      cal_curr_gain_val = fp_div(v4, 10000.0);
    }
    else
    {
      cal_curr_gain_accu_float = fp_from_uint(v3 - cal_curr_offset_val);
      cal_calc_gain_from_gain_accu();
    }
    v5 = fp_to_int(cal_curr_gain_val);
    cal_write_factor(1, v5);
  }
}
// 200038E0: using guessed type int cal_curr_offset_val;
// 20003948: using guessed type int curr_cap_val;
// 20003B28: using guessed type char calibrating_gain;
// 20003B29: using guessed type char calibrating_gain_finished;
// 20003B2F: using guessed type char cal_countdown_timer;

//----- (0800F7CC) --------------------------------------------------------
void __fastcall cal_update_ac_gain_accu(int num, int offset)
{
  int v2; // r7@5
  float v3; // r0@6
  int v4; // r0@8

  if ( cal_countdown_timer == 16 )
    cal_curr_offset_accu = num;
  else
    cal_curr_offset_accu += num;
  --cal_countdown_timer;
  if ( !cal_countdown_timer )
  {
    calibrating_gain = 0;
    calibrating_gain_finished = 1;
    v2 = cal_curr_offset_accu / 16;
    cal_curr_offset_val = offset - (cal_curr_offset_accu / 16 - offset) / 9;
    cal_write_factor(0, cal_curr_offset_val);
    if ( curr_meas_mode == MM_CAP )
    {
      v3 = fp_from_int(curr_cap_val - cal_curr_offset_val);
      cal_curr_gain_val = fp_div(v3, 10000.0);
    }
    else
    {
      cal_curr_gain_accu_float = fp_from_int(v2 - cal_curr_offset_val);
      cal_calc_gain_from_gain_accu();
    }
    v4 = fp_to_int(cal_curr_gain_val);
    cal_write_factor(1, v4);
  }
  meas_was_updated = 1;
}
// 200038E0: using guessed type int cal_curr_offset_val;
// 200038FC: using guessed type int cal_curr_offset_accu;
// 20003948: using guessed type int curr_cap_val;
// 20003B28: using guessed type char calibrating_gain;
// 20003B29: using guessed type char calibrating_gain_finished;
// 20003B2F: using guessed type char cal_countdown_timer;

//----- (0800F8AC) --------------------------------------------------------
void __fastcall cal_ac_factor_update_and_save(char a1, int a2)
{
  if ( a1 == 1 )
  {
    if ( curr_meas_mode != MM_ACV || curr_meas_range != 3 )
      cal_ac_factor_decirange = a2 - 5000;
    else
      cal_ac_factor_decirange = a2 - 600;
  }
  else if ( (unsigned __int8)a1 >= 1u )
  {
    if ( a1 == 3 )
    {
      if ( curr_meas_mode != MM_ACV || curr_meas_range != 3 )
        cal_ac_factor_decirange_lf = a2 - 5000;
      else
        cal_ac_factor_decirange_lf = a2 - 600;
    }
    else if ( (unsigned __int8)a1 < 3u )
    {
      if ( curr_meas_mode != MM_ACV || curr_meas_range != 3 )
        cal_ac_factor_fullrange = a2 - 50000;
      else
        cal_ac_factor_fullrange = a2 - 6000;
    }
    else if ( a1 == 4 )
    {
      if ( curr_meas_mode != MM_ACV || curr_meas_range != 3 )
        cal_ac_factor_fullrange_lf = a2 - 50000;
      else
        cal_ac_factor_fullrange_lf = a2 - 6000;
    }
  }
  cal_save_ac_factor(curr_meas_mode, curr_meas_range, a1);
}

//----- (0800F9B4) --------------------------------------------------------
void __fastcall cal_calc_gain_from_gain_accu()
{
  char v0; // r0@0

  if ( curr_meas_mode == MM_DCV )
    goto LABEL_29;
  if ( curr_meas_mode == MM_ACV )
    goto LABEL_27;
  if ( curr_meas_mode == MM_DCmV )
  {
LABEL_29:
    if ( curr_meas_range == 3 )
      cal_set_curr_gain_div_by_6000();
    else
      cal_set_curr_gain_div_by_50000();
    return;
  }
  if ( curr_meas_mode == MM_ACmV )
  {
LABEL_27:
    if ( input_1ms_peak_enabled )
    {
      cal_set_curr_gain_div_by_42426();
      return;
    }
    goto LABEL_29;
  }
  if ( curr_meas_mode == MM_TEMP )
    goto LABEL_45;
  if ( curr_meas_mode == MM_OHMS )
  {
    cal_set_curr_gain_div_by_50000();
    return;
  }
  if ( curr_meas_mode == MM_CONTINUITY )
    goto LABEL_45;
  if ( curr_meas_mode == MM_DIODE )
  {
    call_set_curr_gain_div_by_30000();
    return;
  }
  if ( curr_meas_mode == MM_CAP )
  {
    if ( curr_meas_range == 5 )
      cal_set_curr_gain_div_by_n(0.0, 1000.0);
    else
      cal_set_curr_gain_div_by_n(0.0, 10000.0);
    return;
  }
  if ( curr_meas_mode == MM_ACuVA )
    goto LABEL_19;
  if ( curr_meas_mode == MM_ACmVA )
    goto LABEL_20;
  if ( curr_meas_mode == MM_ACVA )
  {
LABEL_21:
    if ( v0 )
    {
      if ( (signed int)curr_meas_range >= 2 )
        cal_set_curr_gain_div_by_10000();
      else
        cal_set_curr_gain_div_by_50000();
    }
    else
    {
      cal_set_curr_gain_div_by_50000();
    }
    return;
  }
  if ( (unsigned int)(unsigned __int8)curr_meas_mode - MM_ACuA <= 3 )
  {
LABEL_45:
    cal_set_curr_gain_div_by_50000();
    return;
  }
  if ( (unsigned int)(unsigned __int8)curr_meas_mode - MM_ACA > 1 )
  {
    if ( curr_meas_mode != MM_DCuVA )
    {
      if ( curr_meas_mode != MM_DCmVA )
      {
        if ( curr_meas_mode != MM_DCVA )
          return;
        goto LABEL_21;
      }
LABEL_20:
      cal_set_curr_gain_div_by_50000();
      return;
    }
LABEL_19:
    cal_set_curr_gain_div_by_50000();
    return;
  }
  if ( curr_meas_range == 2 )
    cal_set_curr_gain_div_by_10000();
  else
    cal_set_curr_gain_div_by_50000();
}
// 20003B4F: using guessed type char input_1ms_peak_enabled;

//----- (0800FAFC) --------------------------------------------------------
void __fastcall cal_set_curr_gain_div_by_n(float a1, float num)
{
  cal_curr_gain_val = fp_div(cal_curr_gain_accu_float, num);
}

//----- (0800FB16) --------------------------------------------------------
void __fastcall cal_set_curr_gain_div_by_50000()
{
  cal_curr_gain_val = fp_div(cal_curr_gain_accu_float, 50000.0);
}

//----- (0800FB3C) --------------------------------------------------------
void __fastcall call_set_curr_gain_div_by_30000()
{
  cal_curr_gain_val = fp_div(cal_curr_gain_accu_float, 30000.0);
}

//----- (0800FB5C) --------------------------------------------------------
void __fastcall cal_set_curr_gain_div_by_10000()
{
  cal_curr_gain_val = fp_div(cal_curr_gain_accu_float, 10000.0);
}

//----- (0800FB76) --------------------------------------------------------
void __fastcall cal_set_curr_gain_div_by_6000()
{
  cal_curr_gain_val = fp_div(cal_curr_gain_accu_float, 6000.0);
}

//----- (0800FB90) --------------------------------------------------------
void cal_set_curr_gain_div_by_42426(void)
{
  double v0; // r0@1
  double v1; // r0@1

  v0 = dp_from_fp(cal_curr_gain_accu_float);
  v1 = dp_div(v0, 42426.4068);
  cal_curr_gain_val = fp_from_dp(v1);
}

//----- (0800FBB4) --------------------------------------------------------
void __fastcall meas_setup_hw(meter_meas_mode mode, char range)
{
  meas_hw_turn_on_4V_supply();
  meas_hw_set_ac_rms_filter_ctl(mode);
  high_voltage_diode = 0;
  meas_hw_set_hv_diode(mode);
  meas_hw_set_fre_ctl(mode);
  meas_hw_set_va_ctl_useless(mode);
  meas_hw_set_temp_ctl(mode);
  meas_hw_set_amp_amplifier_power(mode);
  meas_hw_set_amp_x10(mode, range);
}
// 20003B32: using guessed type char lowz_measuring_ac;
// 20003B4B: using guessed type char high_voltage_diode;

//----- (0800FC34) --------------------------------------------------------
void __fastcall meas_hw_set_ac_rms_filter_ctl(meter_meas_mode mode)
{
  // CTL_A: when 0, uses switch X of U16 to connect the RMS output to the HY PB7
  // CTL_E/D:
  // * 0, RMS_IN and 1kHz filter input unconnected
  // * 1, AC connected to RMS chip
  // * 2, AC connected to OP2O on HY, input of 1kHz filter,
  //      output of 1kHz filter connected to RMS chip
  // * 3, RMS_IN and 1kHz filter input unconnected
  if ( mode != MM_ACuA
    && mode != MM_ACmA
    && mode != MM_ACA
    && mode != MM_ACV
    && mode != MM_ACmV
    && mode
    && mode != MM_ACuVA
    && mode != MM_ACmVA
    && mode != MM_ACVA )
  {
    LOWORD(GPIOD.BSRR) = 1;                     // turn on PD0 (CTL_A)
    LOWORD(GPIOF.BSRR) = 32;                    // turn on PF5 (CTL_E)
  }
  else if ( (mode == MM_ACuA || mode == MM_ACmA || mode == MM_ACA || mode == MM_ACV || mode == MM_ACmV)
         && input_lpf_enabled )
  {
    HIWORD(GPIOD.BSRR) = 1;                     // turn off PD0 (CTL_A)
    GPIOF.BSRR = 0x100020;                      // turn off PF4 (CTL_D) and on PF5 (CTL_E)
  }
  else
  {
    HIWORD(GPIOD.BSRR) = 1;                     // turn off PD0 (CTL_A)
    GPIOF.BSRR = 0x200010;                      // turn off PF5 (CTL_E) and on PF4 (CTL_D)
  }
  // use switch Y of U16 to connect a 1.5nF between the HY PB0
  // and input ground on OHMS mode
  if ( mode == MM_OHMS )
    HIWORD(GPIOC.BSRR) = 0x800;                 // turn off PC11 (CTL_B)
  else
    LOWORD(GPIOC.BSRR) = 0x800;                 // turn on PC11 (CTL_B)
  // sets DCmV_CTL which is only connected to the unpopulated U14
  if ( mode == MM_ACV )
    HIWORD(GPIOD.BSRR) = 0x80;                  // turn off PD7 (DCmV_CTL)
  else
    LOWORD(GPIOD.BSRR) = 0x80;                  // turn on PD7 (DCmV_CTL)
}
// 20003B51: using guessed type char input_lpf_enabled;
// 40020800: using guessed type GPIO_REGS GPIOC;
// 40020C00: using guessed type GPIO_REGS GPIOD;
// 40021800: using guessed type GPIO_REGS GPIOF;

//----- (0800FD18) --------------------------------------------------------
void __fastcall meas_hw_set_hv_diode(meter_meas_mode mode)
{
  // If in the high voltage diode range, ENB is asserted
  // which switches on U10 which generates the 15V test voltage

  // Also sets LED_CK which sets switches Y and Z of U9 to position 1.

  // The diode is then connected to the V jack which is connected
  // * to R_RLD via range switch contacts 36 and 37
  // * to the test voltage via switch Y on U9 in pos. 1
  // * to input ground via switch Z on U9 in pos. 1 thru a 910K resistor
  // * to the other side of the diode through the ground jack

  // The voltage is measured at the V jack using HY3131 PA8 (probably).
  if ( mode == MM_DIODE && high_voltage_diode )
  {
    HIWORD(GPIOE.BSRR) = 0x8000u;               // turn off PE15 (LED_CK)
    LOWORD(GPIOF.BSRR) = 0x40;                  // turn on PF6 (ENB)
  }
  else
  {
    LOWORD(GPIOE.BSRR) = 0x8000u;               // turn on PE15 (LED_CK)
    HIWORD(GPIOF.BSRR) = 0x40;                  // turn off PF6 (ENB)
  }
}
// 20003B4B: using guessed type char high_voltage_diode;
// 40021000: using guessed type GPIO_REGS GPIOE;
// 40021800: using guessed type GPIO_REGS GPIOF;

//----- (0800FD5C) --------------------------------------------------------
void __fastcall meas_hw_set_va_ctl_useless(meter_meas_mode mode)
{
  // asserts VA_CTL in ACmVA and ACVA modes
  // which isn't actually connected to anything
  // (would be U14 but it's not populated)

  if ( mode != MM_ACmVA && mode != MM_ACVA )
    LOWORD(GPIOA.BSRR) = 0x800;                 // turn on PA11 (VA_CTL)
  else
    HIWORD(GPIOA.BSRR) = 0x800;                 // turn off PA11 (VA_CTL)
}

//----- (0800FD84) --------------------------------------------------------
void __fastcall meas_hw_set_temp_ctl(meter_meas_mode mode)
{
  // asserts TEMP_CTL in TEMP mode, which sets switch Z of U16 to pos. 0

  // Connects VDD to TEMP_OL and then the V jack through 21Mohm of resistors. Must be for detecting open leads
  if ( mode == MM_TEMP )
    LOWORD(GPIOH.BSRR) = 4;                     // turn on PH2 (TEMP_CTL)
  else
    HIWORD(GPIOH.BSRR) = 4;                     // turn off PH2 (TEMP_CTL)
}
// 40021400: using guessed type GPIO_REGS GPIOH;

//----- (0800FD9E) --------------------------------------------------------
void __fastcall meas_hw_set_fre_ctl(meter_meas_mode mode)
{
  // when in a frequency related mode, asserts FRE_CTL

  // This sets Switch X on U9 to position 1.
  // The frequency source is connected to the V jack which is connected
  // * to R_RLD via range switch contacts 36 and 37
  // * to RLD through switch Y on U9 in pos. 0
  // * to RLD1 through switch X on U9 set to pos. 1
  // * to the HY's CNT input through some filter
  if ( mode != MM_HZ && mode != MM_mSEC && mode != MM_DUTY )
    LOWORD(GPIOA.BSRR) = 0x1000;                // turn on PA12 (FRE_CTL)
  else
    HIWORD(GPIOA.BSRR) = 0x1000;                // turn off PA12 (FRE_CTL)
}

//----- (0800FDC8) --------------------------------------------------------
void meas_hw_turn_on_4V_supply()
{
  // enable U13, the regulator for the 4V analog supply
  // this is PD1, labeled PWR_CTL2 on the schematic
  LOWORD(GPIOD.BSRR) = 2;
}
// 40020C00: using guessed type GPIO_REGS GPIOD;

//----- (0800FDDC) --------------------------------------------------------
void __fastcall meas_hw_set_amp_amplifier_power(meter_meas_mode mode)
{
  // if in an amp mode, the x10 voltage amplifier's
  // shutdown input is deasserted
  if ( mode != MM_ACuA
    && mode != MM_ACmA
    && mode != MM_ACA
    && mode != MM_DCuA
    && mode != MM_DCmA
    && mode != MM_DCA
    && mode != MM_ACuVA
    && mode != MM_ACmVA
    && mode != MM_ACVA
    && mode != MM_DCuVA
    && mode != MM_DCmVA
    && mode != MM_DCVA )
    HIWORD(GPIOE.BSRR) = 0x1000;                // turn off PE12 (SHDN_A)
  else
    LOWORD(GPIOE.BSRR) = 0x1000;                // turn on PE12 (SHDN_A)
}
// 40021000: using guessed type GPIO_REGS GPIOE;

//----- (0800FE48) --------------------------------------------------------
void __fastcall meas_hw_set_amp_x10(meter_meas_mode mode, char range)
{
  // This enables reading the x10 amp amplifier on low amp ranges

  // when PE5 is turned on, switch Y of U11 is at pos. 0 and connects X10 to the HY
  // otherwise, X1 is connected
  if ( mode != MM_ACuA && mode != MM_ACmA && mode != MM_ACA && mode != MM_DCuA && mode != MM_DCmA && mode != MM_DCA )
  {
    if ( mode != MM_ACuVA
      && mode != MM_ACmVA
      && mode != MM_ACVA
      && mode != MM_DCuVA
      && mode != MM_DCmVA
      && mode != MM_DCVA )
    {
      LOWORD(GPIOE.BSRR) = 32;                  // turn on PE5 (A_CTL)
    }
    else if ( curr_power_amps_range )
    {
      HIWORD(GPIOE.BSRR) = 32;                  // turn off PE5 (A_CTL)
    }
    else
    {
      LOWORD(GPIOE.BSRR) = 32;                  // turn on PE5 (A_CTL)
    }
  }
  else if ( range )
  {
    HIWORD(GPIOE.BSRR) = 32;                    // turn off PE5 (A_CTL)
  }
  else
  {
    LOWORD(GPIOE.BSRR) = 32;                    // turn on PE5 (A_CTL)
  }
}
// 20003B5C: using guessed type char curr_power_amps_range;
// 40021000: using guessed type GPIO_REGS GPIOE;

//----- (0800FEEC) --------------------------------------------------------
void rtc_read_time()
{
  unsigned __int8 v0; // r4@1
  unsigned __int8 v1; // r4@7
  unsigned __int8 v2; // r4@13
  unsigned __int8 v3; // r0@19
  unsigned __int8 v4; // r0@23
  unsigned __int8 v5; // r4@27

  v0 = rtc_read_reg(RTC_REG_YEAR);
  if ( v0 && (signed int)v0 < 0x9A )
  {
    curr_year = bcd2_to_int(v0);
    if ( !curr_year || (signed int)curr_year >= 100 )
      curr_year = 16;
  }
  else
  {
    curr_year = 16;
  }
  spinloop(5u);
  v1 = rtc_read_reg(RTC_REG_MONTH);
  if ( v1 && (signed int)v1 < 0x13 )
  {
    curr_month = bcd2_to_int(v1);
    if ( !curr_month || (signed int)curr_month >= 13 )
      curr_month = 7;
  }
  else
  {
    curr_month = 7;
  }
  spinloop(5u);
  v2 = rtc_read_reg(RTC_REG_DAY);
  if ( v2 && (signed int)v2 < 0x32 )
  {
    curr_day = bcd2_to_int(v2);
    if ( !curr_day || (signed int)curr_day >= 32 )
      curr_day = 1;
  }
  else
  {
    curr_day = 1;
  }
  spinloop(5u);
  v3 = rtc_read_reg(RTC_REG_HOUR);
  if ( (signed int)v3 >= 0x24 )
  {
    curr_hour = 12;
  }
  else
  {
    curr_hour = bcd2_to_int(v3);
    if ( (signed int)curr_hour >= 24 )
      curr_hour = 12;
  }
  spinloop(5u);
  v4 = rtc_read_reg(RTC_REG_MINUTE);
  if ( (signed int)v4 >= 0x5A )
  {
    curr_minute = 0;
  }
  else
  {
    curr_minute = bcd2_to_int(v4);
    if ( (signed int)curr_minute >= 60 )
      curr_minute = 0;
  }
  spinloop(5u);
  v5 = rtc_read_reg(RTC_REG_SECOND);
  if ( rtc_last_read_seconds != v5 )
  {
    rtc_last_read_seconds = v5;
    rtc_last_read_was_new_second = 1;
  }
  if ( (signed int)v5 >= 0x5A )
  {
    curr_second = 0;
  }
  else
  {
    curr_second = bcd2_to_int(v5);
    if ( (signed int)curr_second >= 60 )
      curr_second = 0;
  }
}
// 20003B66: using guessed type char rtc_last_read_was_new_second;

//----- (080100B4) --------------------------------------------------------
unsigned __int8 __fastcall bcd2_to_int(unsigned __int8 bcd)
{
  return (bcd & 0xF) + 10 * (bcd >> 4);
}

//----- (080100D8) --------------------------------------------------------
unsigned __int8 __fastcall int_to_bcd2(unsigned __int8 a1)
{
  return (unsigned __int16)(a1 % 10) + 16 * (a1 / 10);
}

//----- (08010106) --------------------------------------------------------
void rtc_write_time()
{
  rtc_write_reg(RTC_REG_YEAR, curr_year);
  rtc_write_reg(RTC_REG_MONTH, curr_month);
  rtc_write_reg(RTC_REG_DAY, curr_day);
  rtc_write_reg(RTC_REG_HOUR, curr_hour);
  rtc_write_reg(RTC_REG_MINUTE, curr_minute);
  rtc_write_reg(RTC_REG_SECOND, curr_second);
}

//----- (08010154) --------------------------------------------------------
void __fastcall rtc_write_reg(RTC_REGS loc, unsigned __int8 data)
{
  unsigned __int8 v3; // r6@1

  v3 = int_to_bcd2(data);
  rtc_select_chip();
  spinloop(5u);
  rtc_send_reg_number((RTC_REGS)(loc + 1));
  rtc_send_data(v3);
  spinloop(5u);
  rtc_deselect_chip();
}

//----- (0801018A) --------------------------------------------------------
_BYTE __fastcall rtc_read_reg(RTC_REGS loc)
{
  char v2; // r5@1

  rtc_select_chip();
  rtc_send_reg_number(loc);
  v2 = rtc_recv_data();
  rtc_deselect_chip();
  return v2;
}

//----- (080101AC) --------------------------------------------------------
void __fastcall rtc_send_reg_number(RTC_REGS loc)
{
  unsigned __int8 i; // r5@1

  for ( i = 0; (signed int)i < 4; ++i )
  {
    if ( (((signed int)(unsigned __int8)loc >> i) & 1) == 1 )
      LOWORD(GPIOB.BSRR) = 128;                 // send this bit
    else
      HIWORD(GPIOB.BSRR) = 128;
    LOWORD(GPIOB.BSRR) = 64;                    // pulse clock
    spinloop(5u);
    HIWORD(GPIOB.BSRR) = 64;
    spinloop(5u);
  }
}
// 40020400: using guessed type GPIO_REGS GPIOB;

//----- (080101F8) --------------------------------------------------------
_BYTE rtc_recv_data()
{
  unsigned int v0; // r5@1
  unsigned __int8 i; // r4@1

  LOBYTE(v0) = 0;
  spinloop(5u);
  rtc_config_data_input();
  spinloop(5u);
  for ( i = 0; (signed int)i < 8; ++i )
  {
    LOWORD(GPIOB.BSRR) = 64;
    spinloop(5u);
    if ( GPIOB.IDR & 0x80 )
      LOBYTE(v0) = v0 | 0x80;
    HIWORD(GPIOB.BSRR) = 64;
    spinloop(5u);
    if ( (signed int)i < 7 )
      v0 = (unsigned int)(unsigned __int8)v0 >> 1;
  }
  rtc_config_data_output();
  spinloop(5u);
  return v0;
}
// 40020400: using guessed type GPIO_REGS GPIOB;

//----- (0801025C) --------------------------------------------------------
void __fastcall rtc_send_data(unsigned __int8 data)
{
  unsigned __int8 i; // r5@1

  for ( i = 0; (signed int)i < 8; ++i )
  {
    HIWORD(GPIOB.BSRR) = 64;
    spinloop(5u);
    if ( (((signed int)data >> i) & 1) == 1 )
      LOWORD(GPIOB.BSRR) = 128;
    else
      HIWORD(GPIOB.BSRR) = 128;
    LOWORD(GPIOB.BSRR) = 64;
    spinloop(5u);
  }
}
// 40020400: using guessed type GPIO_REGS GPIOB;

//----- (080102A8) --------------------------------------------------------
void rtc_select_chip()
{
  HIWORD(GPIOB.BSRR) = 128;                     // turn off output (PB7)
  LOWORD(GPIOC.BSRR) = 0x2000;                  // assert chip sdelect (PC13)
}
// 40020400: using guessed type GPIO_REGS GPIOB;
// 40020800: using guessed type GPIO_REGS GPIOC;

//----- (080102BE) --------------------------------------------------------
void rtc_deselect_chip()
{
  HIWORD(GPIOB.BSRR) = 128;                     // turn off data output (PB7)
  HIWORD(GPIOC.BSRR) = 0x2000;                  // deassert chip select (PC13)
}
// 40020400: using guessed type GPIO_REGS GPIOB;
// 40020800: using guessed type GPIO_REGS GPIOC;

//----- (080102D4) --------------------------------------------------------
void rtc_config_data_output()
{
  GPIO_CONFIG cfg; // [sp+0h] [bp-10h]@1

  cfg.pins = 128;                               // PB7
  cfg.mode = 1;                                 // output
  cfg.pull = 0;                                 // no pullup/down
  *(_WORD *)&cfg.speed = 1;                     // 'medium' speed, push-pull output
  gpio_config_pin(&GPIOB, &cfg);
}
// 40020400: using guessed type GPIO_REGS GPIOB;

//----- (080102FE) --------------------------------------------------------
void rtc_config_data_input()
{
  GPIO_CONFIG cfg; // [sp+0h] [bp-10h]@1

  cfg.pins = 0x80;                              // PB7
  *(_WORD *)&cfg.mode = 0x300;                  // Mode = input
  cfg.pull = 1;                                 // pull-up
  gpio_config_pin(&GPIOB, &cfg);
}
// 40020400: using guessed type GPIO_REGS GPIOB;

//----- (08010340) --------------------------------------------------------
unsigned __int8 __fastcall get_days_in_month_without_going_over(unsigned __int8 year, unsigned __int8 month, unsigned __int8 curr_day)
{
  unsigned int v4; // r0@1

  LOBYTE(v4) = get_days_in_month(year, month);
  if ( v4 < curr_day )
    curr_day = v4;
  return curr_day;
}

//----- (0801036E) --------------------------------------------------------
unsigned __int8 __fastcall get_days_in_month(unsigned __int8 year, unsigned __int8 month)
{
  unsigned int v2; // r3@1
  char days_in_month[12]; // [sp+0h] [bp-18h]@1

  *(_DWORD *)days_in_month = 0x1E1F1C1F;
  *(_DWORD *)&days_in_month[4] = 0x1F1F1E1F;
  *(_DWORD *)&days_in_month[8] = 0x1F1E1F1E;
  v2 = year + 2000;
  if ( !(v2 % 4) && v2 % 100 || !(v2 % 400) )
    days_in_month[1] = 29;
  return days_in_month[month - 1];
}

//----- (08010460) --------------------------------------------------------
void __cdecl fp_compare_c_ge(float a, float b)
{
  ;                                             // performs signed comparison and returns result in status bits
                                                // Z = 1 iff a == b
                                                // C = 1 if a >= b
                                                // C = 0 if a < b
}

//----- (08010484) --------------------------------------------------------
void __fastcall fp_compare_c_le(float a, float b)
{
  ;                                             // performs signed comparison and returns result in status bits
                                                // Z = 1 iff a == b
                                                // C = 1 if a <= b
                                                // C = 0 if a > b
}

//----- (080104A8) --------------------------------------------------------
unsigned int __fastcall fp_to_uint(float a1)
{
  unsigned __int8 neg; // cf@1
  unsigned int num; // r0@1
  int v3; // r1@3
  unsigned int result; // r0@4

  neg = __CFSHL__(LODWORD(a1), 1);
  num = 2 * LODWORD(a1);
  if ( neg || (((num >> 24) - 127) & 0x80000000) != 0 )// number is negative or < 1
  {
    result = 0;
  }
  else
  {
    v3 = 158 - (num >> 24);
    if ( v3 < 0 )                               // number is bigger than a uint can hold
      result = -1;
    else
      result = ((num << 7) | 0x80000000) >> v3;
  }
  return result;
}

//----- (080104CC) --------------------------------------------------------
float __fastcall fp_mul(float a, float b)
{
  int bexp; // r3@0
  char v3; // zf@1
  int aexp; // r12@1
  int endexp; // r12@7
  float v6; // r2@7
  unsigned int asig; // r0@7
  unsigned int bsig; // r1@7
  unsigned int v9; // r0@8
  unsigned int v10; // kr00_4@8
  unsigned __int8 v11; // cf@8
  int v12; // r1@10
  float result; // r0@12
  char v14; // r12@13
  unsigned __int8 v15; // vf@13
  int v16; // r1@13
  char v17; // zf@15
  int v18; // r0@18
  int v19; // r1@19
  unsigned int v20; // r1@22
  unsigned int v21; // r3@22
  unsigned int v22; // r0@23
  unsigned int v23; // r12@23
  int v24; // r0@25
  int v25; // r1@26
  unsigned __int8 v26; // cf@27
  char v27; // zf@27

  aexp = (LODWORD(a) >> 23) & 0xFF;
  v3 = aexp == 0;
  if ( aexp )
  {
    bexp = (LODWORD(b) >> 23) & 0xFF;
    v3 = bexp == 0;
  }
  if ( !v3 )
  {
    v3 = aexp == 255;
    if ( aexp != 255 )
      v3 = bexp == 255;
  }
  if ( !v3 )
  {
    endexp = aexp + bexp;
    LODWORD(v6) = (LODWORD(a) ^ LODWORD(b)) & 0x80000000;
    asig = (LODWORD(a) << 8) | 0x80000000;
    bsig = (LODWORD(b) << 8) | 0x80000000;
    goto LABEL_8;
  }
  v17 = aexp == 255;
  if ( aexp != 255 )
  {
    bexp = (LODWORD(b) >> 23) & 0xFF;
    v17 = bexp == 255;
  }
  LODWORD(v6) = (LODWORD(a) ^ LODWORD(b)) & 0x80000000;
  if ( !v17 )
  {
    v18 = 2 * LODWORD(a);
    if ( !v18 )
      return v6;
    v19 = 2 * LODWORD(b);
    if ( !v19 )
      return v6;
    if ( bexp )
    {
      v22 = v18 << 8;
      v23 = __clz(v22);
      asig = v22 << v23;
      endexp = bexp - v23;
      bsig = (v19 << 7) | 0x80000000;
    }
    else
    {
      if ( 0 == aexp )
        return v6;
      v20 = v19 << 8;
      v21 = __clz(v20);
      bsig = v20 << v21;
      endexp = aexp - v21;
      asig = (v18 << 7) | 0x80000000;
    }
LABEL_8:
    v10 = bsig * asig;
    v9 = bsig * (unsigned __int64)asig >> 32;
    v11 = __CFSHL__(v9, 1);
    if ( !__CFSHL__(v9, 1) )
      v9 *= 2;
    v12 = endexp - (!v11 + 127);
    if ( !((endexp - (!v11 + 127) < 0) ^ __OFADD__(endexp, v11 - 128)) )
    {
      if ( v12 < 254 )
      {
        LODWORD(result) = (v9 >> 8) + __CFSHR__(v9, 8) + (LODWORD(v6) | (v12 << 23));
        return result;
      }
      goto LABEL_30;
    }
    v14 = 8 - v12;
    v15 = __OFSUB__(32, 8 - v12);
    v16 = v12 + 24;
    if ( !((v16 < 0) ^ v15) )
    {
      LODWORD(result) = LODWORD(v6) + __CFADD__((v10 >> 1) | (v9 << v16), __CFSHL__(v9, v16) + 0x7FFFFFFF) + (v9 >> v14);
      return result;
    }
    return v6;
  }
  v24 = 2 * LODWORD(a);
  if ( v24 )
  {
    v25 = 2 * LODWORD(b);
    if ( v25 )
    {
      v26 = __CFADD__(v24, 0x1000000);
      v27 = v24 == -16777216;
      if ( (unsigned int)v24 <= 0xFF000000 )
      {
        v26 = __CFADD__(v25, 0x1000000);
        v27 = v25 == -16777216;
      }
      if ( !(!v27 & v26) )
      {
LABEL_30:
        LODWORD(result) = LODWORD(v6) | 0x7F800000;
        return result;
      }
    }
  }
  LODWORD(result) = ~LODWORD(v6);
  return result;
}

//----- (080105A4) --------------------------------------------------------
void __cdecl check_on_batt_and_internal_temp()
{
  ++cobait_timer;
  if ( (signed int)(unsigned __int8)cobait_timer >= 2 )
    cobait_timer = 0;
  if ( cobait_timer )
  {
    if ( cobait_timer == 1 )
      read_batt_level();
  }
  else
  {
    prob_read_internal_temp();
  }
}
// 20003B21: using guessed type char cobait_timer;

//----- (080105DE) --------------------------------------------------------
void read_batt_level()
{
  unsigned int v0; // r4@1
  int v1; // r0@5

  curr_adc_val_for_batt_level_and_internal_temp = prob_read_adc1_ch(1);
  powerdown_adc1();
  v0 = (unsigned __int16)curr_adc_val_for_batt_level_and_internal_temp;
  if ( (signed int)(unsigned __int16)curr_adc_val_for_batt_level_and_internal_temp < 1020 )
    v0 = 1020;
  if ( (signed int)(unsigned __int16)curr_adc_val_for_batt_level_and_internal_temp > 3120 )
    v0 = 3120;
  v1 = batt_level_adjust(v0);
  curr_batt_charge = batt_level_avg(v1) / 10;
  bat_is_low = (signed int)(unsigned __int16)curr_batt_charge < 41;
  if ( curr_sub_mode == SM_BATTERY )
    need_to_update_subscr = 1;
  if ( (unsigned __int8)bat_is_low == (unsigned __int8)batt_is_low_icon )
  {
    batt_really_is_low_timer = 0;
  }
  else
  {
    ++batt_really_is_low_timer;
    if ( (signed int)batt_really_is_low_timer >= 11 )
    {
      batt_is_low_icon = bat_is_low;
      batt_really_is_low_timer = 0;
      scr_update_low_batt_icon(1);
    }
  }
}
// 20003A6E: using guessed type __int16 curr_batt_charge;
// 20003A84: using guessed type __int16 curr_adc_val_for_batt_level_and_internal_temp;
// 20003A9B: using guessed type char bat_is_low;
// 20003ADF: using guessed type char batt_is_low_icon;
// 20003AFE: using guessed type char need_to_update_subscr;

//----- (080106B0) --------------------------------------------------------
unsigned int __fastcall batt_level_avg(int a1)
{
  unsigned int v1; // r6@1
  unsigned int i; // r5@2
  unsigned int j; // r5@5
  unsigned int v4; // r7@8
  unsigned int k; // r5@9

  v1 = 0;
  if ( batt_level_avg_count == 20 )
  {
    for ( i = 1; i < (unsigned __int16)batt_level_avg_count; ++i )
      batt_level_avg_buf[(unsigned __int16)batt_level_avg_count - i] = batt_level_avg_buf[(unsigned __int16)batt_level_avg_count
                                                                                        - 1
                                                                                        - i];
    batt_level_avg_buf[0] = a1;
    batt_level_avg_sort_buf();
    for ( j = 5; j < (unsigned int)(unsigned __int16)batt_level_avg_count - 5; ++j )
      v1 += batt_level_avg_buf_sorted[j];
    v4 = v1 / ((unsigned int)(unsigned __int16)batt_level_avg_count - 10);
  }
  else
  {
    batt_level_avg_buf[(unsigned __int16)batt_level_avg_count] = a1;
    for ( k = 0; (unsigned __int16)batt_level_avg_count >= k; ++k )
      v1 += batt_level_avg_buf[k];
    v4 = v1 / ((unsigned int)(unsigned __int16)batt_level_avg_count + 1);
  }
  ++batt_level_avg_count;
  if ( (signed int)(unsigned __int16)batt_level_avg_count >= 21 )
    batt_level_avg_count = 20;
  return v4;
}
// 20003A70: using guessed type __int16 batt_level_avg_count;

//----- (08010786) --------------------------------------------------------
void batt_level_avg_sort_buf()
{
  unsigned __int8 maxi; // r2@1
  unsigned __int8 i; // r3@1
  unsigned __int8 j; // r1@4
  unsigned int max; // r0@6
  unsigned __int8 k; // r3@6
  unsigned __int8 l; // r3@12
  int tmp[20]; // [sp+0h] [bp-58h]@11

  maxi = 0;
  for ( i = 0; (signed int)i < 20; ++i )
    batt_level_avg_buf_sorted[i] = batt_level_avg_buf[i];
  for ( j = 0; (signed int)j < 20; ++j )
  {
    max = 0;
    for ( k = 0; (signed int)k < 20; ++k )
    {
      if ( batt_level_avg_buf_sorted[k] >= max )
      {
        max = batt_level_avg_buf_sorted[k];
        maxi = k;
      }
    }
    batt_level_avg_buf_sorted[maxi] = 0;
    tmp[j] = max;
  }
  for ( l = 0; (signed int)l < 20; ++l )
    batt_level_avg_buf_sorted[l] = tmp[l];
}

//----- (08010824) --------------------------------------------------------
int __fastcall batt_level_adjust(unsigned int a1)
{
  char v1; // r6@1
  unsigned __int8 v2; // r5@1
  float v3; // r9@6
  float v4; // r0@6
  float v5; // r0@6

  v1 = 1;
  v2 = 0;
  while ( v1 )
  {
    if ( a1 >= batt_level_offset_factor_tbl[v2] )
      v1 = 0;
    else
      ++v2;
  }
  v3 = fp_from_uint(50 * (a1 - batt_level_offset_factor_tbl[v2]));
  v4 = fp_from_uint(batt_level_offset_factor_tbl[v2 - 1] - batt_level_offset_factor_tbl[v2]);
  v5 = fp_div(v3, v4);
  return 1050 - 50 * v2 + fp_to_int(v5);
}

//----- (080108B0) --------------------------------------------------------
int __fastcall prob_read_adc1_ch(char a1)
{
  char v1; // r4@1

  v1 = a1;
  set_APB2_periph_clock(512, 1);
  enable_adc(&ADC1_BASE, 1);
  while ( !and_bool_low16(&ADC1_BASE, 0x40u) )
    ;
  if ( v1 == 1 )
    sub_801C894((int)&ADC1_BASE, 5u, 1u, 7u);
  else
    sub_801C894((int)&ADC1_BASE, 4u, 1u, 7u);
  sub_801CA52((int)&ADC1_BASE);
  while ( !and_bool_low16(&ADC1_BASE, 2u) )
    ;
  return sub_801CA5C((int)&ADC1_BASE);
}
// 40012400: using guessed type ADC_REGS ADC1_BASE;

//----- (0801091A) --------------------------------------------------------
void __cdecl prob_read_internal_temp()
{
  curr_adc_val_for_batt_level_and_internal_temp = prob_read_adc1_ch(0);
  powerdown_adc1();
  if ( (signed int)(unsigned __int16)curr_adc_val_for_batt_level_and_internal_temp < 0x8000 )
  {
    calc_internal_temp(curr_adc_val_for_batt_level_and_internal_temp);
    if ( curr_sub_mode == SM_TEMP )
      need_to_update_subscr = 1;
  }
}
// 20003A84: using guessed type __int16 curr_adc_val_for_batt_level_and_internal_temp;
// 20003AFE: using guessed type char need_to_update_subscr;

//----- (08010956) --------------------------------------------------------
void __fastcall calc_internal_temp(__int16 adc)
{
  signed __int16 v1; // r5@1
  signed int v2; // r8@1
  unsigned int i; // r9@6
  unsigned int j; // r9@9
  unsigned int k; // r9@13
  char v6; // r6@25
  int v7; // r7@25

  v1 = 0;
  v2 = 0;
  curr_internal_temp_adc = adc;
  if ( (signed int)(unsigned __int16)adc >= 51 )
  {
    curr_internal_temp_invalid_timer = 0;
    curr_internal_temp_invalid = 0;
    if ( curr_internal_temp_avg_count == 10 )
    {
      for ( i = 1; i < (unsigned __int16)curr_internal_temp_avg_count; ++i )
        curr_internal_temp_avg_buf[(unsigned __int16)curr_internal_temp_avg_count - i] = curr_internal_temp_avg_buf[(unsigned __int16)curr_internal_temp_avg_count - 1 - i];
      curr_internal_temp_avg_buf[0] = curr_internal_temp_adc;
      for ( j = 0; j < (unsigned __int16)curr_internal_temp_avg_count; ++j )
        v2 += (unsigned __int16)curr_internal_temp_avg_buf[j];
      curr_internal_temp_avg = v2 / (unsigned __int16)curr_internal_temp_avg_count;
    }
    else
    {
      curr_internal_temp_avg_buf[(unsigned __int16)curr_internal_temp_avg_count] = curr_internal_temp_adc;
      for ( k = 0; (unsigned __int16)curr_internal_temp_avg_count >= k; ++k )
        v2 += (unsigned __int16)curr_internal_temp_avg_buf[k];
      curr_internal_temp_avg = v2 / ((unsigned __int16)curr_internal_temp_avg_count + 1);
    }
    ++curr_internal_temp_avg_count;
    if ( (signed int)(unsigned __int16)curr_internal_temp_avg_count >= 11 )
      curr_internal_temp_avg_count = 10;
  }
  else
  {
    curr_internal_temp_avg_count = 0;
    ++curr_internal_temp_invalid_timer;
    if ( (signed int)(unsigned __int16)curr_internal_temp_invalid_timer >= 11 )
    {
      curr_internal_temp_invalid_timer = 10;
      curr_internal_temp_invalid = 1;
    }
    v1 = 1;
  }
  if ( !v1 )
  {
    curr_internal_temperature = calc_internal_temp_core(curr_internal_temp_avg);
    if ( meter_in_cal_mode && calibrating_thermistor_23c )
    {
      calibrating_thermistor_23c = 0;
      cal_switch_to_temp_on_subscr_delay = 3;
      cal_internal_thermistor_factor = 2300 - curr_internal_temperature;
      cal_write_factor(0xC8, (signed __int16)(2300 - curr_internal_temperature));
    }
    curr_internal_temperature += cal_internal_thermistor_factor;
    if ( curr_internal_temp_calc_invalid )
    {
      ++curr_internal_temp_calc_invalid_timer;
      if ( (signed int)(unsigned __int8)curr_internal_temp_calc_invalid_timer >= 11 )
      {
        curr_internal_temp_calc_invalid_timer = 10;
        curr_internal_temp_invalid = 1;
      }
    }
    else
    {
      curr_internal_temp_calc_invalid_timer = 0;
      if ( curr_internal_temperature & 0x8000 )
      {
        v6 = 1;
        v7 = ~curr_internal_temperature;
      }
      else
      {
        v6 = 0;
        v7 = curr_internal_temperature;
      }
      temp_load_offset((unsigned __int8)v6, v7 / 10);
    }
  }
  if ( curr_internal_temp_invalid == 1 )
  {
    need_to_update_subscr = 1;
    temp_offset = 0;
  }
}
// 2000395C: using guessed type int temp_offset;
// 20003A72: using guessed type __int16 cal_internal_thermistor_factor;
// 20003A7E: using guessed type __int16 curr_internal_temperature;
// 20003A80: using guessed type __int16 curr_internal_temp_adc;
// 20003A82: using guessed type __int16 curr_internal_temp_avg;
// 20003A86: using guessed type __int16 curr_internal_temp_avg_count;
// 20003A88: using guessed type __int16 curr_internal_temp_invalid_timer;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B30: using guessed type char calibrating_thermistor_23c;
// 20003B31: using guessed type char cal_switch_to_temp_on_subscr_delay;
// 20003B44: using guessed type char curr_internal_temp_invalid;
// 20003B47: using guessed type char curr_internal_temp_calc_invalid;
// 20003B48: using guessed type char curr_internal_temp_calc_invalid_timer;

//----- (08010BB8) --------------------------------------------------------
int __fastcall calc_internal_temp_core(unsigned __int16 a1)
{
  char v1; // r6@1
  unsigned __int8 v2; // r5@3
  float v3; // r9@8
  float v4; // r0@8
  float v5; // r0@8
  __int16 v6; // r8@8

  v1 = 1;
  there_was_a_temp_error = 0;
  if ( (signed int)a1 < 518 || (signed int)a1 >= 3673 )
  {
    v6 = 0;
    curr_internal_temp_calc_invalid = 1;
  }
  else
  {
    v2 = 0;
    while ( v1 )
    {
      if ( a1 >= (unsigned int)internal_temp_offset_factor_tbl[v2] )
        v1 = 0;
      else
        ++v2;
    }
    v3 = fp_from_int(500 * (internal_temp_offset_factor_tbl[v2 - 1] - a1));
    v4 = fp_from_int(internal_temp_offset_factor_tbl[v2 - 1] - internal_temp_offset_factor_tbl[v2]);
    v5 = fp_div(v3, v4);
    v6 = 500 * v2 - 3500 + fp_to_int(v5);
    curr_internal_temp_calc_invalid = 0;
  }
  return v6;
}
// 20003B46: using guessed type char there_was_a_temp_error;
// 20003B47: using guessed type char curr_internal_temp_calc_invalid;

//----- (08010C80) --------------------------------------------------------
int __fastcall temp_conv_c_to_f(int a1)
{
  char was_negative; // r5@2
  float v2; // r0@4
  double v3; // r0@4
  double v4; // r0@4
  float v5; // r0@4
  float v6; // r6@4
  float v7; // r6@5
  unsigned __int8 cf; // cf@6
  char zf; // zf@6
  int v10; // r0@9
  float v11; // r0@9
  float v12; // r0@9

  if ( a1 & 0x8000 )
  {
    was_negative = 1;
    temp_meas_val_in_f = ~a1;
  }
  else
  {
    was_negative = 0;
    temp_meas_val_in_f = a1;
  }
  v2 = fp_from_int(temp_meas_val_in_f);
  v3 = dp_from_fp(v2);
  v4 = dp_mul(v3, 1.8);
  v5 = fp_from_dp(v4);
  v6 = v5;
  if ( was_negative )
  {
    fp_compare_c_le(v5, 3200.0);
    if ( !zf & cf )                             // v5 < 3200
    {
      was_negative = 0;
      v7 = fp_sub(3200.0, v6);
    }
    else
    {
      was_negative = 1;
      v7 = fp_add(-3200.0, v6);
    }
  }
  else
  {
    v7 = fp_add(3200.0, v5);
  }
  v10 = fp_to_int(v7);
  temp_meas_val_in_f = v10;
  v11 = fp_from_int(v10);
  v12 = fp_sub(v7, v11);
  fp_compare_c_le(v12, 0.5);
  if ( !(!zf & cf) )                            // v12 >= 0.5
    ++temp_meas_val_in_f;
  if ( was_negative == 1 )
    temp_meas_val_in_f = ~temp_meas_val_in_f;
  return temp_meas_val_in_f;
}
// 20003968: using guessed type int temp_meas_val_in_f;

//----- (08010D4A) --------------------------------------------------------
void __fastcall meas_calc_temp_from_dcmv(int dcmv)
{
  char v1; // r6@1
  unsigned __int8 v2; // r5@5
  float v3; // r0@10
  int v4; // r0@10

  v1 = 1;
  temp_meas_sign = 0;
  if ( dcmv >= -5891 )
  {
    if ( dcmv < 54139 )
    {
      v2 = 0;
      while ( v1 )
      {
        if ( temp_range_offset_factor_tbl[v2] >= dcmv )
          v1 = 0;
        else
          ++v2;
      }
      temp_meas_val_base = 1000 * v2 - 22000;
      v3 = fp_from_int(1000 * (temp_range_offset_factor_tbl[v2 - 1] - dcmv) / (temp_range_offset_factor_tbl[v2 - 1]
                                                                             - temp_range_offset_factor_tbl[v2]));
      v4 = fp_to_int(v3);
      temp_meas_val_in_f = temp_meas_val_base + v4;
      temp_meas_val = temp_meas_val_base + v4;
    }
    else
    {
      temp_meas_val = 0;
      temp_meas_sign = 1;
    }
  }
  else
  {
    temp_meas_val = 0;
    temp_meas_sign = 2;
  }
}
// 20003960: using guessed type int temp_meas_val;
// 20003964: using guessed type int temp_meas_val_base;
// 20003968: using guessed type int temp_meas_val_in_f;
// 20003B45: using guessed type char temp_meas_sign;

//----- (08010E02) --------------------------------------------------------
void __fastcall temp_load_offset(int temp_is_negative, signed int a2)
{
  int v2; // r2@4
  int v3; // r3@4

  if ( (!(_BYTE)temp_is_negative || a2 < 201) && a2 <= 1000 )
  {
    v2 = a2 / 100;
    v3 = a2 % 100;
    if ( (_BYTE)temp_is_negative )
      temp_offset = temp_range_offset_factor_tbl[(unsigned __int8)(21 - v2)]
                  - v3
                  * (10
                   * (~temp_range_offset_factor_tbl[(unsigned __int8)(21 - v2) - 1]
                    - ~temp_range_offset_factor_tbl[(unsigned __int8)(21 - v2)])
                   / 100)
                  / 10;
    else
      temp_offset = v3
                  * (10
                   * (temp_range_offset_factor_tbl[(unsigned __int8)(v2 + 21) + 1]
                    - temp_range_offset_factor_tbl[(unsigned __int8)(v2 + 21)])
                   / 100)
                  / 10
                  + temp_range_offset_factor_tbl[(unsigned __int8)(v2 + 21)];
  }
}
// 2000395C: using guessed type int temp_offset;

//----- (08010EDE) --------------------------------------------------------
void init_adc_and_stuff()
{
  _BYTE chan[4]; // [sp+0h] [bp-20h]@1
  char v1; // [sp+4h] [bp-1Ch]@1
  char v2; // [sp+5h] [bp-1Bh]@1
  int v3; // [sp+Ch] [bp-14h]@1
  int v4; // [sp+10h] [bp-10h]@1
  char v5; // [sp+14h] [bp-Ch]@1

  reset_adc(&ADC1_BASE);
  *(_DWORD *)chan = 0;
  v1 = 0;
  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 1;
  do_lots_of_adc_config(&ADC1_BASE, chan);
  enable_adc(&ADC1_BASE, 1);
  while ( !and_bool_low16(&ADC1_BASE, 0x40u) )  // wait for adc to be ready
    ;
}
// 40012400: using guessed type ADC_REGS ADC1_BASE;

//----- (08010FCC) --------------------------------------------------------
void __fastcall lcd_set_fcr_and_cr(int a1)
{
  int v1; // r4@1

  v1 = a1;
  LCD_FCR &= 0xFC03FFFF;
  LCD_FCR |= *(_DWORD *)a1 | *(_DWORD *)(a1 + 4);
  lcd_wait_for_FCR_sync();
  LCD_CR &= 0xFFFFFF81;
  LCD_CR |= *(_DWORD *)(v1 + 8) | *(_DWORD *)(v1 + 12) | *(_DWORD *)(v1 + 16);
}
// 40002400: using guessed type int LCD_CR;
// 40002404: using guessed type int LCD_FCR;

//----- (08011012) --------------------------------------------------------
void __fastcall lcd_set_enable(unsigned __int8 result)
{
  v42048000 = result;
}

//----- (0801101A) --------------------------------------------------------
void __fastcall lcd_wait_for_FCR_sync()
{
  int v0; // r0@1

  v0 = 0;
  do
    ++v0;
  while ( v0 != 0x8000 && !(LCD_SR & 0x20) );
}
// 40002408: using guessed type int LCD_SR;

//----- (08011036) --------------------------------------------------------
void __fastcall lcd_set_segment_multiplexing(unsigned __int8 result)
{
  v4204801C = result;
}

//----- (0801103E) --------------------------------------------------------
void __fastcall lcd_set_pulse_on_duration(int result)
{
  LCD_FCR &= 0xFFFFFF8F;
  LCD_FCR |= result;
}
// 40002400: using guessed type int LCD_CR;
// 40002404: using guessed type int LCD_FCR;

//----- (08011056) --------------------------------------------------------
void __fastcall lcd_set_dead_time(int result)
{
  LCD_FCR &= 0xFFFFFC7F;
  LCD_FCR |= result;
}
// 40002400: using guessed type int LCD_CR;
// 40002404: using guessed type int LCD_FCR;

//----- (0801106E) --------------------------------------------------------
void __fastcall lcd_set_blink(int result, int a2)
{
  LCD_FCR &= 0xFFFC1FFF;
  LCD_FCR |= a2 | result;
}
// 40002400: using guessed type int LCD_CR;
// 40002404: using guessed type int LCD_FCR;

//----- (0801108A) --------------------------------------------------------
void __fastcall lcd_set_contrast_reg(int contrast)
{
  LCD_FCR &= 0xFFFFE3FF;
  LCD_FCR |= contrast;
}
// 40002400: using guessed type int LCD_CR;
// 40002404: using guessed type int LCD_FCR;

//----- (080110A2) --------------------------------------------------------
void set_lcd_update_request()
{
  v42048108 = 1;
}

//----- (080110AA) --------------------------------------------------------
bool __fastcall read_lcd_sr(int mask)
{
  return (LCD_SR & mask) != 0;
}
// 40002408: using guessed type int LCD_SR;

//----- (080110DC) --------------------------------------------------------
void apo_config_rcc()
{
  RCC_CR |= 0x100u;
  RCC_CFGR &= 0x88FFC00C;
  RCC_CR &= 0xEEFEFFFE;
  RCC_CR &= 0xFFFBFFFF;
  RCC_CFGR &= 0xFF02FFFF;
  RCC_CIR = 0;
}
// 40023808: using guessed type int RCC_CFGR;
// 4002380C: using guessed type int RCC_CIR;

//----- (0801113A) --------------------------------------------------------
void __fastcall set_hse_bits(char bits)
{
  BYTE2(RCC_CR) = bits;
}

//----- (0801114A) --------------------------------------------------------
bool wait_for_hse_ready()
{
  char v0; // r5@2
  int v2; // [sp+0h] [bp-10h]@1

  v2 = 0;
  do
  {
    v0 = read_clock_ready_bit(0x31u);
    ++v2;
  }
  while ( v2 != 20480 && !v0 );
  return read_clock_ready_bit(0x31u) != 0;
}

//----- (0801118A) --------------------------------------------------------
void __fastcall set_MSI_range(int mask)
{
  RCC_ICSCR = RCC_ICSCR & 0xFFFF1FFF | mask;
}
// 40023804: using guessed type int RCC_ICSCR;

//----- (080111A2) --------------------------------------------------------
void __fastcall set_HSI_ON(int result)
{
  v42470000 = (unsigned __int8)result;
}

//----- (080111AC) --------------------------------------------------------
void __fastcall set_lse_bits(char result)
{
  BYTE1(RCC_CSR) = result;
}
// 40023834: using guessed type int RCC_CSR;

//----- (080111BC) --------------------------------------------------------
void __fastcall set_RCC_LSION(unsigned __int8 result)
{
  v42470680 = result;
}

//----- (080111C6) --------------------------------------------------------
void __fastcall set_system_clock_source(int result)
{
  RCC_CFGR = 4 * ((unsigned int)RCC_CFGR >> 2) | result;
}
// 40023808: using guessed type int RCC_CFGR;

//----- (080111DE) --------------------------------------------------------
int read_RCC_curr_clock_source()
{
  return RCC_CFGR & 0xC;
}
// 80111DE: using guessed type int read_RCC_curr_clock_source(void);
// 40023808: using guessed type int RCC_CFGR;

//----- (080111EA) --------------------------------------------------------
void __fastcall get_sys_clock_info(_DWORD *info)
{
  int v1; // r7@1
  int v2; // r2@9
  unsigned int v3; // r3@9

  v1 = RCC_CFGR & 0xC;
  if ( RCC_CFGR & 0xC )
  {
    switch ( v1 )
    {
      case 4:
        *info = 16000000;
        break;
      case 8:
        *info = 8000000;
        break;
      case 12:
        v2 = PLLMulTable[(RCC_CFGR & 0x3C0000u) >> 18];
        v3 = ((RCC_CFGR & 0xC00000u) >> 22) + 1;
        if ( RCC_CFGR & 0x10000 )
          *info = 8000000 * v2 / v3;
        else
          *info = 16000000 * v2 / v3;
        break;
      default:
        *info = 1 << (((unsigned __int16)RCC_ICSCR >> 13) + 1) << 15;
        break;
    }
  }
  else
  {
    *info = 1 << (((unsigned __int16)RCC_ICSCR >> 13) + 1) << 15;
  }
  info[1] = *info >> AHB_APB_PrescTable[(RCC_CFGR & 0xF0u) >> 4];
  info[2] = info[1] >> AHB_APB_PrescTable[(RCC_CFGR & 0x700u) >> 8];
  info[3] = info[1] >> AHB_APB_PrescTable[(RCC_CFGR & 0x3800u) >> 11];
}
// 40023804: using guessed type int RCC_ICSCR;
// 40023808: using guessed type int RCC_CFGR;

//----- (080112F4) --------------------------------------------------------
void __fastcall set_internal_rtc_and_lcd_clocksource(int result)
{
  if ( (result & 0x30000) == 0x30000 )
    RCC_CR = RCC_CR & 0x9FFFFFFF | result & 0x60000000;
  RCC_CSR &= 0xFFFCFFFF;
  RCC_CSR |= result & 0x30000;
}
// 40023834: using guessed type int RCC_CSR;

//----- (08011330) --------------------------------------------------------
void __fastcall set_RCC_CSR_RTCEN(unsigned __int8 val)
{
  v424706D8 = val;
}

//----- (08011338) --------------------------------------------------------
void __fastcall set_RCC_CSR_RTCRST(unsigned __int8 val)
{
  v424706DC = val;
}

//----- (08011340) --------------------------------------------------------
void __fastcall set_AHB_periph_clk(int mask, char enable)
{
  if ( enable )
    RCC_AHBENR |= mask;
  else
    RCC_AHBENR &= ~mask;
}
// 4002381C: using guessed type int RCC_AHBENR;

//----- (0801135E) --------------------------------------------------------
void __fastcall set_APB2_periph_clock(int mask, char enable)
{
  if ( enable )
    RCC_APB2ENR |= mask;
  else
    RCC_APB2ENR &= ~mask;
}
// 4002381C: using guessed type int RCC_AHBENR;
// 40023820: using guessed type int RCC_APB2ENR;

//----- (0801137C) --------------------------------------------------------
void __fastcall set_APB1_periph_clock(int mask, char enable)
{
  if ( enable )
    RCC_APB1ENR |= mask;
  else
    RCC_APB1ENR &= ~mask;
}
// 40023820: using guessed type int RCC_APB2ENR;
// 40023824: using guessed type int RCC_APB1ENR;

//----- (0801139A) --------------------------------------------------------
void __fastcall reset_apb2_periph(int mask, char reset)
{
  if ( reset )
    RCC_APB2RSTR |= mask;
  else
    RCC_APB2RSTR &= ~mask;
}
// 40023814: using guessed type int RCC_APB2RSTR;

//----- (080113B8) --------------------------------------------------------
bool __fastcall read_clock_ready_bit(unsigned __int8 a1)
{
  unsigned int v1; // r3@2

  if ( a1 >> 5 == 1 )
    v1 = RCC_CR;
  else
    v1 = RCC_CSR;
  return ((v1 >> (a1 & 0x1F)) & 1) != 0;
}
// 40023834: using guessed type int RCC_CSR;

//----- (08011450) --------------------------------------------------------
void __fastcall sub_8011450(int result)
{
  *(_DWORD *)(4 * ((unsigned int)(char)result >> 5) - 0x1FFF1F00) = 1 << (result & 0x1F);
}

//----- (0801146A) --------------------------------------------------------
void config_clock_interrupts_and_gpio()
{
  if ( test_pwr_csr_bits(1) )                   // came from standby?
  {
    set_APB1_periph_clock(0x10000000, 1);       // enable PWR
    set_pwr_cr_bits_offset(2);                  // then reset standby flag
    came_from_standby = 1;
  }
  else
  {
    came_from_standby = 0;
  }
  set_flash_sr(0x1F02);                         // that's an illegal value?
  current_brownout_level = get_brownout_level_from_option_bytes();
  if ( current_brownout_level & 0xF )           // brownout is not zero (bad test btw)
  {
    unlock_option_bytes_and_data_eeprom();
    set_flash_sr(0xF02);
    probably_reprogram_brownout_level_or_otherwise_init_options(0);
    reload_option_bytes();
  }
  set_most_pwr_cr_bits(0x800);                  // set high power range
  while ( test_pwr_csr_bits(0x10) )             // wait for change to be complete
    ;
  set_clocks_and_power_periphs(0);
  enable_internal_rtc_and_lcd_clk();
  sub_801CE7C(7, 1);
  gpio_config_meter_hardware();
  gpio_config_analog_inputs();
  init_adc_and_stuff();
  probably_something_with_interrupts();
  config_TIM2();
  config_TIM3();
  power_all_gpio_banks();
}
// 20003804: using guessed type int current_brownout_level;
// 20003A9C: using guessed type char came_from_standby;

//----- (0801150E) --------------------------------------------------------
void __fastcall set_clocks_and_power_periphs(char use_hse)
{
  if ( use_hse )
  {
    set_hse_bits(1);
    if ( wait_for_hse_ready() == 1 )
    {
      set_system_clock_source(2);               // switch to HSE
      set_HSI_ON(0);
    }
  }
  else                                          // use MSI instead
  {
    set_HSI_ON(1);
    while ( !read_clock_ready_bit(0x21u) )
      ;
    set_system_clock_source(0);
    set_MSI_range(0xC000);
    set_lse_bits(0);
    set_hse_bits(0);
    if ( read_clock_ready_bit(0x31u) )
    {
      while ( 1 )
        ;
    }
  }
  power_all_gpio_banks();
  set_APB1_periph_clock(0x10000200, 1);         // enable power and lcd
  set_APB2_periph_clock(0x201, 1);              // enable adc and syscfg
}

//----- (08011586) --------------------------------------------------------
void __fastcall enable_internal_rtc_and_lcd_clk()
{
  set_rtc_rcc_csr_access(1u);
  set_RCC_CSR_RTCRST(1u);
  set_RCC_CSR_RTCRST(0);
  set_RCC_LSION(1u);
  while ( !read_clock_ready_bit(0x41u) )        // wait for LSI to be ready
    ;
  set_RCC_CSR_RTCEN(1u);
  set_internal_rtc_and_lcd_clocksource(0x20000);// to LSI
}

//----- (080115BA) --------------------------------------------------------
void power_all_gpio_banks()
{
  set_AHB_periph_clk(0xFF, 1);
}

//----- (080115C6) --------------------------------------------------------
void __fastcall power_off_all_gpio_banks()
{
  set_AHB_periph_clk(255, 0);
}

//----- (080115D2) --------------------------------------------------------
void probably_something_with_interrupts()
{
  char v0; // [sp+0h] [bp-8h]@1
  char v1; // [sp+1h] [bp-7h]@1
  char v2; // [sp+2h] [bp-6h]@1
  char v3; // [sp+3h] [bp-5h]@1

  set_SCB_AIRCR(0x500);
  v0 = 45;
  v1 = 0;
  v2 = 0;
  v3 = 1;
  sub_801CEAA((int)&v0);
  v0 = 53;
  v1 = 0;
  sub_801CEAA((int)&v0);
  v0 = 28;
  v1 = 2;
  v2 = 2;
  v3 = 1;
  sub_801CEAA((int)&v0);
  v0 = 29;
  v1 = 1;
  v2 = 1;
  v3 = 1;
  sub_801CEAA((int)&v0);
}

//----- (0801164A) --------------------------------------------------------
void __fastcall gpio_config_meter_hardware()
{
  GPIO_CONFIG cfg; // [sp+0h] [bp-10h]@1

  power_all_gpio_banks();
  gpio_config_switch_button_inputs(0);
  gpio_config_jack_detector_inputs();
  // configure PD0 (CTL_A), PD1 (PWR_CTL2), PD7 (DCmV_CTL)
  // * output, push-pull
  // * no pull up/down
  // * medium speed
  cfg.pins = 0x83;
  cfg.mode = 1;
  cfg.out_type = 0;
  cfg.pull = 0;
  cfg.speed = 1;
  gpio_config_pin(&GPIOD, &cfg);
  LOWORD(GPIOD.BSRR) = 128;                     // PD7 on at poweron
  // configure PE5 (A_CTL), PE7 (BUZZER), PE8 (BL_OUT),
  // PE9 (PWR_CTL), PE12 (SHDN_A), PE13 (N/C), PE15 (LED_CK)
  // * output, push-pull
  // * no pull up/down
  // * medium speed
  cfg.pins = 0xB3A0;
  cfg.mode = 1;
  cfg.out_type = 0;
  cfg.pull = 0;
  cfg.speed = 1;
  gpio_config_pin(&GPIOE, &cfg);
  GPIOE.BSRR = 0x200200;                        // PE9 on at poweron
  // configure PF2 (HY_DI) to medium speed output
  cfg.pins = 4;
  cfg.mode = 1;
  cfg.out_type = 0;
  cfg.pull = 0;
  cfg.speed = 1;
  gpio_config_pin(&GPIOF, &cfg);
  // configure PF0 (HY_CK) to medium speed output
  cfg.pins = 1;
  cfg.mode = 1;
  cfg.out_type = 0;
  cfg.pull = 0;
  cfg.speed = 1;
  gpio_config_pin(&GPIOF, &cfg);
  // configure PF1 (HY_CS) to medium speed output
  cfg.pins = 2;
  cfg.mode = 1;
  cfg.out_type = 0;
  cfg.pull = 0;
  cfg.speed = 1;
  gpio_config_pin(&GPIOF, &cfg);
  // configure PF3 (HY_DO) to input with pull-up
  cfg.pins = 8;
  cfg.mode = 0;
  cfg.pull = 1;
  cfg.speed = 3;
  gpio_config_pin(&GPIOF, &cfg);
  GPIOF.BSRR = 0x10004;                         // PF2 on at poweron
  // configure PB6 (EE_CLK) and PB7 (EE_DO)
  // * output, push/pull
  // * no pull up/down
  // * medium speed
  cfg.pins = 0xC0;
  cfg.mode = 1;
  cfg.out_type = 0;
  cfg.pull = 0;
  cfg.speed = 1;
  gpio_config_pin(&GPIOB, &cfg);
  HIWORD(GPIOB.BSRR) = 128;                     // PB7 on at poweron
  // configure PC11 (CTL_B) and PC13 (RTC_CE)
  // * output, push/pull
  // * no pull up/down
  // * medium speed
  cfg.pins = 0x2800;
  cfg.mode = 1;
  cfg.out_type = 0;
  cfg.pull = 0;
  cfg.speed = 1;
  gpio_config_pin(&GPIOC, &cfg);
  HIWORD(GPIOC.BSRR) = 0x2000;                  // PC13 on at poweron
  // configure PF4 (CTL_D), PF5 (CTL_E), and PF6 (ENB)
  // * output, push/pull
  // * no pull up/down
  // * medium speed
  cfg.pins = 0x70;
  cfg.mode = 1;
  cfg.out_type = 0;
  cfg.pull = 0;
  cfg.speed = 1;
  gpio_config_pin(&GPIOF, &cfg);
  // configure PH2 (TEMP_CTL)
  // * output, push/pull
  // * no pull up/down
  // * medium speed
  cfg.pins = 4;
  cfg.mode = 1;
  cfg.out_type = 0;
  cfg.pull = 0;
  cfg.speed = 1;
  gpio_config_pin(&GPIOH, &cfg);
  // configure PA11 (VA_CTL) and PA12 (FRE_CTL)
  // * output, push/pull
  // * no pull up/down
  // * medium speed
  cfg.pins = 0x1800;
  cfg.mode = 1;
  cfg.out_type = 0;
  cfg.pull = 0;
  cfg.speed = 1;
  gpio_config_pin(&GPIOA, &cfg);
  GPIOA.BSRR = 0x8001000;                       // PA12 on at poweron
  HIWORD(GPIOE.BSRR) = 0x8000u;
  HIWORD(GPIOF.BSRR) = 0x40;
  HIWORD(GPIOH.BSRR) = 4;
  meas_hw_set_ac_rms_filter_ctl(MM_SUB_TEMPC);
}
// 40020400: using guessed type GPIO_REGS GPIOB;
// 40020800: using guessed type GPIO_REGS GPIOC;
// 40020C00: using guessed type GPIO_REGS GPIOD;
// 40021000: using guessed type GPIO_REGS GPIOE;
// 40021400: using guessed type GPIO_REGS GPIOH;
// 40021800: using guessed type GPIO_REGS GPIOF;

//----- (080118AE) --------------------------------------------------------
void __fastcall gpio_config_switch_button_inputs(unsigned __int8 except_this_range_switch_input)
{
  GPIO_CONFIG cfg; // [sp+0h] [bp-10h]@11
                                                // configure the range switch and button inputs on port G
                                                // * input
                                                // * pull-up
                                                // * max drive speed
  *(_DWORD *)&except_this_range_switch_input = except_this_range_switch_input;
  if ( except_this_range_switch_input )
  {
    switch ( except_this_range_switch_input )
    {
      case 1u:
        cfg.pins = 0x7F;
        break;
      case 2u:
        cfg.pins = 0xBF;
        break;
      case 4u:
        cfg.pins = 0xDF;
        break;
      case 8u:
        cfg.pins = 0xEF;
        break;
      case 0x10u:
        cfg.pins = 0xF7;
        break;
      case 0x20u:
        cfg.pins = 0xFB;
        break;
      case 0x40u:
        cfg.pins = 0xFD;
        break;
      case 0x80u:
        cfg.pins = 0xFE;
        break;
    }
  }
  else
  {
    cfg.pins = 255;
  }
  cfg.mode = 0;
  cfg.pull = 1;
  cfg.speed = 3;
  gpio_config_pin(&GPIOG, &cfg);
  cfg.pins = 0xFF00;
  cfg.mode = 0;
  cfg.pull = 1;
  cfg.speed = 3;
  gpio_config_pin(&GPIOG, &cfg);
}
// 40021C00: using guessed type GPIO_REGS GPIOG;

//----- (08011950) --------------------------------------------------------
void __fastcall gpio_config_jack_detector_inputs()
{
  GPIO_CONFIG cfg; // [sp+0h] [bp-10h]@1

  // PE10 and PE11
  // * input
  // * no pull
  // * max drive speed
  cfg.pins = 0xC00;
  cfg.mode = 0;
  cfg.pull = 0;
  cfg.speed = 3;
  gpio_config_pin(&GPIOE, &cfg);
}
// 40021000: using guessed type GPIO_REGS GPIOE;

//----- (08011978) --------------------------------------------------------
void __cdecl bt_powerup()
{
  GPIO_CONFIG gpio_cfg; // [sp+0h] [bp-20h]@1
  char v1; // [sp+4h] [bp-1Ch]@1
  char v2; // [sp+5h] [bp-1Bh]@1
  char v3; // [sp+6h] [bp-1Ah]@1
  char v4; // [sp+7h] [bp-19h]@1
  int v5; // [sp+8h] [bp-18h]@1
  __int16 v6; // [sp+Ch] [bp-14h]@1
  __int16 v7; // [sp+Eh] [bp-12h]@1
  __int16 v8; // [sp+10h] [bp-10h]@1
  __int16 v9; // [sp+12h] [bp-Eh]@1
  __int16 v10; // [sp+14h] [bp-Ch]@1

  gpio_cfg.pins = 0x8000;
  v1 = 1;
  v3 = 0;
  v4 = 0;
  v2 = 3;
  gpio_config_pin(&GPIOF, &gpio_cfg);
  LOWORD(GPIOF.BSRR) = 0x8000u;
  set_AHB_periph_clk(8, 1);
  gpio_cfg.pins = 96;
  v1 = 2;
  v2 = 3;
  v3 = 0;
  v4 = 1;
  gpio_config_pin(&GPIOD, &gpio_cfg);
  set_gpio_pin_func(&GPIOD, 5u, 7u);
  set_gpio_pin_func(&GPIOD, 6u, 7u);
  set_APB1_periph_clock(0x20000, 1);
  v5 = 19200;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v10 = 0;
  v9 = 12;
  config_usart(&USART2_1, (int)&v5);
  set_usart_enable(&USART2_1, 1);
  set_usart_control_bit(&USART2_1, 37u, 1);
  sub_8011450(38);
}
// 40020C00: using guessed type GPIO_REGS GPIOD;
// 40021800: using guessed type GPIO_REGS GPIOF;

//----- (08011A4E) --------------------------------------------------------
void gpio_config_analog_inputs()
{
  GPIO_CONFIG cfg; // [sp+0h] [bp-10h]@1

  // configure PA4 and PA5
  // * max speed
  // * analog
  // * no pull up/down
  cfg.pins = 0x30;
  cfg.speed = 3;
  cfg.mode = 3;
  cfg.pull = 0;
  gpio_config_pin(&GPIOA, &cfg);
  // configure PF11 (N/C), PF13 (N/C), and PF14 (N/C)
  // * max speed
  // * analog
  // * no pull up/down
  cfg.pins = 0x6800;
  cfg.speed = 3;
  cfg.mode = 3;
  cfg.pull = 0;
  gpio_config_pin(&GPIOF, &cfg);
}
// 40021800: using guessed type GPIO_REGS GPIOF;

//----- (08011A96) --------------------------------------------------------
void __fastcall config_TIM2()
{
  __int64 a2; // [sp+0h] [bp-10h]@1
  __int16 v1; // [sp+8h] [bp-8h]@1

  set_APB1_periph_clock(1, 1);
  a2 = 0xA000000104LL;
  v1 = 0;
  TIM_Base_SetConfig(&TIM2_0, (int *)&a2);
  TIM_clear_status_bits(&TIM2_0, 1);
  sub_801CFBC(0x40000000, 1, 1);
  set_timer_enable(&TIM2_0, 1);
}

//----- (08011AE4) --------------------------------------------------------
void __fastcall config_TIM3()
{
  __int64 a2; // [sp+0h] [bp-10h]@1
  __int16 v1; // [sp+8h] [bp-8h]@1

  set_APB1_periph_clock(2, 1);
  a2 = 0xE00000104LL;
  v1 = 0;
  TIM_Base_SetConfig(&TIM3, (int *)&a2);
  TIM_clear_status_bits(&TIM3, 1);
  sub_801CFBC((int)&TIM3, 1, 1);
  set_timer_enable(&TIM3, 1);
}

//----- (08011B32) --------------------------------------------------------
void apo_prepare_to_turn_off(void)
{
  apo_unset_gpios();
  apo_disable_timers();
  disable_PWR_voltage_detector();
  apo_config_rcc_power_stuff();
  apo_something_with_power();
  apo_config_rcc();
  set_APB1_periph_clock(0x10000000, 1);
  set_most_pwr_cr_bits(6144);
  while ( test_pwr_csr_bits(16) )
    ;
  set_MSI_range(0);
  set_system_clock_source(0);
  while ( read_RCC_curr_clock_source() )
    ;
  apo_something_with_rtc(0x4000, 0);
  apo_disable_oscillators();
  apo_power_off_gpio();
  apo_something_with_rangeswitch();
}
// 80111DE: using guessed type int read_RCC_curr_clock_source(void);

//----- (08011B94) --------------------------------------------------------
void apo_unset_gpios(void)
{
  HIWORD(GPIOE.BSRR) = 256;
  lcd_shutdown();
  GPIOB.BSRR = 4194432;
  apo_sleep_HY();
  meas_hw_set_ac_rms_filter_ctl(MM_SUB_TEMPC);
  HIWORD(GPIOA.BSRR) = 4096;
  HIWORD(GPIOH.BSRR) = 4;
  HIWORD(GPIOE.BSRR) = -32768;
  HIWORD(GPIOF.BSRR) = 64;
  bt_shutdown();
  powerdown_adc1();
  HIWORD(GPIOE.BSRR) = 512;
}
// 40020400: using guessed type GPIO_REGS GPIOB;
// 40021000: using guessed type GPIO_REGS GPIOE;
// 40021400: using guessed type GPIO_REGS GPIOH;
// 40021800: using guessed type GPIO_REGS GPIOF;

//----- (08011C2C) --------------------------------------------------------
void __fastcall apo_something_with_rangeswitch()
{
  __int64 v0; // r0@1
  int v1; // r2@1
  int v2; // r3@1
  __int64 v3; // r0@17
  int v4; // r2@17
  int v5; // r3@17
  __int64 v6; // r0@17
  int v7; // r2@17
  int v8; // r3@17
  __int64 v9; // r0@17
  int v10; // r2@17
  int v11; // r3@17
  __int64 v12; // r0@17
  int v13; // r2@17
  int v14; // r3@17
  __int64 v15; // r0@17
  int v16; // r2@17
  int v17; // r3@17
  __int64 v18; // r0@17
  int v19; // r2@17
  int v20; // r3@17
  __int64 v21; // r0@17
  int v22; // r2@17
  int v23; // r3@17

  set_AHB_periph_clk(128, 1);
  gpio_config_switch_button_inputs(curr_range_switch_bits);
  set_APB2_periph_clock(1, 1);
  if ( curr_range_switch_bits != 1 )
    v0 = sub_8011D04(7u, SHIDWORD(v0), v1, v2);
  if ( curr_range_switch_bits != 2 )
    v0 = sub_8011D04(6u, SHIDWORD(v0), v1, v2);
  if ( curr_range_switch_bits != 4 )
    v0 = sub_8011D04(5u, SHIDWORD(v0), v1, v2);
  if ( curr_range_switch_bits != 8 )
    v0 = sub_8011D04(4u, SHIDWORD(v0), v1, v2);
  if ( curr_range_switch_bits != 16 )
    v0 = sub_8011D04(3u, SHIDWORD(v0), v1, v2);
  if ( curr_range_switch_bits != 32 )
    v0 = sub_8011D04(2u, SHIDWORD(v0), v1, v2);
  if ( curr_range_switch_bits != 64 )
    v0 = sub_8011D04(1u, SHIDWORD(v0), v1, v2);
  if ( curr_range_switch_bits != 128 )
    v0 = sub_8011D04(0, SHIDWORD(v0), v1, v2);
  v3 = sub_8011D04(8u, SHIDWORD(v0), v1, v2);
  v6 = sub_8011D04(9u, SHIDWORD(v3), v4, v5);
  v9 = sub_8011D04(0xAu, SHIDWORD(v6), v7, v8);
  v12 = sub_8011D04(0xBu, SHIDWORD(v9), v10, v11);
  v15 = sub_8011D04(0xCu, SHIDWORD(v12), v13, v14);
  v18 = sub_8011D04(0xDu, SHIDWORD(v15), v16, v17);
  v21 = sub_8011D04(0xEu, SHIDWORD(v18), v19, v20);
  sub_8011D04(0xFu, SHIDWORD(v21), v22, v23);
}

//----- (08011D04) --------------------------------------------------------
__int64 __fastcall sub_8011D04(unsigned __int8 a1, int a2, int a3, int a4)
{
  unsigned __int8 v4; // r4@1
  unsigned __int8 v5; // r0@1
  __int64 v7; // [sp+0h] [bp-20h]@1
  int v8; // [sp+8h] [bp-18h]@1

  v8 = a4;
  v4 = a1;
  v5 = identity_if_lt_16(a1);
  sub_801D0A8(7, v5);
  HIDWORD(v7) = one_hot_16bit(v4);
  LOWORD(v8) = 3072;
  BYTE2(v8) = 1;
  sub_801D0FC((int)((char *)&v7 + 4));
  LOWORD(v7) = (unsigned __int8)sub_8011D66(v4);
  BYTE2(v7) = v4;
  BYTE3(v7) = 1;
  sub_801CEAA((int)&v7);
  return v7;
}

//----- (08011D66) --------------------------------------------------------
int __fastcall sub_8011D66(int result)
{
  if ( (_BYTE)result )
  {
    switch ( (unsigned __int8)result )
    {
      case 1u:
        LOBYTE(result) = 7;
        break;
      case 2u:
        LOBYTE(result) = 8;
        break;
      case 3u:
        LOBYTE(result) = 9;
        break;
      case 4u:
        LOBYTE(result) = 10;
        break;
      default:
        if ( (unsigned int)(unsigned __int8)result - 5 <= 4 )
        {
          LOBYTE(result) = 23;
        }
        else if ( (unsigned int)(unsigned __int8)result - 10 <= 5 )
        {
          LOBYTE(result) = 40;
        }
        break;
    }
  }
  else
  {
    LOBYTE(result) = 6;
  }
  return (unsigned __int8)result;
}

//----- (08011DBA) --------------------------------------------------------
unsigned __int32 __fastcall one_hot_16bit(unsigned __int32 result)
{
  if ( (_BYTE)result )
  {
    if ( (unsigned __int8)result == 2 )
    {
      result = 4;
    }
    else if ( (unsigned __int8)result >= 2u )
    {
      if ( (unsigned __int8)result == 4 )
      {
        result = 16;
      }
      else if ( (unsigned __int8)result >= 4u )
      {
        if ( (unsigned __int8)result == 6 )
        {
          result = 64;
        }
        else if ( (unsigned __int8)result >= 6u )
        {
          if ( (unsigned __int8)result == 8 )
          {
            result = 256;
          }
          else if ( (unsigned __int8)result >= 8u )
          {
            if ( (unsigned __int8)result == 10 )
            {
              result = 1024;
            }
            else if ( (unsigned __int8)result >= 0xAu )
            {
              if ( (unsigned __int8)result == 12 )
              {
                result = 4096;
              }
              else if ( (unsigned __int8)result >= 0xCu )
              {
                if ( (unsigned __int8)result == 14 )
                {
                  result = 0x4000;
                }
                else if ( (unsigned __int8)result >= 0xEu )
                {
                  if ( (unsigned __int8)result == 15 )
                    result = 0x8000;
                }
                else
                {
                  result = 0x2000;
                }
              }
              else
              {
                result = 2048;
              }
            }
            else
            {
              result = 512;
            }
          }
          else
          {
            result = 128;
          }
        }
        else
        {
          result = 32;
        }
      }
      else
      {
        result = 8;
      }
    }
    else
    {
      result = 2;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (08011E62) --------------------------------------------------------
unsigned __int8 __fastcall identity_if_lt_16(unsigned __int8 result)
{
  if ( result )
  {
    if ( result == 2 )
    {
      result = 2;
    }
    else if ( result >= 2u )
    {
      if ( result == 4 )
      {
        result = 4;
      }
      else if ( result >= 4u )
      {
        if ( result == 6 )
        {
          result = 6;
        }
        else if ( result >= 6u )
        {
          if ( result == 8 )
          {
            result = 8;
          }
          else if ( result >= 8u )
          {
            if ( result == 10 )
            {
              result = 10;
            }
            else if ( result >= 0xAu )
            {
              if ( result == 12 )
              {
                result = 12;
              }
              else if ( result >= 0xCu )
              {
                if ( result == 14 )
                {
                  result = 14;
                }
                else if ( result >= 0xEu )
                {
                  if ( result == 15 )
                    result = 15;
                }
                else
                {
                  result = 13;
                }
              }
              else
              {
                result = 11;
              }
            }
            else
            {
              result = 9;
            }
          }
          else
          {
            result = 7;
          }
        }
        else
        {
          result = 5;
        }
      }
      else
      {
        result = 3;
      }
    }
    else
    {
      result = 1;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (08011EFC) --------------------------------------------------------
void __cdecl apo_sleep_HY()
{
  GPIOF.BSRR = 0x10004;
}
// 40021800: using guessed type GPIO_REGS GPIOF;

//----- (08011F18) --------------------------------------------------------
void __fastcall lcd_shutdown()
{
  lcd_turn_off_all_segments();
  update_lcd_if_appropriate();
  lcd_set_enable(0);
  while ( read_lcd_sr(1) == 1 )
    ;
  set_APB1_periph_clock(512, 0);
}

//----- (08011F3E) --------------------------------------------------------
void apo_disable_timers()
{
  set_timer_enable(&TIM2_0, 0);
  set_APB1_periph_clock(1, 0);
  set_timer_enable(&TIM3, 0);
  set_APB1_periph_clock(2, 0);
}

//----- (08011F64) --------------------------------------------------------
void __cdecl bt_shutdown()
{
  HIWORD(GPIOF.BSRR) = 0x8000u;
  set_usart_control_bit(&USART2_1, 0x25u, 0);
  set_usart_enable(&USART2_1, 0);
  set_APB1_periph_clock(0x20000, 0);
}
// 40021800: using guessed type GPIO_REGS GPIOF;

//----- (08011F98) --------------------------------------------------------
void __cdecl powerdown_adc1()
{
  enable_adc(&ADC1_BASE, 0);
  set_APB2_periph_clock(512, 0);
}
// 40012400: using guessed type ADC_REGS ADC1_BASE;

//----- (08011FB8) --------------------------------------------------------
void disable_PWR_voltage_detector()
{
  set_PWR_voltage_detector_enable(0);
}

//----- (08011FC2) --------------------------------------------------------
void __fastcall apo_config_rcc_power_stuff()
{
  set_PWR_Vrefint_off_in_low_power_mode(1);
  RCC_AHBENR = 5;
  unused_dword_40023828 = 5;
  RCC_APB1ENR = 0x10000000;
  RCC_APB2ENR = 0;
}
// 4002381C: using guessed type int RCC_AHBENR;
// 40023820: using guessed type int RCC_APB2ENR;
// 40023824: using guessed type int RCC_APB1ENR;
// 40023828: using guessed type int unused_dword_40023828;

//----- (08011FEC) --------------------------------------------------------
void __fastcall apo_something_with_power()
{
  vE000E010 = 0;
  set_pwr_cr_bits_offset(1);
}

//----- (08012024) --------------------------------------------------------
void __fastcall apo_disable_oscillators()
{
  set_HSI_ON(0);
  set_hse_bits(0);
  set_lse_bits(0);
}

//----- (0801203A) --------------------------------------------------------
void __fastcall apo_power_off_gpio()
{
  GPIO_CONFIG cfg; // [sp+0h] [bp-10h]@1

  power_all_gpio_banks();
  cfg.mode = 3;
  cfg.speed = 0;
  cfg.pull = 0;
  cfg.out_type = 0;
  cfg.pins = 0xFFFF;
  gpio_config_pin(&GPIOB, &cfg);
  gpio_config_pin(&GPIOC, &cfg);
  gpio_config_pin(&GPIOG, &cfg);
  gpio_config_pin(&GPIOH, &cfg);
  gpio_config_pin(&GPIOD, &cfg);
  gpio_config_pin(&GPIOE, &cfg);
  gpio_config_pin(&GPIOF, &cfg);
  cfg.pins = 0x9FFF;
  gpio_config_pin(&GPIOA, &cfg);
  power_off_all_gpio_banks();
}
// 40020400: using guessed type GPIO_REGS GPIOB;
// 40020800: using guessed type GPIO_REGS GPIOC;
// 40020C00: using guessed type GPIO_REGS GPIOD;
// 40021000: using guessed type GPIO_REGS GPIOE;
// 40021400: using guessed type GPIO_REGS GPIOH;
// 40021800: using guessed type GPIO_REGS GPIOF;
// 40021C00: using guessed type GPIO_REGS GPIOG;

//----- (08012100) --------------------------------------------------------
void __fastcall gpio_config_pin(GPIO_REGS *GPIO, GPIO_CONFIG *cfg)
{
  unsigned int i; // r2@1

  for ( i = 0; i < 0x10; ++i )
  {
    if ( (cfg->pins & (1 << i)) == 1 << i )
    {
      GPIO->MODER = GPIO->MODER & ~(3 << 2 * i) | (cfg->mode << 2 * i);
      if ( cfg->mode == 1 || cfg->mode == 2 )
      {
        GPIO->OSPEEDR = GPIO->OSPEEDR & ~(3 << 2 * i) | (cfg->speed << 2 * i);
        LOWORD(GPIO->OTYPER) = LOWORD(GPIO->OTYPER) & ~(1 << i) | (cfg->out_type << i);
      }
      GPIO->PUPDR = GPIO->PUPDR & ~(3 << 2 * i) | (cfg->pull << 2 * i);
    }
  }
}

//----- (080121A4) --------------------------------------------------------
void __fastcall gpio_clear_config(GPIO_CONFIG *cfg)
{
  cfg->pins = 0xFFFF;
  cfg->mode = 0;
  cfg->speed = 0;
  cfg->out_type = 0;
  cfg->pull = 0;
}

//----- (080121BC) --------------------------------------------------------
void __fastcall set_gpio_pin_func(GPIO_REGS *GPIO, unsigned __int16 pin, unsigned __int8 func)
{
  *(&GPIO->AFRL + ((signed int)pin >> 3)) &= ~(15 << 4 * (pin & 7));
  *(&GPIO->AFRL + ((signed int)pin >> 3)) |= func << 4 * (pin & 7);
}

//----- (08012216) --------------------------------------------------------
_DWORD *__fastcall sub_8012216(_DWORD *a1)
{
  int v1; // r9@0
  _DWORD *result; // r0@1
  int v3; // r1@1
  int v4; // t1@1
  _DWORD *v5; // r2@2
  _DWORD *v6; // r0@2
  int v7; // r3@2
  int v8; // t1@2
  int v9; // t1@4

  while ( 1 )
  {
    v4 = *a1;
    result = a1 + 1;
    v3 = v4;
    if ( !v4 )
      break;
    v5 = (_DWORD *)((char *)result + *result);
    v6 = result + 1;
    v8 = *v6;
    a1 = v6 + 1;
    v7 = v8;
    if ( v8 << 31 < 0 )
      v7 += v1 - 1;
    do
    {
      v9 = *v5;
      ++v5;
      *(_DWORD *)v7 = v9;
      v7 += 4;
      v3 -= 4;
    }
    while ( v3 );
  }
  return result;
}

//----- (08012244) --------------------------------------------------------
void cal_save_to_sd(void)
{
  char v0; // r4@1
  int i; // r6@1
  unsigned int j; // r6@19
  unsigned int k; // r6@29
  unsigned int l; // r6@39

  v0 = 0;
  for ( i = 0; (unsigned int)i < 1200; ++i )
    sd_cal_buf[i] = read_eeprom_byte_also(i);
  set_clocks_and_power_periphs(1);
  if ( f_mount_tries(0xAu) )
    v0 = 1;
  if ( !v0 )
    sub_801E1E0(0, (int)&unk_20002938);
  if ( !v0 && sub_8012608(0xAu) )
    v0 = 4;
  if ( !v0 )
  {
    f_op_err = f_write(&f_file_structure, sd_cal_buf, 1200u, &f_bytes_written_temp);
    if ( f_op_err || f_bytes_written_temp != 1200 )
      v0 = 7;
  }
  f_close((int)&f_file_structure);
  f_open(&f_file_structure, "cal.bin", FA_READ);
  f_op_err = f_read(&f_file_structure, sd_readback_buf, 512u, &f_bytes_read_temp);
  if ( f_op_err || f_bytes_read_temp != 512 )
    v0 = 8;
  if ( !v0 )
  {
    for ( j = 0; j < 0x200; ++j )
    {
      if ( sd_cal_buf[j] != sd_readback_buf[j] )
      {
        v0 = 9;
        break;
      }
    }
  }
  if ( !v0 )
  {
    f_op_err = f_read(&f_file_structure, sd_readback_buf, 0x200u, &f_bytes_read_temp);
    if ( f_op_err || f_bytes_read_temp != 512 )
      v0 = 8;
    if ( !v0 )
    {
      for ( k = 0; k < 0x200; ++k )
      {
        if ( sd_cal_buf[k + 512] != sd_readback_buf[k] )
        {
          v0 = 9;
          break;
        }
      }
    }
  }
  if ( !v0 )
  {
    f_op_err = f_read(&f_file_structure, sd_readback_buf, 0xB0u, &f_bytes_read_temp);
    if ( f_op_err || f_bytes_read_temp != 176 )
      v0 = 8;
    if ( !v0 )
    {
      for ( l = 0; l < 0xB0 && sd_cal_buf[l + 1024] == sd_readback_buf[l]; ++l )
        ;
    }
  }
  f_close((int)&f_file_structure);
  turn_off_sd_card();
  set_clocks_and_power_periphs(0);
}
// 200037EC: using guessed type int f_bytes_read_temp;
// 200037F0: using guessed type int f_bytes_written_temp;
// 20003A96: using guessed type char f_op_err;

//----- (08012438) --------------------------------------------------------
int cal_load_from_sd()
{
  char v0; // r4@1
  unsigned int i; // r6@11
  unsigned int j; // r6@18
  unsigned int k; // r6@25
  int l; // r6@29
  int m; // r6@32
  unsigned int n; // r6@35
  char v8; // [sp+0h] [bp-4C0h]@34

  v0 = 0;
  set_clocks_and_power_periphs(1);
  if ( f_mount_tries(0xAu) )
    v0 = 1;
  if ( !v0 )
    sub_801E1E0(0, (int)&unk_20002938);
  if ( f_open(&f_file_structure, "cal.bin", FA_READ) )
    v0 = 4;
  if ( !v0 )
  {
    f_op_err = f_read(&f_file_structure, sd_readback_buf, 0x200u, &f_bytes_read_temp);
    if ( f_op_err || f_bytes_read_temp != 512 )
    {
      v0 = 8;
    }
    else
    {
      for ( i = 0; i < 0x200; ++i )
        sd_cal_buf[i] = sd_readback_buf[i];
    }
  }
  if ( !v0 )
  {
    f_op_err = f_read(&f_file_structure, sd_readback_buf, 0x200u, &f_bytes_read_temp);
    if ( f_op_err || f_bytes_read_temp != 512 )
    {
      v0 = 8;
    }
    else
    {
      for ( j = 0; j < 0x200; ++j )
        sd_cal_buf[j + 512] = sd_readback_buf[j];
    }
  }
  if ( !v0 )
  {
    f_op_err = f_read(&f_file_structure, sd_readback_buf, 0xB0u, &f_bytes_read_temp);
    if ( f_op_err || f_bytes_read_temp != 176 )
    {
      v0 = 8;
    }
    else
    {
      for ( k = 0; k < 0xB0; ++k )
        sd_cal_buf[k + 1024] = sd_readback_buf[k];
    }
  }
  f_close((int)&f_file_structure);
  turn_off_sd_card();
  set_clocks_and_power_periphs(0);
  if ( !v0 )
  {
    for ( l = 0; (unsigned int)l < 0x4B0; ++l )
      try_to_write_byte_10_times_also_also(l, sd_cal_buf[l]);
    for ( m = 0; (unsigned int)m < 0x4B0; ++m )
      *(&v8 + m) = read_eeprom_byte_also(m);
    for ( n = 0; n < 0x4B0; ++n )
    {
      if ( (unsigned __int8)*(&v8 + n) != sd_cal_buf[n] )
      {
        v0 = 9;
        return (unsigned __int8)v0;
      }
    }
  }
  return (unsigned __int8)v0;
}
// 8012438: using guessed type int cal_load_from_sd(void);
// 200037EC: using guessed type int f_bytes_read_temp;
// 20003A96: using guessed type char f_op_err;

//----- (08012608) --------------------------------------------------------
int __fastcall sub_8012608(unsigned __int8 a1)
{
  unsigned __int8 v1; // r4@1
  char v2; // r6@1
  unsigned __int8 i; // r5@1

  v1 = a1;
  v2 = 1;
  log_first_byte_of_vol_path_str = '0';
  log_second_byte_of_vol_path_str_never_read = ':';
  log_flush_samples_from_eeprom_try_counter = 0;
  for ( i = 0; i < (unsigned int)v1; ++i )
  {
    if ( !f_open(&f_file_structure, "cal.bin", FA_CREATE_ALWAYS|FA_WRITE) )
    {
      v2 = 0;
      return (unsigned __int8)v2;
    }
  }
  return (unsigned __int8)v2;
}
// 20003A97: using guessed type char log_first_byte_of_vol_path_str;
// 20003A98: using guessed type char log_second_byte_of_vol_path_str_never_read;
// 20003A99: using guessed type char log_flush_samples_from_eeprom_try_counter;

//----- (08012654) --------------------------------------------------------
int log_flush_samples_from_eeprom(void)
{
  char v0; // r5@1
  unsigned __int8 v1; // r4@7

  v0 = 0;
  log_flush_samples_from_eeprom_try_counter = 20;
  while ( log_try_flush_samples_from_eeprom() )
  {
    --log_flush_samples_from_eeprom_try_counter;
    if ( !log_flush_samples_from_eeprom_try_counter )
    {
      v0 = 1;
      break;
    }
  }
  if ( v0 == 1 )
  {
    v0 = 0;
    log_start_new_link();
    log_flush_samples_from_eeprom_try_counter = 20;
    while ( 1 )
    {
      v1 = log_try_flush_samples_from_eeprom();
      if ( !v1 )
        break;
      --log_flush_samples_from_eeprom_try_counter;
      if ( !log_flush_samples_from_eeprom_try_counter )
      {
        curr_sys_error = v1;
        need_to_update_subscr = 1;
        v0 = 1;
        return (unsigned __int8)v0;
      }
    }
  }
  return (unsigned __int8)v0;
}
// 20003A99: using guessed type char log_flush_samples_from_eeprom_try_counter;
// 20003AFE: using guessed type char need_to_update_subscr;

//----- (080126CE) --------------------------------------------------------
signed int log_try_flush_samples_from_eeprom()
{
  char v0; // r4@1
  signed int result; // r0@2
  unsigned __int8 i; // r5@26

  v0 = 0;
  set_clocks_and_power_periphs(1);
  if ( f_mount_tries(10u) )
  {
    result = 1;
  }
  else
  {
    sub_801E1E0(0, (int)&unk_20002938);
    if ( log_file_starting_new_link )
    {
      log_file_total_len = 0;
      f_op_err = log_file_get_name_then_create(10u);
      if ( f_op_err )
      {
        v0 = 3;
      }
      else
      {
        log_file_starting_new_link = 0;
        if ( !log_file_chain_idx )
          log_file_need_to_write_header = 1;
      }
    }
    else
    {
      v0 = log_file_open_and_seek();
    }
    if ( !v0 && log_write_samples_to_file() )
      v0 = 7;
    f_close((int)&f_file_structure);
    if ( !v0 )
    {
      log_file_curr_pos = f_get_len(&f_file_structure);
      v0 = log_file_reread_and_verify();
      if ( v0 )
      {
        log_file_curr_pos = log_file_start_pos;
        log_second_byte_of_vol_path_str_never_read = 1;
        if ( (unsigned int)log_file_total_samples_written >= 60 )
        {
          log_file_total_samples_written -= 60;
          --log_successful_flushes;
        }
      }
      if ( !v0 && log_file_need_to_write_header )
        log_file_need_to_write_header = 0;
    }
    if ( v0 || (unsigned int)log_file_total_samples_written < 600000 )
    {
      if ( batt_is_low_icon )
      {
        logging_end(0);
        logging_active = 0;
        scr_update_mem_icon(1);
        curr_sys_error = 20;
        need_to_update_subscr = 1;
      }
    }
    else
    {
      logging_end(0);
      logging_active = 0;
      scr_update_mem_icon(1);
      need_to_display_logging_ended = 1;
      need_to_update_subscr = 1;
    }
    if ( !v0 && log_file_is_ending )
    {
      log_file_is_ending = 0;
      for ( i = 0; (signed int)i < 20; ++i )
      {
        if ( !(unsigned __int8)log_file_open_and_seek() && !log_write_footer() )
        {
          f_close((int)&f_file_structure);
          break;
        }
        f_close((int)&f_file_structure);
      }
      v0 = 0;
    }
    turn_off_sd_card();
    set_clocks_and_power_periphs(0);
    result = (unsigned __int8)v0;
  }
  return result;
}
// 8012D0A: using guessed type int log_write_samples_to_file(void);
// 80149B4: using guessed type int log_file_reread_and_verify(void);
// 200037F4: using guessed type int log_file_start_pos;
// 200037F8: using guessed type int log_file_curr_pos;
// 200037FC: using guessed type int log_file_total_len;
// 2000382C: using guessed type int log_successful_flushes;
// 20003834: using guessed type int log_file_total_samples_written;
// 20003A64: using guessed type __int16 log_file_chain_idx;
// 20003A96: using guessed type char f_op_err;
// 20003A98: using guessed type char log_second_byte_of_vol_path_str_never_read;
// 20003AC5: using guessed type char need_to_display_logging_ended;
// 20003ACC: using guessed type char log_file_starting_new_link;
// 20003ACD: using guessed type char log_file_is_ending;
// 20003ACE: using guessed type char log_file_need_to_write_header;
// 20003ADF: using guessed type char batt_is_low_icon;
// 20003AFE: using guessed type char need_to_update_subscr;

//----- (0801289A) --------------------------------------------------------
int log_file_open_and_seek()
{
  char v0; // r5@1
  int v1; // r6@1
  int v2; // r6@6

  v0 = 0;
  v1 = 0;
  while ( 1 )
  {
    f_op_err = f_open(&f_file_structure, (char *)log_curr_filename_ptr, FA_WRITE);
    if ( !f_op_err )
      break;
    ++v1;
    if ( (signed int)(unsigned __int8)v1 >= 21 )
    {
      v0 = 4;
      break;
    }
  }
  if ( !f_op_err )
  {
    v2 = 0;
    do
    {
      f_op_err = f_seek((int)&f_file_structure, log_file_curr_pos);
      if ( !f_op_err )
      {
        log_second_byte_of_vol_path_str_never_read = 0;
        log_file_start_pos = f_get_len(&f_file_structure);
        return (unsigned __int8)v0;
      }
      ++v2;
    }
    while ( (signed int)(unsigned __int8)v2 < 21 );
    v0 = 5;
  }
  return (unsigned __int8)v0;
}
// 200037E0: using guessed type int log_curr_filename_ptr;
// 200037F4: using guessed type int log_file_start_pos;
// 200037F8: using guessed type int log_file_curr_pos;
// 20003A96: using guessed type char f_op_err;
// 20003A98: using guessed type char log_second_byte_of_vol_path_str_never_read;

//----- (0801292C) --------------------------------------------------------
void __fastcall log_start_new_link()
{
  log_need_to_flush_samples_from_eeprom = 1;
  log_file_starting_new_link = 1;
  ++log_file_chain_idx;
}
// 20003A64: using guessed type __int16 log_file_chain_idx;
// 20003AC4: using guessed type char log_need_to_flush_samples_from_eeprom;
// 20003ACC: using guessed type char log_file_starting_new_link;

//----- (0801294C) --------------------------------------------------------
int __fastcall log_file_create(char a1, unsigned __int8 a2)
{
  char v2; // r4@1
  unsigned __int8 v3; // r5@1
  unsigned __int8 i; // r6@1

  v2 = a1;
  v3 = a2;
  for ( i = 0; i < (unsigned int)v3; ++i )
  {
    if ( v2 )
    {
      f_op_err = f_open(&unk_20002D8C, (char *)log_curr_filename_ptr, FA_CREATE_ALWAYS|FA_WRITE|FA_READ);
      if ( !f_op_err )
        f_op_err = f_open(&f_file_structure, (char *)dword_200037E4, FA_READ);
    }
    else
    {
      f_op_err = f_open(&f_file_structure, (char *)log_curr_filename_ptr, FA_CREATE_ALWAYS|FA_WRITE);
    }
    if ( !f_op_err )
      return (unsigned __int8)f_op_err;
  }
  return (unsigned __int8)f_op_err;
}
// 200037E0: using guessed type int log_curr_filename_ptr;
// 200037E4: using guessed type int dword_200037E4;
// 20003A96: using guessed type char f_op_err;

//----- (080129C2) --------------------------------------------------------
int __fastcall log_file_get_name_then_create(unsigned __int8 a1)
{
  unsigned __int8 v1; // r4@1
  unsigned __int8 i; // r5@1

  v1 = a1;
  log_first_byte_of_vol_path_str = '0';
  log_second_byte_of_vol_path_str_never_read = ':';
  log_flush_samples_from_eeprom_try_counter = 0;
  for ( i = 0; i < (unsigned int)v1; ++i )
  {
    f_op_err = maybe_find_last_log_file_chain_link((int)&log_first_byte_of_vol_path_str);
    if ( !f_op_err )
    {
      if ( log_file_chain_idx )
        log_file_name_add_chain_link_num();
      else
        log_file_build_name(log_file_name_number);
      f_op_err = log_file_create(0, 0xAu);
      if ( !f_op_err )
        return (unsigned __int8)f_op_err;
    }
  }
  return (unsigned __int8)f_op_err;
}
// 200037E8: using guessed type int log_file_name_number;
// 20003A64: using guessed type __int16 log_file_chain_idx;
// 20003A96: using guessed type char f_op_err;
// 20003A97: using guessed type char log_first_byte_of_vol_path_str;
// 20003A98: using guessed type char log_second_byte_of_vol_path_str_never_read;
// 20003A99: using guessed type char log_flush_samples_from_eeprom_try_counter;

//----- (08012A3C) --------------------------------------------------------
int __fastcall maybe_find_last_log_file_chain_link(int a1)
{
  int v1; // r6@1
  int result; // r0@2

  v1 = 0;
  f_op_err = sub_801EADA((int)&unk_20003684, a1);
  if ( f_op_err )
  {
    result = (unsigned __int8)f_op_err;
  }
  else
  {
    if ( !log_file_chain_idx )
    {
      while ( 1 )
      {
        f_op_err = sub_801EB64((int)&unk_20003684, (int)&unk_200036A0);
        if ( f_op_err || !byte_200036A9 )
          break;
        if ( byte_200036A9 != '.'
          && (byte_200036B2 == 'c' && byte_200036B3 == 's' && byte_200036B4 == 'v'
           || byte_200036B2 == 'C' && byte_200036B3 == 'S' && byte_200036B4 == 'V') )
        {
          byte_20003B74 = byte_200036AA + 10 * byte_200036A9 - 16;
          byte_20003B75 = byte_200036AC + 10 * byte_200036AB - 16;
          byte_20003B76 = byte_200036AE + 10 * byte_200036AD - 16;
          if ( (unsigned __int8)byte_20003B74 == curr_year
            && (unsigned __int8)byte_20003B75 == curr_month
            && (unsigned __int8)byte_20003B76 == curr_day
            && v1 < (unsigned __int8)byte_200036B0 + 10 * (unsigned __int8)byte_200036AF - 527 )
            v1 = (unsigned __int8)byte_200036B0 + 10 * (unsigned __int8)byte_200036AF - 527;
        }
      }
      log_file_name_number = v1;
      if ( v1 >= 100 )
        log_file_name_number = 0;
    }
    result = (unsigned __int8)f_op_err;
  }
  return result;
}
// 200036A9: using guessed type char byte_200036A9;
// 200036AA: using guessed type char byte_200036AA;
// 200036AB: using guessed type char byte_200036AB;
// 200036AC: using guessed type char byte_200036AC;
// 200036AD: using guessed type char byte_200036AD;
// 200036AE: using guessed type char byte_200036AE;
// 200036AF: using guessed type char byte_200036AF;
// 200036B0: using guessed type char byte_200036B0;
// 200036B2: using guessed type char byte_200036B2;
// 200036B3: using guessed type char byte_200036B3;
// 200036B4: using guessed type char byte_200036B4;
// 200037E8: using guessed type int log_file_name_number;
// 20003A64: using guessed type __int16 log_file_chain_idx;
// 20003A96: using guessed type char f_op_err;
// 20003B74: using guessed type char byte_20003B74;
// 20003B75: using guessed type char byte_20003B75;
// 20003B76: using guessed type char byte_20003B76;

//----- (08012B98) --------------------------------------------------------
void __fastcall log_file_name_add_chain_link_num()
{
  if ( log_file_chain_idx == 1 )
  {
    log_file_name[0] = log_file_name[2];
    log_file_name[1] = log_file_name[3];
    log_file_name[2] = log_file_name[4];
    log_file_name[3] = log_file_name[5];
    log_file_name[4] = log_file_name[6];
    log_file_name[5] = log_file_name[7];
  }
  log_file_name[6] = (unsigned __int16)log_file_chain_idx / 10 + 48;
  log_file_name[7] = (unsigned __int16)log_file_chain_idx % 10 + 48;
  log_curr_filename_ptr = (int)log_file_name;
}
// 200037E0: using guessed type int log_curr_filename_ptr;
// 20003A64: using guessed type __int16 log_file_chain_idx;

//----- (08012C3C) --------------------------------------------------------
void __fastcall log_file_build_name(signed int result)
{
  log_file_name[0] = curr_year / 10 + 48;
  log_file_name[1] = (unsigned __int16)(curr_year % 10) + 48;
  log_file_name[2] = curr_month / 10 + 48;
  log_file_name[3] = (unsigned __int16)(curr_month % 10) + 48;
  log_file_name[4] = curr_day / 10 + 48;
  log_file_name[5] = (unsigned __int16)(curr_day % 10) + 48;
  log_file_name[6] = result / 10 + 48;
  log_file_name[7] = result % 10 + 48;
  log_file_name[8] = '.';
  log_file_name[9] = 'c';
  log_file_name[10] = 's';
  log_file_name[11] = 'v';
  log_curr_filename_ptr = (int)log_file_name;
}
// 200037E0: using guessed type int log_curr_filename_ptr;

//----- (08012D0A) --------------------------------------------------------
int log_write_samples_to_file()
{
  unsigned __int8 v0; // r5@1
  int result; // r0@2
  unsigned __int16 i; // r4@4

  v0 = 0;
  curr_log_cache_pos = 0;
  if ( log_file_need_to_write_header )
  {
    LOBYTE(result) = log_file_write_header_lines();
    v0 = result;
    if ( (_BYTE)result )
      return (unsigned __int8)result;
  }
  else
  {
    log_file_total_samples_written_backup = log_file_total_samples_written;
    for ( i = 0; i < (unsigned int)log_samples_in_eeprom_that_need_flushing; ++i )
    {
      ++log_file_total_samples_written;
      LOBYTE(result) = log_file_write_sample(i);
      v0 = result;
      if ( (_BYTE)result )
      {
        log_second_byte_of_vol_path_str_never_read = 1;
        log_file_total_samples_written = log_file_total_samples_written_backup;
        return (unsigned __int8)result;
      }
      log_file_prepare_to_write_next_sample();
    }
    log_file_total_samples_written_backup = 0;
    if ( log_samples_in_eeprom_that_need_flushing == 60 )
      ++log_successful_flushes;
    log_samples_in_eeprom_that_need_flushing = 0;
  }
  return v0;
}
// 8012D0A: using guessed type int log_write_samples_to_file(void);
// 2000382C: using guessed type int log_successful_flushes;
// 20003834: using guessed type int log_file_total_samples_written;
// 20003838: using guessed type int log_samples_in_eeprom_that_need_flushing;
// 2000383C: using guessed type int log_file_total_samples_written_backup;
// 20003A4C: using guessed type __int16 curr_log_cache_pos;
// 20003A98: using guessed type char log_second_byte_of_vol_path_str_never_read;
// 20003ACE: using guessed type char log_file_need_to_write_header;

//----- (08012DB8) --------------------------------------------------------
void __fastcall log_file_prepare_to_write_next_sample()
{
  char v0; // r5@10

  if ( log_file_total_samples_written == 1 )
  {
    sub_8012F30();
  }
  else if ( byte_20003AD1 & 0x80 && byte_20003AD1 & 0x40 )
  {
    sub_8012E4A();
  }
  else if ( !(byte_20003AD1 & 0x80) )
  {
    sub_8012E4A();
  }
  if ( log_file_total_samples_written == 1 )
  {
    sub_8012F68();
  }
  else
  {
    v0 = byte_20003AD2 & 0x40;
    if ( !(byte_20003AD2 & 0x80) || v0 )
    {
      if ( !(byte_20003AD2 & 0x80) || !v0 )
        sub_8012EBC();
    }
    else
    {
      sub_8012EBC();
    }
  }
}
// 20003834: using guessed type int log_file_total_samples_written;
// 20003AD1: using guessed type char byte_20003AD1;
// 20003AD2: using guessed type char byte_20003AD2;

//----- (08012E4A) --------------------------------------------------------
void __fastcall sub_8012E4A()
{
  int v0; // r5@5
  int v1; // r4@8

  if ( (!(log_rdsamp_B_flags & 0x80) || !(log_rdsamp_B_flags & 0x40)) && !(log_rdsamp_B_flags & 0x80) )
  {
    if ( byte_20003AD1 & 0x40 )
      v0 = ~dword_20003840;
    else
      v0 = dword_20003840;
    if ( log_rdsamp_B_flags & 0x40 )
      v1 = ~log_rdsamp_C_main_measurement;
    else
      v1 = log_rdsamp_C_main_measurement;
    if ( v0 < v1 )
      sub_8012F30();
  }
}
// 20003814: using guessed type int log_rdsamp_C_main_measurement;
// 20003840: using guessed type int dword_20003840;
// 20003AB1: using guessed type char log_rdsamp_B_flags;
// 20003AD1: using guessed type char byte_20003AD1;

//----- (08012EBC) --------------------------------------------------------
void __fastcall sub_8012EBC()
{
  int v0; // r5@5
  int v1; // r4@8

  if ( (!(log_rdsamp_B_flags & 0x80) || log_rdsamp_B_flags & 0x40)
    && !((unsigned __int8)(log_rdsamp_B_flags & 0x80) & log_rdsamp_B_flags & 0x40) )
  {
    if ( byte_20003AD2 & 0x40 )
      v0 = ~dword_20003844;
    else
      v0 = dword_20003844;
    if ( log_rdsamp_B_flags & 0x40 )
      v1 = ~log_rdsamp_C_main_measurement;
    else
      v1 = log_rdsamp_C_main_measurement;
    if ( v1 < v0 )
      sub_8012F68();
  }
}
// 20003814: using guessed type int log_rdsamp_C_main_measurement;
// 20003844: using guessed type int dword_20003844;
// 20003AB1: using guessed type char log_rdsamp_B_flags;
// 20003AD2: using guessed type char byte_20003AD2;

//----- (08012F30) --------------------------------------------------------
void __fastcall sub_8012F30()
{
  dword_20003848 = log_file_total_samples_written;
  byte_20003ACF = log_rdsamp_A_range_mode;
  byte_20003AD1 = log_rdsamp_B_flags;
  dword_20003840 = log_rdsamp_C_main_measurement;
}
// 20003814: using guessed type int log_rdsamp_C_main_measurement;
// 20003834: using guessed type int log_file_total_samples_written;
// 20003840: using guessed type int dword_20003840;
// 20003848: using guessed type int dword_20003848;
// 20003AB0: using guessed type char log_rdsamp_A_range_mode;
// 20003AB1: using guessed type char log_rdsamp_B_flags;
// 20003ACF: using guessed type char byte_20003ACF;
// 20003AD1: using guessed type char byte_20003AD1;

//----- (08012F68) --------------------------------------------------------
int *sub_8012F68()
{
  int *result; // r0@1

  dword_2000384C = log_file_total_samples_written;
  byte_20003AD0 = log_rdsamp_A_range_mode;
  byte_20003AD2 = log_rdsamp_B_flags;
  result = &dword_20003844;
  dword_20003844 = log_rdsamp_C_main_measurement;
  return result;
}
// 20003814: using guessed type int log_rdsamp_C_main_measurement;
// 20003834: using guessed type int log_file_total_samples_written;
// 20003844: using guessed type int dword_20003844;
// 2000384C: using guessed type int dword_2000384C;
// 20003AB0: using guessed type char log_rdsamp_A_range_mode;
// 20003AB1: using guessed type char log_rdsamp_B_flags;
// 20003AD0: using guessed type char byte_20003AD0;
// 20003AD2: using guessed type char byte_20003AD2;

//----- (08012FE4) --------------------------------------------------------
bool __fastcall log_file_write_sample(unsigned __int16 sample_idx)
{
  bool result; // r0@2

  if ( log_write_num_then_comma(log_file_total_samples_written) )
    return 1;
  log_read_sample_from_eeprom(sample_idx);
  if ( log_write_mode(log_rdsamp_mode) )
    return 1;
  if ( log_rdsamp_B_flags & 0x80 )              // sign
  {
    if ( log_rdsamp_B_flags & 0x40 )            // overflow
    {
      if ( write_log_token(TOK_NEGOVERFLOW, 0, 0) )
        return 1;
    }
    else if ( write_log_token(TOK_POSOVERFLOW, 0, 0) )
    {
      return 1;
    }
  }
  else
  {
    if ( log_rdsamp_B_flags & 0x40 && write_log_token(TOK_MINUS, 0, 0) )
      return 1;
    if ( log_write_measurement(log_rdsamp_mode, log_rdsamp_range, log_rdsamp_C_main_measurement) )
      return 1;
  }
  if ( write_log_token(TOK_COMMA, 0, 0) )
    return 1;
  if ( log_write_unit(log_rdsamp_mode, log_rdsamp_range) )
    return 1;
  if ( log_rdsamp_mode != MM_ACuA
    && log_rdsamp_mode != MM_ACmA
    && log_rdsamp_mode != MM_ACA
    && (log_rdsamp_mode != MM_ACV || log_rdsamp_in_ac_dc_mode)
    && log_rdsamp_mode != MM_ACmV
    && log_rdsamp_mode != MM_ACuVA
    && log_rdsamp_mode != MM_ACmVA
    && log_rdsamp_mode != MM_ACVA
    && log_rdsamp_mode != MM_DCuVA
    && log_rdsamp_mode != MM_DCmVA
    && log_rdsamp_mode != MM_DCVA )
  {
    // skip volts display for measurements that don't need it
    if ( write_log_token(TOK_COMMA, 0, 0) )
      return 1;
    if ( write_log_token(TOK_COMMA, 0, 0) )
      return 1;
    if ( write_log_token(TOK_COMMA, 0, 0) )
      return 1;
    if ( write_log_token(TOK_COMMA, 0, 0) )
      return 1;
    if ( write_log_token(TOK_COMMA, 0, 0) )
      return 1;
    if ( write_log_token(TOK_COMMA, 0, 0) )
      return 1;
  }
  else
  {
    if ( log_write_mode((meter_meas_mode)log_rdsamp_ex_volt_mode) )
      return 1;
    if ( log_rdsamp_E_ex_volt_flags & 0x80 )
    {
      if ( write_log_token(TOK_POSOVERFLOW, 0, 0) )
        return 1;
    }
    else
    {
      if ( log_rdsamp_F_ex_volt_value < 0 )
      {
        if ( write_log_token(TOK_MINUS, 0, 0) )
          return 1;
        log_rdsamp_F_ex_volt_value = -log_rdsamp_F_ex_volt_value;
      }
      if ( log_write_measurement(
             (meter_meas_mode)log_rdsamp_ex_volt_mode,
             log_rdsamp_ex_volt_range,
             log_rdsamp_F_ex_volt_value) )
        return 1;
    }
    if ( write_log_token(TOK_COMMA, 0, 0) )
      return 1;
    if ( log_write_unit((meter_meas_mode)log_rdsamp_ex_volt_mode, log_rdsamp_ex_volt_range) )
      return 1;
    if ( log_rdsamp_mode != MM_ACuVA
      && log_rdsamp_mode != MM_ACmVA
      && log_rdsamp_mode != MM_ACVA
      && log_rdsamp_mode != MM_DCuVA
      && log_rdsamp_mode != MM_DCmVA
      && log_rdsamp_mode != MM_DCVA )
    {
      if ( write_log_token(TOK_COMMA, 0, 0) )
        return 1;
      if ( write_log_token(TOK_COMMA, 0, 0) )
        return 1;
      if ( write_log_token(TOK_COMMA, 0, 0) )
        return 1;
    }
    else
    {
      if ( log_write_mode((meter_meas_mode)log_rdsamp_ex_amp_mode) )
        return 1;
      if ( log_rdsamp_H_ex_amp_flags & 0x80 )
      {
        if ( write_log_token(TOK_POSOVERFLOW, 0, 0) )
          return 1;
      }
      else
      {
        if ( log_rdsamp_I_ex_amp_value < 0 )
        {
          if ( write_log_token(TOK_MINUS, 0, 0) )
            return 1;
          log_rdsamp_I_ex_amp_value = -log_rdsamp_I_ex_amp_value;
        }
        if ( log_write_measurement(
               (meter_meas_mode)log_rdsamp_ex_amp_mode,
               log_rdsamp_ex_amp_range,
               log_rdsamp_I_ex_amp_value) )
          return 1;
      }
      if ( write_log_token(TOK_COMMA, 0, 0) )
        return 1;
      if ( log_write_unit((meter_meas_mode)log_rdsamp_ex_amp_mode, log_rdsamp_ex_amp_range) )
        return 1;
    }
  }
  if ( log_rdsamp_input_1ms_peak_enabled )
  {
    if ( write_log_token(TOK_PEAKHOLD, 0, 0) )
      return 1;
  }
  else if ( log_rdsamp_input_lpf_enabled )
  {
    if ( write_log_token(TOK_1KHZ, 0, 0) )
      return 1;
  }
  else if ( log_rdsamp_in_ac_dc_mode && write_log_token(TOK_ACDC, 0, 0) )
  {
    return 1;
  }
  if ( write_log_token(TOK_COMMA, 0, 0) )
    result = 1;
  else
    result = write_log_token(TOK_CRLF, 0, 0) != 0;
  return result;
}
// 20003814: using guessed type int log_rdsamp_C_main_measurement;
// 20003818: using guessed type int log_rdsamp_F_ex_volt_value;
// 2000381C: using guessed type int log_rdsamp_I_ex_amp_value;
// 20003834: using guessed type int log_file_total_samples_written;
// 20003AA3: using guessed type char log_rdsamp_input_lpf_enabled;
// 20003AA4: using guessed type char log_rdsamp_input_1ms_peak_enabled;
// 20003AA5: using guessed type char log_rdsamp_in_ac_dc_mode;
// 20003AB1: using guessed type char log_rdsamp_B_flags;
// 20003AB3: using guessed type char log_rdsamp_E_ex_volt_flags;
// 20003AB5: using guessed type char log_rdsamp_H_ex_amp_flags;
// 20003AC7: using guessed type char log_rdsamp_range;
// 20003AC8: using guessed type char log_rdsamp_ex_volt_mode;
// 20003AC9: using guessed type char log_rdsamp_ex_volt_range;
// 20003ACA: using guessed type char log_rdsamp_ex_amp_mode;
// 20003ACB: using guessed type char log_rdsamp_ex_amp_range;

//----- (080133F4) --------------------------------------------------------
int __fastcall f_get_len(void *a1)
{
  return *((_DWORD *)a1 + 2);
}

//----- (080133FC) --------------------------------------------------------
bool __fastcall log_write_num_then_comma(int a1)
{
  bool result; // r0@2

  if ( write_log_token(TOK_WRITE_NUM, a1, 0) )
    result = 1;
  else
    result = write_log_token(TOK_COMMA, 0, 0) != 0;
  return result;
}

//----- (0801342C) --------------------------------------------------------
int __fastcall log_write_mode(meter_meas_mode mode)
{
  char v1; // r5@1
  meter_meas_mode v2; // r4@1

  v1 = 0;
  v2 = mode;
  if ( (signed int)(unsigned __int8)mode >= 26 )
    v2 = 2;
  if ( write_log_token((LOG_TOKENS)((unsigned __int8)v2 + 21), 0, 0) )
    v1 = 1;
  return (unsigned __int8)v1;
}

//----- (0801345A) --------------------------------------------------------
signed int __fastcall log_write_unit(meter_meas_mode mode, unsigned __int8 range)
{
  if ( mode == MM_LOW_Z )
  {
    if ( log_rdsamp_lowz_measuring_ac )
    {
      if ( write_log_token(TOK_ACV_UNIT, 0, 0) )
        return 1;
    }
    else if ( write_log_token(TOK_DCV_UNIT, 0, 0) )
    {
      return 1;
    }
    return 0;
  }
  if ( mode == 2 || (unsigned __int8)mode < 2u )
  {
    if ( write_log_token(TOK_V, 0, 0) )
      return 1;
    return 0;
  }
  if ( mode == 4 || (unsigned __int8)mode < 4u )
  {
    if ( write_log_token(TOK_mV, 0, 0) )
      return 1;
    return 0;
  }
  if ( mode == 6 )
  {
    if ( (signed int)range >= 2 )
    {
      if ( write_log_token(TOK_KHZ, 0, 0) )
        return 1;
    }
    else if ( write_log_token(TOK_HZ, 0, 0) )
    {
      return 1;
    }
    return 0;
  }
  if ( (unsigned __int8)mode < 6u )
  {
    if ( log_rdsamp_temp_in_c )
    {
      if ( write_log_token(TOK_DEG_C, 0, 0) )
        return 1;
    }
    else if ( write_log_token(TOK_DEG_F, 0, 0) )
    {
      return 1;
    }
    return 0;
  }
  if ( mode == 8 )
  {
    if ( write_log_token(TOK_PERCENT, 0, 0) )
      return 1;
    return 0;
  }
  if ( (unsigned __int8)mode < 8u )
  {
    if ( write_log_token(TOK_mSEC, 0, 0) )
      return 1;
    return 0;
  }
  if ( mode == 10 )
  {
    if ( write_log_token(TOK_OHM_UNIT, 0, 0) )
      return 1;
    return 0;
  }
  if ( (unsigned __int8)mode < 0xAu )
  {
    if ( (signed int)range >= 2 )
    {
      if ( (signed int)range >= 5 )
      {
        if ( write_log_token(TOK_MOHM, 0, 0) )
          return 1;
      }
      else if ( write_log_token(TOK_KOHM, 0, 0) )
      {
        return 1;
      }
    }
    else if ( write_log_token(TOK_OHM_UNIT, 0, 0) )
    {
      return 1;
    }
    return 0;
  }
  if ( mode == 12 )
  {
    if ( (signed int)range >= 2 )
    {
      if ( write_log_token(TOK_uF, 0, 0) )
        return 1;
    }
    else if ( write_log_token(TOK_nF, 0, 0) )
    {
      return 1;
    }
    return 0;
  }
  if ( (unsigned __int8)mode < 0xCu )
  {
    if ( write_log_token(TOK_V, 0, 0) )
      return 1;
    return 0;
  }
  if ( mode == 14 )
  {
LABEL_82:
    if ( write_log_token(TOK_mVA_UNIT, 0, 0) )
      return 1;
    return 0;
  }
  if ( (unsigned __int8)mode < 0xEu )
  {
LABEL_79:
    if ( write_log_token(TOK_uVA_UNIT, 0, 0) )
      return 1;
    return 0;
  }
  if ( mode == 16 )
    goto LABEL_108;
  if ( (unsigned __int8)mode < 0x10u )
    goto LABEL_85;
  if ( mode == 18 )
    goto LABEL_94;
  if ( (unsigned __int8)mode < 0x12u )
  {
LABEL_108:
    if ( write_log_token(TOK_uA, 0, 0) )
      return 1;
    return 0;
  }
  if ( mode == 20 )
    goto LABEL_97;
  if ( (unsigned __int8)mode < 0x14u )
  {
LABEL_94:
    if ( write_log_token(TOK_mA, 0, 0) )
      return 1;
    return 0;
  }
  if ( mode == 22 )
    goto LABEL_79;
  if ( (unsigned __int8)mode < 0x16u )
  {
LABEL_97:
    if ( range )
    {
      if ( write_log_token(TOK_AMP, 0, 0) )
        return 1;
    }
    else if ( write_log_token(TOK_mA, 0, 0) )
    {
      return 1;
    }
    return 0;
  }
  if ( mode == 24 )
  {
LABEL_85:
    if ( range )
    {
      if ( write_log_token(TOK_VA_UNIT, 0, 0) )
        return 1;
    }
    else if ( write_log_token(TOK_mVA_UNIT, 0, 0) )
    {
      return 1;
    }
    return 0;
  }
  if ( (unsigned __int8)mode < 0x18u )
    goto LABEL_82;
  if ( mode == 25 && write_log_token(TOK_mV, 0, 0) )
    return 1;
  return 0;
}
// 20003AA1: using guessed type char log_rdsamp_lowz_measuring_ac;
// 20003AA6: using guessed type char log_rdsamp_temp_in_c;

//----- (08013714) --------------------------------------------------------
int log_file_write_header_lines()
{
  int v0; // r0@1
  int result; // r0@1

  v0 = f_get_len(&f_file_structure);
  log_file_curr_pos = v0;
  log_file_start_pos = v0;
  LOBYTE(result) = log_file_write_header_line1();
  if ( (_BYTE)result )
  {
    result = (unsigned __int8)result;
  }
  else
  {
    LOBYTE(result) = log_file_write_header_line2();
    if ( (_BYTE)result )
    {
      result = (unsigned __int8)result;
    }
    else
    {
      LOBYTE(result) = log_file_write_header_line3();
      if ( (_BYTE)result )
      {
        result = (unsigned __int8)result;
      }
      else
      {
        LOBYTE(result) = log_file_write_header_line4();
        if ( (_BYTE)result )
        {
          result = (unsigned __int8)result;
        }
        else
        {
          LOBYTE(result) = log_file_write_header_line5();
          if ( (_BYTE)result )
            result = (unsigned __int8)result;
          else
            result = 0;
        }
      }
    }
  }
  return result;
}
// 200037F4: using guessed type int log_file_start_pos;
// 200037F8: using guessed type int log_file_curr_pos;

//----- (080137C0) --------------------------------------------------------
bool log_file_write_header_line4()
{
  bool result; // r0@2

  if ( write_log_token(TOK_MAIN, 0, 0) )
  {
    result = 1;
  }
  else if ( write_log_token(TOK_SUB1, 0, 0) )
  {
    result = 1;
  }
  else if ( write_log_token(TOK_SUB2, 0, 0) )
  {
    result = 1;
  }
  else if ( write_log_token(TOK_REMARK, 0, 0) )
  {
    result = 1;
  }
  else
  {
    result = write_log_token(TOK_CRLF, 0, 0) != 0;
  }
  return result;
}

//----- (08013824) --------------------------------------------------------
bool log_file_write_header_line5()
{
  bool result; // r0@2
  unsigned __int8 i; // r5@3

  if ( write_log_token(TOK_No_AS_IN_NUMBER, 0, 0) )
  {
    result = 1;
  }
  else
  {
    for ( i = 0; (signed int)i < 3; ++i )
    {
      if ( write_log_token(TOK_FUNC, 0, 0) )
        return 1;
      if ( write_log_token(TOK_VALUE, 0, 0) )
        return 1;
      if ( write_log_token(TOK_UNIT, 0, 0) )
        return 1;
    }
    result = write_log_token(TOK_CRLF, 0, 0) != 0;
  }
  return result;
}

//----- (08013896) --------------------------------------------------------
bool log_file_write_header_line2()
{
  bool result; // r0@2

  if ( write_log_token(TOK_ID, 0, 0) )
  {
    result = 1;
  }
  else if ( write_log_token(TOK_CAL_DATE_AND_SERIAL, 0, 0) )
  {
    result = 1;
  }
  else
  {
    result = write_log_token(TOK_CRLF, 0, 0) != 0;
  }
  return result;
}

//----- (080138D6) --------------------------------------------------------
bool log_file_write_header_line1()
{
  bool result; // r0@2

  if ( write_log_token(TOK_START, 0, 0) )
  {
    result = 1;
  }
  else if ( write_log_token(TOK_START_DATE, 0, 0) )
  {
    result = 1;
  }
  else if ( write_log_token(TOK_START_TIME, 0, 0) )
  {
    result = 1;
  }
  else
  {
    result = write_log_token(TOK_CRLF, 0, 0) != 0;
  }
  return result;
}

//----- (08013928) --------------------------------------------------------
bool log_write_footer()
{
  bool result; // r0@2

  log_rdsamp_mode = byte_20003ACF & 0x1F;
  log_rdsamp_range = (unsigned __int8)byte_20003ACF >> 5;
  if ( write_log_token(TOK_MAX, 0, 0) )
    return 1;
  if ( log_write_num_then_comma(dword_20003848) )
    return 1;
  if ( log_write_mode(log_rdsamp_mode) )
    return 1;
  if ( byte_20003AD1 & 0x80 )
  {
    if ( byte_20003AD1 & 0x40 )
    {
      if ( write_log_token(TOK_NEGOVERFLOW, 0, 0) )
        return 1;
    }
    else if ( write_log_token(TOK_POSOVERFLOW, 0, 0) )
    {
      return 1;
    }
  }
  else
  {
    if ( byte_20003AD1 & 0x40 && write_log_token(TOK_MINUS, 0, 0) )
      return 1;
    if ( log_write_measurement(log_rdsamp_mode, log_rdsamp_range, dword_20003840) )
      return 1;
  }
  if ( write_log_token(0, 0, 0) )
    return 1;
  if ( log_write_unit(log_rdsamp_mode, log_rdsamp_range) )
    return 1;
  if ( write_log_token(TOK_CRLF, 0, 0) )
    return 1;
  log_rdsamp_mode = byte_20003AD0 & 0x1F;
  log_rdsamp_range = (unsigned __int8)byte_20003AD0 >> 5;
  if ( write_log_token(TOK_MIN, 0, 0) )
    return 1;
  if ( log_write_num_then_comma(dword_2000384C) )
    return 1;
  if ( log_write_mode(log_rdsamp_mode) )
    return 1;
  if ( byte_20003AD2 & 0x80 )
  {
    if ( byte_20003AD2 & 0x40 )
    {
      if ( write_log_token(TOK_NEGOVERFLOW, 0, 0) )
        return 1;
    }
    else if ( write_log_token(TOK_POSOVERFLOW, 0, 0) )
    {
      return 1;
    }
  }
  else
  {
    if ( byte_20003AD2 & 0x40 && write_log_token(TOK_MINUS, 0, 0) )
      return 1;
    if ( log_write_measurement(log_rdsamp_mode, log_rdsamp_range, dword_20003844) )
      return 1;
  }
  if ( write_log_token(0, 0, 0) )
  {
    result = 1;
  }
  else if ( log_write_unit(log_rdsamp_mode, log_rdsamp_range) )
  {
    result = 1;
  }
  else
  {
    result = write_log_token(TOK_CRLF, 0, 0) != 0;
  }
  return result;
}
// 20003840: using guessed type int dword_20003840;
// 20003844: using guessed type int dword_20003844;
// 20003848: using guessed type int dword_20003848;
// 2000384C: using guessed type int dword_2000384C;
// 20003AC7: using guessed type char log_rdsamp_range;
// 20003ACF: using guessed type char byte_20003ACF;
// 20003AD0: using guessed type char byte_20003AD0;
// 20003AD1: using guessed type char byte_20003AD1;
// 20003AD2: using guessed type char byte_20003AD2;

//----- (08013B70) --------------------------------------------------------
bool log_file_write_header_line3()
{
  bool result; // r0@2

  if ( write_log_token(TOK_INTERVAL, 0, 0) )
  {
    result = 1;
  }
  else if ( write_log_token(TOK_CURR_LOGGING_INTERVAL, 0, 0) )
  {
    result = 1;
  }
  else if ( write_log_token(TOK_SEC, 0, 0) )
  {
    result = 1;
  }
  else
  {
    result = write_log_token(TOK_CRLF, 0, 0) != 0;
  }
  return result;
}

//----- (08013BC2) --------------------------------------------------------
int __fastcall log_write_measurement(meter_meas_mode mode, unsigned __int8 range, int a3)
{
  int v3; // r6@1
  unsigned __int8 v4; // r0@1

  v3 = a3;
  v4 = calc_decimal_place_for_mode_range(mode, range);
  return (unsigned __int8)write_log_token(TOK_WRITE_DEC_NUM, v3, v4);
}

//----- (08013BF6) --------------------------------------------------------
signed int __fastcall write_log_token(LOG_TOKENS token, unsigned int num, unsigned __int8 point)
{
  unsigned __int16 v3; // r0@77
  unsigned __int16 v5; // r0@80
  unsigned __int16 v6; // r0@83
  unsigned __int16 v7; // r0@86
  unsigned __int16 v8; // r0@89
  unsigned __int16 v9; // r0@92
  unsigned __int16 v10; // r0@95
  unsigned __int16 v11; // r0@98
  unsigned __int16 v12; // r0@101
  unsigned __int16 v13; // r0@104
  unsigned __int16 v14; // r0@107
  unsigned __int16 v15; // r0@110
  unsigned __int16 v16; // r0@113
  unsigned __int16 v17; // r0@116
  unsigned __int16 v18; // r0@119
  unsigned __int16 v19; // r0@122
  unsigned __int16 v20; // r0@125
  unsigned __int16 v21; // r0@128
  unsigned __int16 v22; // r0@131
  unsigned __int16 v23; // r0@134
  unsigned __int16 v24; // r0@137
  unsigned __int16 v25; // r0@140
  unsigned __int16 v26; // r0@143
  unsigned __int16 v27; // r0@146
  unsigned __int16 v28; // r0@149
  unsigned __int16 v29; // r0@152
  unsigned __int16 v30; // r0@155
  unsigned __int16 v31; // r0@158
  unsigned __int16 v32; // r0@161
  unsigned __int16 v33; // r0@164
  unsigned __int16 v34; // r0@167
  unsigned __int16 v35; // r0@170
  unsigned __int16 v36; // r0@173
  unsigned __int16 v37; // r0@176
  unsigned __int16 v38; // r0@179
  unsigned __int16 v39; // r0@182
  unsigned __int16 v40; // r0@185
  unsigned __int16 v41; // r0@188
  unsigned __int16 v42; // r0@191
  unsigned __int16 v43; // r0@194
  unsigned __int16 v44; // r0@197
  unsigned __int16 v45; // r0@200
  unsigned __int16 v46; // r0@203
  unsigned __int16 v47; // r0@206
  unsigned __int16 v48; // r0@209
  unsigned __int16 v49; // r0@212
  unsigned __int16 v50; // r0@215
  unsigned __int16 v51; // r0@218
  unsigned __int16 v52; // r0@221
  unsigned __int16 v53; // r0@224
  unsigned __int16 v54; // r0@227
  unsigned __int16 v55; // r0@230
  unsigned __int16 v56; // r0@233
  unsigned __int16 v57; // r0@236
  unsigned __int16 v58; // r0@239
  unsigned __int16 v59; // r0@242
  unsigned __int16 v60; // r0@245
  unsigned __int16 v61; // r0@248
  unsigned __int16 v62; // r0@251
  unsigned __int16 v63; // r0@254
  unsigned __int16 v64; // r0@257
  unsigned __int16 v65; // r0@260
  unsigned __int16 v66; // r0@263
  unsigned __int16 v67; // r0@266
  unsigned __int16 v68; // r0@269
  unsigned __int16 v69; // r0@272
  unsigned __int16 v70; // r0@275
  unsigned __int16 v71; // r0@278
  unsigned __int16 v72; // r0@281
  int v73; // r0@284
  char *v74; // r8@284
  unsigned __int16 v75; // r0@284
  int v76; // r9@287
  unsigned __int16 v77; // r0@287
  unsigned __int16 v78; // r0@290
  unsigned __int16 v79; // r0@293
  unsigned __int16 v80; // r0@296
  int v81; // r0@299
  char *v82; // r10@299
  unsigned __int16 v83; // r0@299
  char str_cache[41]; // [sp+0h] [bp-50h]@287

  *(_DWORD *)&token = (unsigned __int16)token;
  if ( token )
  {
    switch ( token )
    {
      case TOK_CRLF:
        v5 = strlen((int)asc_200001D4);
        if ( write_bytes_to_log_file_and_cache_them_too(asc_200001D4, v5) )
          return 1;
        break;
      case TOK_NEGOVERFLOW:
        v6 = strlen((int)aOverflow_1);
        if ( write_bytes_to_log_file_and_cache_them_too(aOverflow_1, v6) )
          return 1;
        break;
      case TOK_POSOVERFLOW:
        v7 = strlen((int)aOverflow_2);
        if ( write_bytes_to_log_file_and_cache_them_too(aOverflow_2, v7) )
          return 1;
        break;
      case TOK_MINUS:
        v8 = strlen((int)asc_20000216);
        if ( write_bytes_to_log_file_and_cache_them_too(asc_20000216, v8) )
          return 1;
        break;
      case TOK_START:
        v9 = strlen((int)aStart_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aStart_0, v9) )
          return 1;
        break;
      case TOK_ID:
        v10 = strlen((int)aId_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aId_0, v10) )
          return 1;
        break;
      case TOK_INTERVAL:
        v11 = strlen((int)aInterval_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aInterval_0, v11) )
          return 1;
        break;
      case TOK_SEC:
        v12 = strlen((int)aSec_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aSec_0, v12) )
          return 1;
        break;
      case TOK_MAIN:
        v13 = strlen((int)aMain_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aMain_0, v13) )
          return 1;
        break;
      case TOK_SUB1:
        v14 = strlen((int)aSub1_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aSub1_0, v14) )
          return 1;
        break;
      case TOK_SUB2:
        v15 = strlen((int)aSub2_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aSub2_0, v15) )
          return 1;
        break;
      case TOK_REMARK:
        v16 = strlen((int)aRemark_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aRemark_0, v16) )
          return 1;
        break;
      case TOK_No_AS_IN_NUMBER:
        v17 = strlen((int)aNo__0);
        if ( write_bytes_to_log_file_and_cache_them_too(aNo__0, v17) )
          return 1;
        break;
      case TOK_FUNC:
        v18 = strlen((int)aFunc__0);
        if ( write_bytes_to_log_file_and_cache_them_too(aFunc__0, v18) )
          return 1;
        break;
      case TOK_VALUE:
        v19 = strlen((int)aValue_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aValue_0, v19) )
          return 1;
        break;
      case TOK_UNIT:
        v20 = strlen((int)aUnit_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aUnit_0, v20) )
          return 1;
        break;
      case TOK_LOWZ:
        v21 = strlen((int)aLowz_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aLowz_0, v21) )
          return 1;
        break;
      case TOK_DCV_MODE:
        v22 = strlen((int)aDcv_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aDcv_0, v22) )
          return 1;
        break;
      case TOK_ACV_MODE:
        v23 = strlen((int)aAcv_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aAcv_0, v23) )
          return 1;
        break;
      case TOK_DCmV:
        v24 = strlen((int)aDcmv_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aDcmv_0, v24) )
          return 1;
        break;
      case TOK_ACmV:
        v25 = strlen((int)aAcmv_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aAcmv_0, v25) )
          return 1;
        break;
      case TOK_TEMP:
        v26 = strlen((int)aTemp__0);
        if ( write_bytes_to_log_file_and_cache_them_too(aTemp__0, v26) )
          return 1;
        break;
      case TOK_FREQ:
        v27 = strlen((int)aFreq__0);
        if ( write_bytes_to_log_file_and_cache_them_too(aFreq__0, v27) )
          return 1;
        break;
      case TOK_PULSE:
        v28 = strlen((int)aPulse_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aPulse_0, v28) )
          return 1;
        break;
      case TOK_DUTY:
        v29 = strlen((int)aDuty_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aDuty_0, v29) )
          return 1;
        break;
      case TOK_OHM_MODE:
        v30 = strlen((int)aOhm_1);
        if ( write_bytes_to_log_file_and_cache_them_too(aOhm_1, v30) )
          return 1;
        break;
      case TOK_BEEP_CONTINUITY:
        v31 = strlen((int)aBeep_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aBeep_0, v31) )
          return 1;
        break;
      case TOK_DIODE:
        v32 = strlen((int)aDiode_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aDiode_0, v32) )
          return 1;
        break;
      case TOK_CAP:
        v33 = strlen((int)aCap__0);
        if ( write_bytes_to_log_file_and_cache_them_too(aCap__0, v33) )
          return 1;
        break;
      case TOK_uVA_MODE:
        v34 = strlen((int)aUva_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aUva_0, v34) )
          return 1;
        break;
      case TOK_mVA_MODE:
        v35 = strlen((int)aMva_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aMva_0, v35) )
          return 1;
        break;
      case TOK_VA_MODE:
        v36 = strlen((int)aVa_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aVa_0, v36) )
          return 1;
        break;
      case TOK_ACuA:
        v37 = strlen((int)aAcua_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aAcua_0, v37) )
          return 1;
        break;
      case TOK_DCuA:
        v38 = strlen((int)aDcua_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aDcua_0, v38) )
          return 1;
        break;
      case TOK_ACmA:
        v39 = strlen((int)aAcma_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aAcma_0, v39) )
          return 1;
        break;
      case TOK_DCmA:
        v40 = strlen((int)aDcma_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aDcma_0, v40) )
          return 1;
        break;
      case TOK_ACA:
        v41 = strlen((int)aAca_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aAca_0, v41) )
          return 1;
        break;
      case TOK_DCA:
        v42 = strlen((int)aDca_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aDca_0, v42) )
          return 1;
        break;
      case TOK_DCuVA:
        v43 = strlen((int)aDcuva_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aDcuva_0, v43) )
          return 1;
        break;
      case TOK_DCmVA:
        v44 = strlen((int)aDcmva_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aDcmva_0, v44) )
          return 1;
        break;
      case TOK_DCVA:
        v45 = strlen((int)aDcva_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aDcva_0, v45) )
          return 1;
        break;
      case TOK_BURDEN:
        v46 = strlen((int)aBurden_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aBurden_0, v46) )
          return 1;
        break;
      case TOK_ACV_UNIT:
        v47 = strlen((int)aAcv_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aAcv_0, v47) )
          return 1;
        break;
      case TOK_DCV_UNIT:
        v48 = strlen((int)aDcv_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aDcv_0, v48) )
          return 1;
        break;
      case TOK_V:
        v49 = strlen((int)aV_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aV_0, v49) )
          return 1;
        break;
      case TOK_mV:
        v50 = strlen((int)aMv_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aMv_0, v50) )
          return 1;
        break;
      case TOK_DEG_C:
        v51 = strlen((int)aC_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aC_0, v51) )
          return 1;
        break;
      case TOK_DEG_F:
        v52 = strlen((int)aF_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aF_0, v52) )
          return 1;
        break;
      case TOK_HZ:
        v53 = strlen((int)aHz_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aHz_0, v53) )
          return 1;
        break;
      case TOK_KHZ:
        v54 = strlen((int)aKhz_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aKhz_0, v54) )
          return 1;
        break;
      case TOK_mSEC:
        v55 = strlen((int)aMsec_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aMsec_0, v55) )
          return 1;
        break;
      case TOK_PERCENT:
        v56 = strlen((int)asc_20000200);
        if ( write_bytes_to_log_file_and_cache_them_too(asc_20000200, v56) )
          return 1;
        break;
      case TOK_OHM_UNIT:
        v57 = strlen((int)aOhm_2);
        if ( write_bytes_to_log_file_and_cache_them_too(aOhm_2, v57) )
          return 1;
        break;
      case TOK_KOHM:
        v58 = strlen((int)aKohm_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aKohm_0, v58) )
          return 1;
        break;
      case TOK_MOHM:
        v59 = strlen((int)aMohm_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aMohm_0, v59) )
          return 1;
        break;
      case TOK_nF:
        v60 = strlen((int)aNf_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aNf_0, v60) )
          return 1;
        break;
      case TOK_uF:
        v61 = strlen((int)aUf_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aUf_0, v61) )
          return 1;
        break;
      case TOK_uVA_UNIT:
        v62 = strlen((int)aUva_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aUva_0, v62) )
          return 1;
        break;
      case TOK_mVA_UNIT:
        v63 = strlen((int)aMva_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aMva_0, v63) )
          return 1;
        break;
      case TOK_VA_UNIT:
        v64 = strlen((int)aVa_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aVa_0, v64) )
          return 1;
        break;
      case TOK_uA:
        v65 = strlen((int)aUa_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aUa_0, v65) )
          return 1;
        break;
      case TOK_mA:
        v66 = strlen((int)aMa_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aMa_0, v66) )
          return 1;
        break;
      case TOK_AMP:
        v67 = strlen((int)aA_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aA_0, v67) )
          return 1;
        break;
      case TOK_PEAKHOLD:
        v68 = strlen((int)aPeakhold_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aPeakhold_0, v68) )
          return 1;
        break;
      case TOK_1KHZ:
        v69 = strlen((int)a1khz_0);
        if ( write_bytes_to_log_file_and_cache_them_too(a1khz_0, v69) )
          return 1;
        break;
      case TOK_ACDC:
        v70 = strlen((int)aAcdc_1);
        if ( write_bytes_to_log_file_and_cache_them_too(aAcdc_1, v70) )
          return 1;
        break;
      case TOK_MAX:
        v71 = strlen((int)aMax_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aMax_0, v71) )
          return 1;
        break;
      case TOK_MIN:
        v72 = strlen((int)aMin_0);
        if ( write_bytes_to_log_file_and_cache_them_too(aMin_0, v72) )
          return 1;
        break;
      case TOK_WRITE_NUM:
        v73 = (int)uint_to_ascii(num);
        v74 = (char *)v73;
        v75 = strlen(v73);
        if ( write_bytes_to_log_file_and_cache_them_too(v74, v75) )
          return 1;
        break;
      case TOK_CURR_LOGGING_INTERVAL:
        str_cache[36] = curr_logging_interval / 100 + 48;
        v76 = curr_logging_interval % 100;
        str_cache[37] = v76 / 10 + 48;
        str_cache[38] = v76 % 10 + 48;
        str_cache[39] = ',';
        str_cache[40] = 0;
        v77 = strlen((int)&str_cache[36]);
        if ( write_bytes_to_log_file_and_cache_them_too(&str_cache[36], v77) )
          return 1;
        break;
      case TOK_START_DATE:
        str_cache[0] = '2';
        str_cache[1] = '0';
        str_cache[2] = (unsigned __int8)log_start_year / 10 + 48;
        str_cache[3] = (unsigned __int16)((unsigned __int8)log_start_year % 10) + 48;
        str_cache[4] = '/';
        str_cache[5] = (unsigned __int8)log_start_month / 10 + 48;
        str_cache[6] = (unsigned __int16)((unsigned __int8)log_start_month % 10) + 48;
        str_cache[7] = '/';
        str_cache[8] = (unsigned __int8)log_start_day / 10 + 48;
        str_cache[9] = (unsigned __int16)((unsigned __int8)log_start_day % 10) + 48;
        str_cache[10] = ',';
        str_cache[11] = 0;
        v78 = strlen((int)str_cache);
        if ( write_bytes_to_log_file_and_cache_them_too(str_cache, v78) )
          return 1;
        break;
      case TOK_START_TIME:
        str_cache[24] = (unsigned __int8)log_start_hour / 10 + 48;
        str_cache[25] = (unsigned __int16)((unsigned __int8)log_start_hour % 10) + 48;
        str_cache[26] = 58;
        str_cache[27] = (unsigned __int8)log_start_minute / 10 + 48;
        str_cache[28] = (unsigned __int16)((unsigned __int8)log_start_minute % 10) + 48;
        str_cache[29] = 58;
        str_cache[30] = (unsigned __int8)log_start_second / 10 + 48;
        str_cache[31] = (unsigned __int16)((unsigned __int8)log_start_second % 10) + 48;
        str_cache[32] = 44;
        str_cache[33] = 0;
        v79 = strlen((int)&str_cache[24]);
        if ( write_bytes_to_log_file_and_cache_them_too(&str_cache[24], v79) )
          return 1;
        break;
      case TOK_CAL_DATE_AND_SERIAL:
        conv_uint_to_bcd_tmp((unsigned __int16)last_cal_year_month);
        str_cache[12] = LOBYTE(disp_bcd_tmp[1]) + 48;
        str_cache[13] = LOBYTE(disp_bcd_tmp[2]) + 48;
        str_cache[14] = LOBYTE(disp_bcd_tmp[3]) + 48;
        str_cache[15] = LOBYTE(disp_bcd_tmp[4]) + 48;
        conv_uint_to_bcd_tmp(curr_meter_serial);
        str_cache[16] = LOBYTE(disp_bcd_tmp[0]) + 48;
        str_cache[17] = LOBYTE(disp_bcd_tmp[1]) + 48;
        str_cache[18] = LOBYTE(disp_bcd_tmp[2]) + 48;
        str_cache[19] = LOBYTE(disp_bcd_tmp[3]) + 48;
        str_cache[20] = LOBYTE(disp_bcd_tmp[4]) + 48;
        str_cache[21] = 44;
        str_cache[22] = 0;
        v80 = strlen((int)&str_cache[12]);
        if ( write_bytes_to_log_file_and_cache_them_too(&str_cache[12], v80) )
          return 1;
        break;
      case TOK_WRITE_DEC_NUM:
        v81 = (int)uint_to_ascii_with_point(num, point);
        v82 = (char *)v81;
        v83 = strlen(v81);
        if ( write_bytes_to_log_file_and_cache_them_too(v82, v83) )
          return 1;
        break;
    }
  }
  else
  {
    v3 = strlen((int)asc_20000214);
    if ( write_bytes_to_log_file_and_cache_them_too(asc_20000214, v3) )
      return 1;
  }
  return 0;
}
// 2000380C: using guessed type int curr_meter_serial;
// 20003890: using guessed type int disp_bcd_tmp[5];
// 20003AB7: using guessed type char log_start_year;
// 20003AB8: using guessed type char log_start_month;
// 20003AB9: using guessed type char log_start_day;
// 20003ABA: using guessed type char log_start_hour;
// 20003ABB: using guessed type char log_start_minute;
// 20003ABC: using guessed type char log_start_second;

//----- (0801490A) --------------------------------------------------------
signed int __fastcall write_bytes_to_log_file_and_cache_them_too(char *bytes, unsigned __int16 count)
{
  unsigned __int16 v2; // r5@1
  unsigned __int8 i; // r6@1
  signed int result; // r0@6

  v2 = count;
  for ( i = 0; i < (unsigned int)count; ++i )
    sd_cal_buf[(unsigned __int16)curr_log_cache_pos++] = bytes[i];
  f_op_err = f_write(&f_file_structure, bytes, count, &f_bytes_written_temp);
  if ( f_op_err || f_bytes_written_temp != v2 )
  {
    result = 1;
  }
  else
  {
    log_file_total_len += v2;
    result = 0;
  }
  return result;
}
// 200037F0: using guessed type int f_bytes_written_temp;
// 200037FC: using guessed type int log_file_total_len;
// 20003A4C: using guessed type __int16 curr_log_cache_pos;
// 20003A96: using guessed type char f_op_err;

//----- (080149B4) --------------------------------------------------------
int log_file_reread_and_verify()
{
  char v0; // r4@1
  int v1; // r8@1
  signed __int16 v2; // r6@3
  int v3; // r7@5
  unsigned __int16 i; // r5@9

  v0 = 8;
  v1 = 0;
  f_op_err = f_open(&f_file_structure, (char *)log_curr_filename_ptr, FA_READ);
  if ( !f_op_err )
  {
    f_op_err = f_seek((int)&f_file_structure, log_file_start_pos);
    if ( !f_op_err )
    {
      v2 = curr_log_cache_pos;
      while ( 1 )
      {
        LOWORD(v3) = (signed int)(unsigned __int16)v2 <= 512 ? v2 : 512;
        v2 -= v3;
        f_op_err = f_read(&f_file_structure, sd_readback_buf, (unsigned __int16)v3, &f_bytes_read_temp);
        if ( f_op_err || f_bytes_read_temp != (unsigned __int16)v3 )
          break;
        v0 = 0;
        for ( i = 0; ; ++i )
        {
          v3 = (unsigned __int16)v3;
          if ( i >= (unsigned int)(unsigned __int16)v3 )
            break;
          if ( *(&sd_cal_buf[i] + v1) != sd_readback_buf[i] )
          {
            v0 = 8;
            break;
          }
        }
        if ( !v0 )
        {
          if ( !v2 )
            goto LABEL_18;
          v1 += v3;
        }
      }
      v0 = 8;
    }
  }
LABEL_18:
  f_close((int)&f_file_structure);
  return (unsigned __int8)v0;
}
// 80149B4: using guessed type int log_file_reread_and_verify(void);
// 200037E0: using guessed type int log_curr_filename_ptr;
// 200037EC: using guessed type int f_bytes_read_temp;
// 200037F4: using guessed type int log_file_start_pos;
// 20003A4C: using guessed type __int16 curr_log_cache_pos;
// 20003A96: using guessed type char f_op_err;

//----- (08014AA8) --------------------------------------------------------
char *__fastcall uint_to_ascii(unsigned int num)
{
  unsigned int v1; // r1@1
  char *result; // r0@1

  v1 = num;
  result = &uint_to_ascii_unused;
  uint_to_ascii_unused = 0;
  do
  {
    --result;
    *result = v1 % 0xA + 48;
    v1 /= 0xAu;
  }
  while ( v1 );
  return result;
}
// 20003757: using guessed type char uint_to_ascii_unused;

//----- (08014AD8) --------------------------------------------------------
char *__fastcall uint_to_ascii_with_point(unsigned int num, unsigned __int8 place)
{
  unsigned int v2; // r2@1
  unsigned __int8 v3; // r3@1
  unsigned __int8 v4; // r4@1
  char *result; // r0@1

  v2 = num;
  v3 = 0;
  v4 = 0;
  result = &uint_to_ascii_with_point_unused_0;
  uint_to_ascii_with_point_unused_0 = 0;
  do
  {
    if ( place && place == v3 )
    {
      --result;
      *result = '.';
    }
    else
    {
      --result;
      *result = v2 % 0xA + 48;
      v2 /= 0xAu;
      ++v4;
    }
    ++v3;
  }
  while ( (signed int)v4 < 6 );
  return result;
}
// 2000379E: using guessed type char uint_to_ascii_with_point_unused_0;

//----- (08014B40) --------------------------------------------------------
int __fastcall f_mount_tries(unsigned __int8 a1)
{
  unsigned __int8 v1; // r4@1
  unsigned __int8 v2; // r5@1
  unsigned __int8 i; // r6@1

  v1 = a1;
  v2 = 0;
  for ( i = 0; i < (unsigned int)v1; ++i )
  {
    v2 = sd_sub_8014B6E();
    if ( !v2 )
      return 0;
  }
  return v2;
}
// 8014B6E: using guessed type int sd_sub_8014B6E(void);

//----- (08014B6E) --------------------------------------------------------
int sd_sub_8014B6E()
{
  char v0; // r4@1
  signed int v1; // r6@1
  signed int v2; // r0@3

  v0 = 0;
  v1 = 768;
  do
  {
    disable_sd_card_hw();
    if ( !sd_sub_8014BAA() )
      break;
    v2 = v1--;
  }
  while ( v2 );
  if ( v1 )
  {
    if ( !sub_801ECD2() )
      v0 = 2;
  }
  else
  {
    v0 = 1;
  }
  return (unsigned __int8)v0;
}
// 8014B6E: using guessed type int sd_sub_8014B6E(void);

//----- (08014BAA) --------------------------------------------------------
bool sd_sub_8014BAA()
{
  HAL_SD_Init();
  return sub_801E1E0(0, (int)&unk_20002938) != 0;
}

//----- (08014CEC) --------------------------------------------------------
void read_amp_lead_pos_then_update()
{
  char lead_pos; // r4@1
  char lead_pos_valid; // r5@1
  char changed_amp_range; // r6@1

  lead_pos = 0;
  lead_pos_valid = 0;
  changed_amp_range = 0;
  if ( !(GPIOE.IDR & 0x400) )
    lead_pos = 1;                               // mA jack sensor
  if ( !(GPIOE.IDR & 0x800) )
    lead_pos += 2;                              // A jack sensor
  if ( (unsigned __int8)amp_lead_pos_last == (unsigned __int8)lead_pos )
  {
    --amp_lead_pos_debounce_timer;
    if ( !amp_lead_pos_debounce_timer )
    {
      amp_lead_pos_debounce_timer = 10;
      amp_lead_in_ma_jack_only = lead_pos == 1;
      lead_pos_valid = 1;
    }
  }
  else
  {
    amp_lead_pos_last = lead_pos;
    amp_lead_pos_debounce_timer = 10;
  }
  if ( curr_meas_mode == MM_ACA && amp_lead_in_ma_jack_only )
  {
    curr_meas_mode = MM_ACmA;
    changed_amp_range = 1;
  }
  else if ( curr_meas_mode == MM_DCA && amp_lead_in_ma_jack_only )
  {
    curr_meas_mode = MM_DCmA;
    changed_amp_range = 1;
  }
  else if ( curr_meas_mode == MM_ACVA && amp_lead_in_ma_jack_only )
  {
    curr_meas_mode = MM_ACmVA;
    changed_amp_range = 1;
  }
  else if ( curr_meas_mode == MM_DCVA && amp_lead_in_ma_jack_only )
  {
    curr_meas_mode = MM_DCmVA;
    changed_amp_range = 1;
  }
  else if ( curr_meas_mode != MM_ACmA || amp_lead_in_ma_jack_only )
  {
    if ( curr_meas_mode != MM_DCmA || amp_lead_in_ma_jack_only )
    {
      if ( curr_meas_mode != MM_ACmVA || amp_lead_in_ma_jack_only )
      {
        if ( curr_meas_mode == MM_DCmVA && !amp_lead_in_ma_jack_only )
        {
          curr_meas_mode = MM_DCVA;
          changed_amp_range = 1;
        }
      }
      else
      {
        curr_meas_mode = MM_ACVA;
        changed_amp_range = 1;
      }
    }
    else
    {
      curr_meas_mode = MM_DCA;
      changed_amp_range = 1;
    }
  }
  else
  {
    curr_meas_mode = MM_ACA;
    changed_amp_range = 1;
  }
  if ( changed_amp_range )
  {
    meter_mode_changed = 1;
    meter_process_range_mode_changed(1);
  }
  if ( lead_pos_valid )
  {
    if ( lead_pos != 1 && lead_pos != 2 )
    {
      meter_amp_leads_incorrect = 0;
    }
    else if ( curr_meas_mode != MM_ACmA
           && curr_meas_mode != MM_ACA
           && curr_meas_mode != MM_DCmA
           && curr_meas_mode != MM_DCA )
    {
      if ( curr_meas_mode != MM_ACmVA
        && curr_meas_mode != MM_ACVA
        && curr_meas_mode != MM_DCmVA
        && curr_meas_mode != MM_DCVA )
      {
        if ( curr_meas_mode != MM_ACuA
          && curr_meas_mode != MM_DCuA
          && curr_meas_mode != MM_ACuVA
          && curr_meas_mode != MM_DCuVA )
        {
          meter_set_amp_leads_incorrect();
        }
        else if ( lead_pos == 2 )
        {
          meter_set_amp_leads_incorrect();
        }
        else
        {
          meter_amp_leads_incorrect = 0;
        }
      }
      else
      {
        meter_amp_leads_incorrect = 0;
      }
    }
    else
    {
      meter_amp_leads_incorrect = 0;
    }
  }
}
// 2000021F: using guessed type char amp_lead_pos_debounce_timer;
// 20003A8C: using guessed type char amp_lead_pos_last;
// 20003B11: using guessed type char amp_lead_in_ma_jack_only;
// 20003B12: using guessed type char meter_amp_leads_incorrect;
// 40021000: using guessed type GPIO_REGS GPIOE;

//----- (08014F48) --------------------------------------------------------
void __fastcall meter_set_amp_leads_incorrect()
{
  meter_amp_leads_incorrect = 1;
}
// 20003B12: using guessed type char meter_amp_leads_incorrect;

//----- (08014F52) --------------------------------------------------------
void update_mode_based_on_range_switch()
{
  char was_valid_switch; // r4@1

  was_valid_switch = 0;
  switch ( curr_range_switch_bits )
  {
    case 1u:
      curr_meas_mode = MM_LOW_Z;
      was_valid_switch = 1;
      break;
    case 2u:
      curr_meas_mode = get_last_mode_v();
      was_valid_switch = 1;
      break;
    case 4u:
      curr_meas_mode = get_last_mode_mv();
      was_valid_switch = 1;
      break;
    case 8u:
      curr_meas_mode = get_last_mode_hz();
      was_valid_switch = 1;
      break;
    case 0x10u:
      curr_meas_mode = get_last_mode_ohms();
      was_valid_switch = 1;
      break;
    case 0x20u:
      curr_meas_mode = get_last_mode_pwr();
      was_valid_switch = 1;
      break;
    case 0x40u:
      curr_meas_mode = get_last_mode_uA();
      was_valid_switch = 1;
      break;
    case 0x80u:
      curr_meas_mode = get_last_mode_A();
      was_valid_switch = 1;
      break;
  }
  if ( was_valid_switch )
  {
    curr_sys_error = 0;
    need_to_display_logging_ended = 0;
    meter_mode_changed = 1;
    manual_hold_is_enabled = 0;
    auto_hold_is_enabled = 0;
    lcd_update_from_auto_hold = 0;
    auto_hold_need_to_unhold = 0;
    TIM2_auto_hold_unhold_timer_1s = 0;
    auto_hold_holding = 0;
  }
}
// 20003A66: using guessed type __int16 TIM2_auto_hold_unhold_timer_1s;
// 20003AC5: using guessed type char need_to_display_logging_ended;
// 20003AF2: using guessed type char auto_hold_holding;

//----- (08015052) --------------------------------------------------------
void __fastcall meter_incr_mode()
{
  char did_change; // r4@1

  // Increments to the next mode when MODE is pressed

  // The loops are as follows:
  // * Low Z
  // * DCV -> ACV -> ACV/DCV
  // * DCmV -> ACmV -> Temp
  // * Hz -> mSec -> Duty
  // * Ohms -> Continuity -> Diode -> Cap
  // * DCVA -> ACVA and DCmVA -> ACmVA
  //   (switch controlled by lead position)
  // * DCuA -> ACuA -> DCuVA -> ACuVA
  // * DCmA -> ACmA and DCA -> ACA
  //   (switch controlled by lead position)

  did_change = 0;
  subscr_turn_off_units();
  if ( curr_meas_mode == MM_DCV )
  {
    curr_meas_mode = MM_ACV;
    did_change = 1;
  }
  else if ( curr_meas_mode >= (unsigned int)MM_DCV )
  {
    if ( curr_meas_mode == MM_DCmV )
    {
      curr_meas_mode = MM_ACmV;
      did_change = 1;
    }
    else if ( curr_meas_mode >= (unsigned int)MM_DCmV )
    {
      if ( curr_meas_mode == MM_TEMP )
      {
        curr_meas_mode = MM_DCmV;
        did_change = 1;
      }
      else if ( curr_meas_mode >= (unsigned int)MM_TEMP )
      {
        if ( curr_meas_mode == MM_mSEC )
        {
          curr_meas_mode = MM_DUTY;
          did_change = 1;
        }
        else if ( curr_meas_mode >= (unsigned int)MM_mSEC )
        {
          if ( curr_meas_mode == MM_OHMS )
          {
            curr_meas_mode = MM_CONTINUITY;
            did_change = 1;
          }
          else if ( curr_meas_mode >= (unsigned int)MM_OHMS )
          {
            if ( curr_meas_mode == MM_DIODE )
            {
              curr_meas_mode = MM_CAP;
              did_change = 1;
            }
            else if ( curr_meas_mode >= (unsigned int)MM_DIODE )
            {
              if ( curr_meas_mode == MM_ACuVA )
              {
                curr_meas_mode = MM_DCuA;
                did_change = 1;
              }
              else if ( curr_meas_mode >= (unsigned int)MM_ACuVA )
              {
                if ( curr_meas_mode == MM_ACVA )
                {
                  curr_meas_mode = MM_DCVA;
                  did_change = 1;
                }
                else if ( curr_meas_mode >= (unsigned int)MM_ACVA )
                {
                  if ( curr_meas_mode == MM_DCuA )
                  {
                    curr_meas_mode = MM_ACuA;
                    did_change = 1;
                  }
                  else if ( curr_meas_mode >= (unsigned int)MM_DCuA )
                  {
                    if ( curr_meas_mode == MM_DCmA )
                    {
                      curr_meas_mode = MM_ACmA;
                      did_change = 1;
                    }
                    else if ( curr_meas_mode >= (unsigned int)MM_DCmA )
                    {
                      if ( curr_meas_mode == MM_DCA )
                      {
                        curr_meas_mode = MM_ACA;
                        did_change = 1;
                      }
                      else if ( curr_meas_mode >= (unsigned int)MM_DCA )
                      {
                        if ( curr_meas_mode == MM_DCmVA )
                        {
                          curr_meas_mode = MM_ACmVA;
                          did_change = 1;
                        }
                        else if ( curr_meas_mode >= (unsigned int)MM_DCmVA )
                        {
                          if ( curr_meas_mode == MM_DCVA )
                          {
                            curr_meas_mode = MM_ACVA;
                            did_change = 1;
                          }
                        }
                        else
                        {
                          curr_meas_mode = MM_ACuVA;
                          did_change = 1;
                        }
                      }
                      else
                      {
                        curr_meas_mode = MM_DCA;
                        did_change = 1;
                      }
                    }
                    else
                    {
                      curr_meas_mode = MM_DCmA;
                      did_change = 1;
                    }
                  }
                  else
                  {
                    curr_meas_mode = MM_DCuVA;
                    did_change = 1;
                  }
                }
                else
                {
                  curr_meas_mode = MM_DCmVA;
                  did_change = 1;
                }
              }
              else
              {
                curr_meas_mode = MM_OHMS;
                did_change = 1;
              }
            }
            else
            {
              curr_meas_mode = MM_DIODE;
              did_change = 1;
            }
          }
          else
          {
            curr_meas_mode = MM_HZ;
            did_change = 1;
          }
        }
        else
        {
          curr_meas_mode = MM_mSEC;
          did_change = 1;
        }
      }
      else
      {
        curr_meas_mode = MM_TEMP;
        did_change = 1;
      }
    }
    else
    {
      meter_update_acv_dcv_mode();
      did_change = 1;
    }
  }
  meter_curr_mode_is_timey_not_used = 0;
  if ( curr_meas_mode == MM_HZ || curr_meas_mode == MM_mSEC || curr_meas_mode == MM_DUTY )
    meter_curr_mode_is_timey_not_used = 1;
  if ( did_change )
  {
    meter_mode_changed = 1;
    save_curr_meas_mode();
  }
}
// 20003B10: using guessed type char meter_curr_mode_is_timey_not_used;

//----- (0801524A) --------------------------------------------------------
void meter_update_acv_dcv_mode()
{
  if ( meter_mode_acv_dcv )
  {
    meter_mode_acv_dcv = 0;
    curr_meas_mode = MM_DCV;
  }
  else
  {
    meter_enable_acv_dcv_mode();
  }
}
// 20003B52: using guessed type char meter_mode_acv_dcv;

//----- (0801526E) --------------------------------------------------------
void meter_enable_acv_dcv_mode()
{
  meter_mode_acv_dcv = 1;
  input_lpf_enabled = 0;
  ac_input_freq_acv = 0;
  ac_input_freq_range_acv = 0;
  acv_dcv_measuring_dc = 0;
  meas_acv_dcv_dc_value_updated = 0;
  meas_acv_dcv_ac_value_updated = 0;
  meas_acv_dcv_mode_switch_timer = 15;
  meas_acv_dcv_dc_value = 0;
  meas_acv_dcv_ac_value = 0;
}
// 20003940: using guessed type int ac_input_freq_acv;
// 2000397C: using guessed type int meas_acv_dcv_dc_value;
// 20003980: using guessed type int meas_acv_dcv_ac_value;
// 20003B3A: using guessed type char ac_input_freq_range_acv;
// 20003B51: using guessed type char input_lpf_enabled;
// 20003B52: using guessed type char meter_mode_acv_dcv;
// 20003B53: using guessed type char meas_acv_dcv_ac_value_updated;
// 20003B54: using guessed type char meas_acv_dcv_dc_value_updated;
// 20003B55: using guessed type char acv_dcv_measuring_dc;

//----- (080152C8) --------------------------------------------------------
void meter_incr_range(void)
{
  if ( __PAIR__(auto_hold_is_enabled, manual_hold_is_enabled) )
  {
    beep_angrily();
  }
  else if ( (unsigned __int8)meter_in_cal_mode | (unsigned __int8)autoranging_disabled )
  {
    if ( (signed int)ranges_in_mode[(unsigned __int8)curr_meas_mode] < 2 )
    {
      beep_angrily();
    }
    else
    {
      ++curr_meas_range;
      if ( curr_meas_range >= (unsigned int)ranges_in_mode[(unsigned __int8)curr_meas_mode] )
        curr_meas_range = 0;
      meter_range_changed = 1;
      calc_power_ranges(curr_meas_mode, curr_meas_range);
      beep_contentedly();
    }
  }
  else if ( (signed int)ranges_in_mode[(unsigned __int8)curr_meas_mode] < 2 )
  {
    beep_angrily();
  }
  else
  {
    if ( !autoranging_disabled )
    {
      autoranging_disabled = 1;
      scr_update_autorange_icon(1);
    }
    beep_contentedly();
  }
}
// 20003AE6: using guessed type char autoranging_disabled;
// 20003AEC: using guessed type char meter_range_changed;
// 20003B23: using guessed type char cal_mode_load_from_sd;
// 20003B24: using guessed type char meter_in_cal_mode;

//----- (08015388) --------------------------------------------------------
void __fastcall calc_power_ranges(meter_meas_mode mode, unsigned int range)
{
  if ( curr_meas_mode == MM_ACuVA
    || curr_meas_mode == MM_ACmVA
    || curr_meas_mode == MM_ACVA
    || curr_meas_mode == MM_DCuVA
    || curr_meas_mode == MM_DCmVA
    || curr_meas_mode == MM_DCVA )
  {
    range = (unsigned __int8)range;
    if ( (_BYTE)range )
    {
      if ( range == 2 )
      {
        curr_power_volts_range = 0;
        curr_power_amps_range = 1;
      }
      else if ( range >= 2 )
      {
        if ( range == 3 )
        {
          curr_power_volts_range = 1;
          curr_power_amps_range = 1;
        }
      }
      else
      {
        curr_power_volts_range = 1;
        curr_power_amps_range = 0;
      }
    }
    else
    {
      curr_power_volts_range = 0;
      curr_power_amps_range = 0;
    }
    if ( (mode == MM_ACVA || mode == MM_DCVA) && curr_power_amps_range == 1 )
      curr_power_amps_range = 2;
  }
}
// 20003B5B: using guessed type char curr_power_volts_range;
// 20003B5C: using guessed type char curr_power_amps_range;

//----- (0801543C) --------------------------------------------------------
unsigned __int8 __cdecl get_meas_range_from_power_ranges()
{
  unsigned __int8 result; // r0@1

  result = 0;
  if ( !curr_power_volts_range || curr_power_amps_range )
  {
    if ( curr_power_volts_range || !curr_power_amps_range )
    {
      if ( curr_power_volts_range )
      {
        if ( curr_power_amps_range )
          result = 3;
      }
    }
    else
    {
      result = 2;
    }
  }
  else
  {
    result = 1;
  }
  return result;
}
// 20003B5B: using guessed type char curr_power_volts_range;
// 20003B5C: using guessed type char curr_power_amps_range;

//----- (0801548E) --------------------------------------------------------
void read_range_switch_then_update(void)
{
  read_range_switch();
  update_mode_based_on_range_switch_if_necessary();
}

//----- (0801549A) --------------------------------------------------------
void update_mode_based_on_range_switch_if_necessary()
{
  if ( range_switch_was_switched )
  {
    range_switch_was_switched = 0;
    update_mode_based_on_range_switch();
  }
}
// 20003B00: using guessed type char range_switch_was_switched;

//----- (080154B4) --------------------------------------------------------
void read_range_switch(void)
{
  if ( range_switch_unbounce_timer )
    --range_switch_unbounce_timer;
  update_range_switch_inputs();
  if ( range_switch_inputs == last_range_switch_bits )
  {
    ++range_switch_bounce_timer;
    if ( (signed int)range_switch_bounce_timer >= 5 )
    {
      range_switch_bounce_timer = 0;
      if ( exactly_one_range_is_active(range_switch_inputs)
        && curr_range_switch_bits != range_switch_inputs
        && !range_switch_unbounce_timer )
      {
        curr_range_switch_bits = range_switch_inputs;
        range_switch_unbounce_timer = 15;
        range_switch_was_switched = 1;
      }
    }
  }
  else
  {
    last_range_switch_bits = range_switch_inputs;
    range_switch_bounce_timer = 0;
  }
}
// 20003A8D: using guessed type char range_switch_unbounce_timer;
// 20003B00: using guessed type char range_switch_was_switched;

//----- (08015556) --------------------------------------------------------
void update_range_switch_inputs(void)
{
  range_switch_inputs = 0;
  if ( !(GPIOG.IDR & 0x80) )
    range_switch_inputs = 1;
  if ( !(GPIOG.IDR & 0x40) )
    range_switch_inputs |= 2u;
  if ( !(GPIOG.IDR & 0x20) )
    range_switch_inputs |= 4u;
  if ( !(GPIOG.IDR & 0x10) )
    range_switch_inputs |= 8u;
  if ( !(GPIOG.IDR & 8) )
    range_switch_inputs |= 0x10u;
  if ( !(GPIOG.IDR & 4) )
    range_switch_inputs |= 0x20u;
  if ( !(GPIOG.IDR & 2) )
    range_switch_inputs |= 0x40u;
  if ( !(GPIOG.IDR & 1) )
    range_switch_inputs |= 0x80u;
}
// 40021C00: using guessed type GPIO_REGS GPIOG;

//----- (08015628) --------------------------------------------------------
void __fastcall bt_process_rxed_button()
{
  meter_buttons v0; // r5@1

  v0 = 0;
  bt_new_rxed_button = 0;
  curr_sys_error = 0;
  need_to_display_logging_ended = 0;
  if ( bt_pressed_keycode == 1 )
  {
    v0 = BTN_RANGE;
  }
  else if ( bt_pressed_keycode >= 1u )
  {
    if ( bt_pressed_keycode == 3 )
    {
      v0 = BTN_REL;
    }
    else if ( bt_pressed_keycode >= 3u )
    {
      if ( bt_pressed_keycode == 5 )
      {
        v0 = BTN_MODE;
      }
      else if ( bt_pressed_keycode >= 5u )
      {
        if ( bt_pressed_keycode == 7 )
        {
          v0 = BTN_MEM;
        }
        else if ( bt_pressed_keycode >= 7u )
        {
          if ( bt_pressed_keycode == 8 )
            v0 = BTN_SETUP;
        }
        else
        {
          v0 = BTN_MINMAX;
        }
      }
      else
      {
        v0 = BTN_PEAK;
      }
    }
    else
    {
      v0 = BTN_HOLD;
    }
  }
  if ( v0 )
  {
    update_based_on_pressed_buttons(v0);
  }
  else
  {
    if ( bt_pressed_keycode == 129 )
    {
      v0 = BTN_RANGE;
    }
    else if ( bt_pressed_keycode >= 0x81u )
    {
      if ( bt_pressed_keycode == 131 )
      {
        v0 = BTN_REL;
      }
      else if ( bt_pressed_keycode >= 0x83u )
      {
        if ( bt_pressed_keycode == 133 )
        {
          v0 = BTN_MODE;
        }
        else if ( bt_pressed_keycode >= 0x85u )
        {
          if ( bt_pressed_keycode == 135 )
          {
            v0 = BTN_MEM;
          }
          else if ( bt_pressed_keycode >= 0x87u )
          {
            if ( bt_pressed_keycode == 136 )
              v0 = BTN_SETUP;
          }
          else
          {
            v0 = BTN_MINMAX;
          }
        }
        else
        {
          v0 = BTN_PEAK;
        }
      }
      else
      {
        v0 = BTN_HOLD;
      }
    }
    if ( v0 )
      update_based_on_held_buttons(v0);
  }
}
// 20003AC5: using guessed type char need_to_display_logging_ended;
// 20003B05: using guessed type char bt_new_rxed_button;

//----- (08015748) --------------------------------------------------------
void __fastcall update_based_on_pressed_buttons(meter_buttons mask)
{
  *(_DWORD *)&mask = mask;
  if ( mask == BTN_MODE )
  {
    if ( logging_active | log_playback_mode )
    {
      beep_angrily();
      return;
    }
    if ( sys_boot_button_delay_timer_1ms_unit )
    {
      if ( cal_manual_state || cal_sd_state )
      {
        if ( !cal_manual_state && cal_sd_state == 2 )
        {
          cal_sd_state = 3;
          sys_boot_button_delay_timer_1ms_unit = 5000;
          return;
        }
      }
      else
      {
        ++cal_manual_state;
        sys_boot_button_delay_timer_1ms_unit = 2000;
      }
    }
    else
    {
      meter_incr_mode();
    }
    beep_contentedly();
  }
  else
  {
    if ( mask != BTN_SETUP )
    {
      if ( mask == BTN_MINMAX )
      {
        if ( logging_active | log_playback_mode )
        {
          beep_angrily();
        }
        else if ( meter_in_cal_mode )
        {
          beep_angrily();
        }
        else if ( input_1ms_peak_enabled )
        {
          beep_angrily();
        }
        else
        {
          meter_incr_min_max_mode();
          beep_contentedly();
        }
        return;
      }
      if ( mask != BTN_MEM )
      {
        switch ( mask )
        {
          case BTN_RANGE:
            if ( sys_boot_button_delay_timer_1ms_unit )
            {
              if ( !cal_manual_state && !cal_sd_state )
              {
                sys_boot_button_delay_timer_1ms_unit = 2000;
                lcd_turn_on_all_segments();
                update_lcd_if_appropriate();
              }
            }
            else if ( logging_active | log_playback_mode || meter_min_max_mode )
            {
              beep_angrily();
            }
            else if ( curr_meas_mode == MM_DIODE )
            {
              change_diode_voltage();
              beep_contentedly();
            }
            else
            {
              meter_incr_range();
            }
            break;
          case BTN_HOLD:
            if ( logging_active | log_playback_mode )
            {
              beep_angrily();
            }
            else
            {
              if ( __PAIR__(auto_hold_is_enabled, manual_hold_is_enabled) )
              {
                if ( manual_hold_is_enabled )
                {
                  if ( curr_meas_mode != MM_HZ
                    && curr_meas_mode != MM_mSEC
                    && curr_meas_mode != MM_DUTY
                    && curr_meas_mode != MM_CAP )
                  {
                    meas_enable_auto_hold(1, 0);
                  }
                  else
                  {
                    manual_hold_is_enabled = 0;
                    auto_hold_is_enabled = 0;
                  }
                }
                else
                {
                  manual_hold_is_enabled = 0;
                  auto_hold_is_enabled = 0;
                }
              }
              else
              {
                manual_hold_is_enabled = 1;
              }
              scr_update_autorange_icon(0);
              meter_min_max_mode = 0;
              rel_meas_enabled = 0;
              scr_update_hold_icons(1);
              beep_contentedly();
            }
            break;
          case BTN_REL:
            if ( sys_boot_button_delay_timer_1ms_unit )
            {
              if ( cal_manual_state != 1 || cal_sd_state )
              {
                if ( !cal_manual_state && cal_sd_state == 1 )
                {
                  cal_sd_state = 2;
                  cal_mode_save_to_sd = 1;
                  sys_boot_button_delay_timer_1ms_unit = 5000;
                }
              }
              else
              {
                ++cal_manual_state;
                sys_boot_button_delay_timer_1ms_unit = 500;
              }
            }
            else if ( setup_currently_editing )
            {
              setup_menu_button_pressed(1);     // up button
            }
            else if ( log_playback_mode )
            {
              ++log_playback_pos;
              if ( log_playback_window_end < (unsigned int)(unsigned __int16)log_playback_pos )
                log_playback_pos = 1;
              log_playback_mode_timeout = 0;
              log_playback_show_sample(log_playback_pos);
            }
            else
            {
              if ( !((unsigned __int8)scr_overload_displayed & (unsigned __int8)(rel_meas_enabled ^ 1)) )
              {
                rel_meas_enabled = rel_meas_enabled != 1;
                rel_meas_got_rel_val = 0;
                if ( rel_meas_enabled )
                {
                  autoranging_was_disabled_before_rel_meas_was_enabled = autoranging_disabled;
                  autoranging_disabled = 1;
                }
                else
                {
                  autoranging_disabled = autoranging_was_disabled_before_rel_meas_was_enabled != 0;
                }
              }
              scr_update_autorange_icon(0);
              meter_min_max_mode = 0;
              manual_hold_is_enabled = 0;
              auto_hold_is_enabled = 0;
              hold_last_value_for_auto = 0;
              scr_update_rel_meas_icon(1);
            }
            beep_contentedly();
            break;
          case BTN_PEAK:
            if ( sys_boot_button_delay_timer_1ms_unit && !cal_manual_state && cal_sd_state == 1 )
            {
              cal_sd_state = 2;
              cal_mode_load_from_sd = 1;
              sys_boot_button_delay_timer_1ms_unit = 5000;
            }
            if ( setup_currently_editing )
            {
              setup_menu_button_pressed(2);     // down button
              beep_contentedly();
            }
            else if ( log_playback_mode )
            {
              if ( log_playback_pos == 1 )
                log_playback_pos = log_playback_window_end;
              else
                --log_playback_pos;
              log_playback_show_sample(log_playback_pos);
              log_playback_mode_timeout = 0;
              beep_contentedly();
            }
            else if ( (curr_meas_mode != MM_ACV || meter_mode_acv_dcv) && curr_meas_mode != MM_ACmV )
            {
              beep_angrily();
            }
            else
            {
              input_1ms_peak_enabled ^= 1u;
              peakdet_show_min_always_zero = 0;
              meter_mode_changed = 1;
              if ( input_1ms_peak_enabled )
              {
                autoranging_disabled = 1;
                meter_min_max_mode = 0;
              }
              else
              {
                autoranging_disabled = 0;
              }
              peakhold_max_value = 0;
              peakhold_min_value = 0;
              scr_update_1ms_peak_icon(1);
              beep_contentedly();
            }
            break;
        }
        return;
      }
      goto LABEL_46;
    }
    // BTN_SETUP
    if ( !sys_boot_button_delay_timer_1ms_unit )
    {
      if ( logging_active | log_playback_mode )
      {
        beep_angrily();
        return;
      }
      if ( !meter_in_cal_mode )
      {
        meter_incr_subscr_mode();
        beep_contentedly();
        need_to_update_subscr = 1;
        return;
      }
      if ( cal_can_be_done(0) )
      {
        beep_angrily();
        return;
      }
      if ( cal_start(0) == 2 )
      {
        beep_angrily();
        return;
      }
LABEL_46:
      // BTN_MEM
      if ( sys_boot_button_delay_timer_1ms_unit )
      {
        if ( !cal_manual_state && !cal_sd_state )
        {
          cal_sd_state = 1;
          sys_boot_button_delay_timer_1ms_unit = 5000;
          beep_contentedly();
        }
      }
      else if ( meter_in_cal_mode )
      {
        if ( (unsigned __int8)calibrating_offset | (unsigned __int8)calibrating_gain )
        {
          beep_angrily();
        }
        else if ( cal_can_be_done(1) )
        {
          beep_angrily();
        }
        else if ( cal_start(1) == 2 )
        {
          beep_angrily();
        }
        else
        {
          beep_contentedly();
        }
      }
      else if ( logging_active )
      {
        beep_angrily();
      }
      else if ( log_samples_in_eeprom )
      {
        log_playback_mode = log_playback_mode != 1;
        if ( log_playback_mode )
        {
          log_playback_mode_timeout = 0;
          curr_sub_mode = SM_LOG_POS;
          log_playback_pos = log_playback_window_len;
          subscr_set_decimal_point(0);
          read_logged_meas_mode_range_from_eeprom();
          scr_update_for_playback();
          log_playback_show_sample(log_playback_pos);
          load_log_start_time_from_eeprom_badly();
          load_log_end_time_from_eeprom_badly();
        }
        else
        {
          log_playback_mode_stop();
        }
        scr_update_mem_icon(1);
        beep_contentedly();
      }
      else
      {
        beep_angrily();
      }
      return;
    }
    if ( !cal_manual_state && !cal_sd_state )
    {
      cal_manual_state = 3;
      sys_boot_button_delay_timer_1ms_unit = 500;
    }
  }
}
// 2000021A: using guessed type __int16 sys_boot_button_delay_timer_1ms_unit;
// 20003888: using guessed type int hold_last_value_for_auto;
// 2000396C: using guessed type int peakhold_max_value;
// 20003970: using guessed type int peakhold_min_value;
// 20003A54: using guessed type __int16 log_playback_pos;
// 20003A5A: using guessed type __int16 log_playback_window_len;
// 20003A5C: using guessed type __int16 log_samples_in_eeprom;
// 20003A62: using guessed type __int16 log_playback_mode_timeout;
// 20003A8F: using guessed type char autoranging_was_disabled_before_rel_meas_was_enabled;
// 20003A9C: using guessed type char came_from_standby;
// 20003A9F: using guessed type char maybe_logging_was_active_at_some_point;
// 20003AE6: using guessed type char autoranging_disabled;
// 20003AEA: using guessed type char scr_overload_displayed;
// 20003AF5: using guessed type char rel_meas_enabled;
// 20003AF6: using guessed type char rel_meas_got_rel_val;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B0A: using guessed type char setup_currently_editing;
// 20003B22: using guessed type char cal_mode_save_to_sd;
// 20003B23: using guessed type char cal_mode_load_from_sd;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B25: using guessed type char setting_last_cal_year_month;
// 20003B26: using guessed type char calibrating_offset;
// 20003B27: using guessed type char calibrating_offset_finished;
// 20003B28: using guessed type char calibrating_gain;
// 20003B4F: using guessed type char input_1ms_peak_enabled;
// 20003B50: using guessed type char peakdet_show_min_always_zero;
// 20003B52: using guessed type char meter_mode_acv_dcv;
// 20003B5F: using guessed type char cal_manual_state;
// 20003B60: using guessed type char cal_sd_state;

//----- (08015D70) --------------------------------------------------------
void log_playback_mode_stop()
{
  log_playback_mode = 0;
  meter_set_default_subscr_mode();
  need_to_update_bargraph = 1;
  meas_was_updated = 1;
  scr_need_to_refresh_meas_units_and_icons = 1;
  scr_need_to_update_units_in_certain_modes = 1;
  need_to_update_subscr = 1;
}
// 20003AFA: using guessed type char need_to_update_bargraph;
// 20003AFC: using guessed type char scr_need_to_refresh_meas_units_and_icons;
// 20003AFD: using guessed type char scr_need_to_update_units_in_certain_modes;
// 20003AFE: using guessed type char need_to_update_subscr;

//----- (08015DF4) --------------------------------------------------------
void meter_incr_subscr_mode(void)
{
  if ( curr_sub_mode != SM_METER_SERIAL )
    setup_currently_editing = 0;
  if ( setup_currently_editing && curr_sub_mode == SM_METER_SERIAL )
  {
    if ( setup_serial_selected_digit )
      --setup_serial_selected_digit;
    else
      setup_serial_selected_digit = 4;
    setup_edit_timeout_2min = 0;
  }
  else if ( curr_meas_mode != MM_ACV || meter_mode_acv_dcv )
  {
    if ( curr_meas_mode != MM_ACuVA
      && curr_meas_mode != MM_ACmVA
      && curr_meas_mode != MM_ACVA
      && curr_meas_mode != MM_DCuVA
      && curr_meas_mode != MM_DCmVA
      && curr_meas_mode != MM_DCVA )
    {
      if ( curr_meas_mode != MM_ACuA && curr_meas_mode != MM_ACmA && curr_meas_mode != MM_ACA )
      {
        if ( curr_meas_mode != MM_DCuA && curr_meas_mode != MM_DCmA && curr_meas_mode != MM_DCA )
        {
          if ( curr_meas_mode != MM_DIODE && curr_meas_mode != MM_CONTINUITY && curr_meas_mode != MM_ACmV )
          {
            ++curr_sub_mode;
            if ( (unsigned __int8)curr_sub_mode >= (signed int)SM_SPL1 )
              curr_sub_mode = 0;
          }
          else
          {
            ++curr_sub_mode;
            if ( (unsigned __int8)curr_sub_mode >= (signed int)SM_SPL2 )
              curr_sub_mode = 0;
          }
        }
        else if ( burden_enabled_for_current_ranges )
        {
          ++curr_sub_mode;
          if ( (unsigned __int8)curr_sub_mode >= (signed int)SM_SPL3 )
            curr_sub_mode = 0;
        }
        else
        {
          ++curr_sub_mode;
          if ( (unsigned __int8)curr_sub_mode >= (signed int)SM_SPL2 )
            curr_sub_mode = 0;
        }
      }
      else
      {
        ++curr_sub_mode;
        if ( curr_sub_mode == SM_SPL1 )
        {
          edit_burden_enabled_for_current_ranges = burden_enabled_for_current_ranges;
        }
        else if ( (unsigned __int8)curr_sub_mode >= (signed int)SM_SPL3 )
        {
          curr_sub_mode = 0;
        }
      }
    }
    else
    {
      ++curr_sub_mode;
      if ( curr_sub_mode == SM_SPL2 )
      {
        edit_burden_enabled_for_power_ranges = burden_enabled_for_power_ranges;
      }
      else if ( burden_enabled_for_power_ranges )
      {
        if ( (signed int)(unsigned __int8)curr_sub_mode >= 12 )
          curr_sub_mode = 0;
      }
      else if ( (unsigned __int8)curr_sub_mode >= (signed int)SM_SPL3 )
      {
        curr_sub_mode = 0;
      }
      if ( curr_sub_mode == SM_SPL1 )
        subscr_update_power_amps_or_volts_display();
      if ( curr_sub_mode == SM_SPL3 )
        burden_active_msg_showing_timer_1s = 100;
    }
  }
  else
  {
    ++curr_sub_mode;
    if ( (unsigned __int8)curr_sub_mode >= (signed int)SM_SPL3 )
      curr_sub_mode = 0;
  }
  switch ( curr_sub_mode )
  {
    case 4:
      edit_year = curr_year;
      break;
    case 5:
      edit_month = curr_month;
      edit_day = curr_day;
      editing_rightside_time_val = 0;
      break;
    case 6:
      edit_hour = curr_hour;
      edit_minute = curr_minute;
      editing_rightside_time_val = 0;
      break;
    default:
      if ( setup_currently_editing || curr_sub_mode != SM_METER_SERIAL )
      {
        if ( curr_sub_mode == SM_LOG_INTERVAL )
          edit_logging_interval = curr_logging_interval;
      }
      else
      {
        edit_meter_serial = curr_meter_serial;
      }
      break;
  }
}
// 2000380C: using guessed type int curr_meter_serial;
// 20003810: using guessed type int edit_meter_serial;
// 20003A5E: using guessed type __int16 edit_logging_interval;
// 20003B0A: using guessed type char setup_currently_editing;
// 20003B0C: using guessed type char setup_edit_timeout_2min;
// 20003B0D: using guessed type char setup_serial_selected_digit;
// 20003B3D: using guessed type char burden_enabled_for_current_ranges;
// 20003B3E: using guessed type char edit_burden_enabled_for_current_ranges;
// 20003B40: using guessed type char burden_enabled_for_power_ranges;
// 20003B41: using guessed type char edit_burden_enabled_for_power_ranges;
// 20003B42: using guessed type char burden_active_msg_showing_timer_1s;
// 20003B52: using guessed type char meter_mode_acv_dcv;
// 20003B68: using guessed type char editing_rightside_time_val;
// 20003B6F: using guessed type char edit_year;
// 20003B70: using guessed type char edit_month;
// 20003B71: using guessed type char edit_day;
// 20003B72: using guessed type char edit_hour;
// 20003B73: using guessed type char edit_minute;

//----- (080160F0) --------------------------------------------------------
bool __fastcall cal_can_be_done(char cal_gain)
{
  char v1; // r1@1
  bool result; // r0@1

  v1 = cal_gain;
  LOBYTE(result) = 0;
  if ( curr_meas_mode == MM_LOW_Z )
    goto LABEL_6;
  if ( curr_meas_mode != MM_HZ )
  {
    if ( (unsigned int)(unsigned __int8)curr_meas_mode - MM_mSEC > 1 )
    {
      if ( (unsigned int)(unsigned __int8)curr_meas_mode - MM_DIODE > 1 )
        return result;
      goto LABEL_7;
    }
LABEL_6:
    LOBYTE(result) = 1;
    return result;
  }
LABEL_7:
  if ( !v1 && (signed int)curr_meas_range >= 2 )
    LOBYTE(result) = 1;
  return result;
}

//----- (08016134) --------------------------------------------------------
int __fastcall cal_start(char cal_gain)
{
  char v1; // r4@1
  int result; // r0@1
  unsigned __int8 v3; // r5@1

  v1 = cal_gain;
  calibrating_offset = 0;
  calibrating_offset_finished = 0;
  calibrating_gain = 0;
  calibrating_gain_finished = 0;
  LOBYTE(result) = cal_prepare_ac_factor_calibration(cal_gain);
  v3 = result;
  if ( (_BYTE)result )
  {
    result = (unsigned __int8)result;
  }
  else
  {
    if ( v1 )
    {
      if ( v1 == 1 )
        calibrating_gain = 1;
    }
    else
    {
      calibrating_offset = 1;
    }
    cal_countdown_timer = cal_calc_countdown_timer();
    cal_curr_gain_accu = 0LL;
    cal_curr_offset_accu = 0;
    result = v3;
  }
  return result;
}
// 200038FC: using guessed type int cal_curr_offset_accu;
// 20003B26: using guessed type char calibrating_offset;
// 20003B27: using guessed type char calibrating_offset_finished;
// 20003B28: using guessed type char calibrating_gain;
// 20003B29: using guessed type char calibrating_gain_finished;
// 20003B2F: using guessed type char cal_countdown_timer;

//----- (080161B4) --------------------------------------------------------
unsigned __int8 __fastcall cal_calc_countdown_timer()
{
  unsigned __int8 result; // r0@7

  if ( curr_meas_mode != MM_ACuVA
    && curr_meas_mode != MM_ACmVA
    && curr_meas_mode != MM_ACVA
    && curr_meas_mode != MM_DCuVA
    && curr_meas_mode != MM_DCmVA
    && curr_meas_mode != MM_DCVA )
    result = 16;
  else
    result = 4;
  return result;
}

//----- (080161FC) --------------------------------------------------------
void __fastcall meas_enable_auto_hold(char should_enable_holding, char was_called_when_logging_started)
{
  manual_hold_is_enabled = 0;
  if ( should_enable_holding )
  {
    auto_hold_is_enabled = 1;
    auto_hold_need_to_unhold = 1;
    lcd_update_from_auto_hold = 1;
  }
  else
  {
    auto_hold_is_enabled = 0;
    auto_hold_need_to_unhold = 0;
    lcd_update_from_auto_hold = 0;
  }
  auto_hold_holding = 0;
  TIM2_auto_hold_unhold_timer_1s = 0;
  if ( was_called_when_logging_started == 1 )
  {
    scr_update_autorange_icon(0);
    meter_min_max_mode = 0;
    rel_meas_enabled = 0;
    scr_update_hold_icons(1);
  }
}
// 20003A66: using guessed type __int16 TIM2_auto_hold_unhold_timer_1s;
// 20003AF2: using guessed type char auto_hold_holding;
// 20003AF5: using guessed type char rel_meas_enabled;

//----- (0801626E) --------------------------------------------------------
void meter_incr_min_max_mode(void)
{
  if ( meter_min_max_mode )
  {
    ++meter_min_max_mode;
    if ( (signed int)meter_min_max_mode >= 5 )
      meter_min_max_mode = 1;
  }
  else
  {
    meter_enable_min_max_mode();
  }
  scr_update_min_max_icons(1);
}

//----- (080162A4) --------------------------------------------------------
void __fastcall meter_enable_min_max_mode()
{
  meter_min_max_mode = 1;
  meter_min_max_maxval = -2147483648;
  meter_min_max_minval = 0x7FFFFFFF;
  meter_min_max_avg = 0;
  meter_min_max_avg_count = 0;
  meter_min_max_avg_diff = 0;
}
// 20003874: using guessed type int meter_min_max_maxval;
// 20003878: using guessed type int meter_min_max_minval;
// 2000387C: using guessed type int meter_min_max_avg;
// 20003880: using guessed type int meter_min_max_avg_diff;
// 20003884: using guessed type int meter_min_max_avg_count;

//----- (080162E4) --------------------------------------------------------
void __fastcall change_diode_voltage()
{
  high_voltage_diode = high_voltage_diode != 1;
  save_diode_voltage(high_voltage_diode);
  curr_scr_decimal_place = calc_decimal_place_for_mode_range(curr_meas_mode, curr_meas_range);
  meas_hw_set_hv_diode(curr_meas_mode);
  update_max_digits_in_range();
  curr_sub_mode = SM_SPL1;
  need_to_update_subscr = 1;
}
// 20003AE3: using guessed type char curr_scr_decimal_place;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B4B: using guessed type char high_voltage_diode;

//----- (0801633C) --------------------------------------------------------
void __fastcall change_apo_status(char direction)
{
  if ( direction != 1 && direction != 2 )
  {
    save_curr_apo_status(curr_apo_off);
  }
  else
  {
    curr_apo_off = curr_apo_off != 1;
    scr_update_apo_status(1);
  }
  need_to_update_subscr = 1;
}
// 20003AFE: using guessed type char need_to_update_subscr;

//----- (08016384) --------------------------------------------------------
void __fastcall change_logging_interval(char direction)
{
  if ( direction == 1 )
  {
    if ( (signed int)(unsigned __int16)edit_logging_interval < 999 )
      ++edit_logging_interval;
    else
      edit_logging_interval = 0;
  }
  else if ( direction == 2 )
  {
    if ( edit_logging_interval )
      --edit_logging_interval;
    else
      edit_logging_interval = 999;
  }
  else
  {
    curr_logging_interval = edit_logging_interval;
    save_logging_interval(edit_logging_interval);
  }
  need_to_update_subscr = 1;
}
// 20003A5E: using guessed type __int16 edit_logging_interval;
// 20003AFE: using guessed type char need_to_update_subscr;

//----- (08016404) --------------------------------------------------------
void __fastcall change_lcd_contrast(char direction)
{
  if ( direction == 1 )
  {
    if ( curr_lcd_contrast == 17 )
      curr_lcd_contrast = 10;
    else
      ++curr_lcd_contrast;
  }
  else if ( direction == 2 )
  {
    if ( curr_lcd_contrast == 10 )
      curr_lcd_contrast = 17;
    else
      --curr_lcd_contrast;
  }
  else
  {
    save_lcd_contrast(curr_lcd_contrast);
  }
  lcd_init(curr_lcd_contrast, 0);
  need_to_update_subscr = 1;
}
// 20000222: using guessed type char curr_lcd_contrast;
// 20003AFE: using guessed type char need_to_update_subscr;

//----- (08016484) --------------------------------------------------------
void __fastcall change_temp_unit(char direction)
{
  if ( direction != 1 && direction != 2 )
  {
    save_curr_temp_unit(temp_in_c);
  }
  else
  {
    temp_in_c ^= 1u;
    scr_update_temp_unit();
  }
  need_to_update_subscr = 1;
}
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B43: using guessed type char temp_in_c;

//----- (080164C8) --------------------------------------------------------
void __fastcall change_continuity_threshold(char direction)
{
  if ( direction == 1 )
  {
    ++curr_continuity_threshold;
    if ( (signed int)(unsigned __int8)curr_continuity_threshold >= 4 )
      curr_continuity_threshold = 0;
  }
  else if ( direction == 2 )
  {
    if ( curr_continuity_threshold )
      --curr_continuity_threshold;
    else
      curr_continuity_threshold = 3;
  }
  else
  {
    save_curr_continuity_threshold(curr_continuity_threshold);
  }
  need_to_update_subscr = 1;
}
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B4E: using guessed type char curr_continuity_threshold;

//----- (08016540) --------------------------------------------------------
void __fastcall change_year(char direction)
{
  if ( direction == 1 )
  {
    ++edit_year;
    if ( (signed int)(unsigned __int8)edit_year >= 100 )
      edit_year = 0;
  }
  else if ( direction == 2 )
  {
    if ( edit_year )
      --edit_year;
    else
      edit_year = 99;
  }
  else
  {
    curr_year = edit_year;
    curr_day = get_days_in_month_without_going_over(edit_year, curr_month, curr_day);
    rtc_write_time();
    update_last_cal_year_month_and_save();
  }
  need_to_update_subscr = 1;
}
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B6F: using guessed type char edit_year;

//----- (080165EC) --------------------------------------------------------
void __fastcall change_month_day(char direction)
{
  char v1; // r4@1
  unsigned __int8 v2; // r0@10

  v1 = direction;
  if ( editing_rightside_time_val )
  {
    v2 = get_days_in_month(curr_year, curr_month);
    if ( v1 == 1 )
    {
      ++edit_day;
      if ( v2 < (unsigned int)(unsigned __int8)edit_day )
        edit_day = 1;
    }
    else if ( v1 == 2 )
    {
      if ( (signed int)(unsigned __int8)edit_day >= 2 )
        --edit_day;
      else
        edit_day = v2;
    }
    else
    {
      curr_day = edit_day;
      curr_day = get_days_in_month_without_going_over(curr_year, curr_month, edit_day);
      rtc_write_time();
      editing_rightside_time_val = 0;
    }
  }
  else if ( direction == 1 )
  {
    ++edit_month;
    if ( (signed int)(unsigned __int8)edit_month >= 13 )
      edit_month = 1;
  }
  else if ( direction == 2 )
  {
    if ( (signed int)(unsigned __int8)edit_month >= 2 )
      --edit_month;
    else
      edit_month = 12;
  }
  else
  {
    curr_month = edit_month;
    curr_day = get_days_in_month_without_going_over(curr_year, edit_month, curr_day);
    rtc_write_time();
    update_last_cal_year_month_and_save();
    editing_rightside_time_val = 1;
    setup_currently_editing = 1;
  }
  need_to_update_subscr = 1;
}
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B0A: using guessed type char setup_currently_editing;
// 20003B68: using guessed type char editing_rightside_time_val;
// 20003B70: using guessed type char edit_month;
// 20003B71: using guessed type char edit_day;

//----- (08016740) --------------------------------------------------------
void __fastcall change_hour_minute(char a1)
{
  if ( editing_rightside_time_val )
  {
    if ( a1 == 1 )
    {
      ++edit_minute;
      if ( (signed int)(unsigned __int8)edit_minute >= 60 )
        edit_minute = 0;
    }
    else if ( a1 == 2 )
    {
      if ( edit_minute )
        --edit_minute;
      else
        edit_minute = 59;
    }
    else
    {
      curr_minute = edit_minute;
      rtc_write_time();
      editing_rightside_time_val = 0;
    }
  }
  else if ( a1 == 1 )
  {
    ++edit_hour;
    if ( (signed int)(unsigned __int8)edit_hour >= 24 )
      edit_hour = 0;
  }
  else if ( a1 == 2 )
  {
    if ( edit_hour )
      --edit_hour;
    else
      edit_hour = 23;
  }
  else
  {
    curr_hour = edit_hour;
    rtc_write_time();
    editing_rightside_time_val = 1;
    setup_currently_editing = 1;
  }
  need_to_update_subscr = 1;
}
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B0A: using guessed type char setup_currently_editing;
// 20003B68: using guessed type char editing_rightside_time_val;
// 20003B72: using guessed type char edit_hour;
// 20003B73: using guessed type char edit_minute;

//----- (0801680C) --------------------------------------------------------
void __fastcall update_last_cal_year_month_and_save()
{
  if ( setting_last_cal_year_month )
  {
    last_cal_year_month = curr_month + (curr_year << 8);
    save_last_cal_year_month();
  }
}
// 20003B25: using guessed type char setting_last_cal_year_month;

//----- (08016848) --------------------------------------------------------
void __fastcall change_meter_serial(char button)
{
  unsigned int v1; // r0@4
  unsigned int serial_digits[5]; // [sp+0h] [bp-20h]@3
  unsigned int v3; // [sp+4h] [bp-1Ch]@3
  unsigned int v4; // [sp+8h] [bp-18h]@3
  unsigned int v5; // [sp+Ch] [bp-14h]@3
  unsigned int v6; // [sp+10h] [bp-10h]@3

  if ( button == 100 )
  {
    curr_meter_serial = edit_meter_serial;
    save_meter_serial();
  }
  else
  {
    serial_digits[0] = edit_meter_serial % 10u;
    v3 = edit_meter_serial % 100u / 10;
    v4 = edit_meter_serial % 1000u / 100;
    v5 = edit_meter_serial % 10000u / 1000;
    v6 = edit_meter_serial / 10000u;
    if ( button == 1 )
    {
      v1 = serial_digits[(unsigned __int8)setup_serial_selected_digit] + 1;
      serial_digits[(unsigned __int8)setup_serial_selected_digit] = v1;
      if ( v1 >= 10 )
        serial_digits[(unsigned __int8)setup_serial_selected_digit] = 0;
    }
    else if ( serial_digits[(unsigned __int8)setup_serial_selected_digit] )
    {
      --serial_digits[(unsigned __int8)setup_serial_selected_digit];
    }
    else
    {
      serial_digits[(unsigned __int8)setup_serial_selected_digit] = 9;
    }
    edit_meter_serial = serial_digits[0] + 1000 * v5 + 10000 * v6 + 100 * v4 + 10 * v3;
  }
  need_to_update_subscr = 1;
}
// 2000380C: using guessed type int curr_meter_serial;
// 20003810: using guessed type int edit_meter_serial;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B0D: using guessed type char setup_serial_selected_digit;

//----- (08016984) --------------------------------------------------------
void __fastcall change_burden_enabled_for_current_ranges(char a1)
{
  if ( a1 == 100 )
  {
    burden_enabled_for_current_ranges = edit_burden_enabled_for_current_ranges;
    measuring_amps_of_va_or_volts_of_burden = 0;
    meas_amp_burden_timer = 0;
    if ( curr_meas_mode != MM_DCuA && curr_meas_mode != MM_DCmA && curr_meas_mode != MM_DCA )
      prepare_reading_ac_amps(measuring_amps_of_va_or_volts_of_burden != 0);
    else
      prepare_reading_dc_amps(measuring_amps_of_va_or_volts_of_burden != 0);
  }
  else
  {
    edit_burden_enabled_for_current_ranges = edit_burden_enabled_for_current_ranges != 1;
  }
  need_to_update_subscr = 1;
}
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B3D: using guessed type char burden_enabled_for_current_ranges;
// 20003B3E: using guessed type char edit_burden_enabled_for_current_ranges;
// 20003B59: using guessed type char measuring_amps_of_va_or_volts_of_burden;
// 20003B5A: using guessed type char meas_amp_burden_timer;

//----- (08016A1A) --------------------------------------------------------
void __fastcall change_burden_enabled_for_power_ranges(char a1)
{
  if ( a1 == 100 )
  {
    burden_enabled_for_power_ranges = edit_burden_enabled_for_power_ranges;
    save_burden_enabled_for_power_ranges(edit_burden_enabled_for_power_ranges);
  }
  else
  {
    edit_burden_enabled_for_power_ranges = edit_burden_enabled_for_power_ranges != 1;
  }
  need_to_update_subscr = 1;
}
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B40: using guessed type char burden_enabled_for_power_ranges;
// 20003B41: using guessed type char edit_burden_enabled_for_power_ranges;

//----- (08016ABC) --------------------------------------------------------
void __fastcall update_based_on_held_buttons(meter_buttons mask)
{
  *(_DWORD *)&mask = mask;
  switch ( mask )
  {
    case BTN_MODE:
      if ( backlight_on )
      {
        backlight_on = 0;
        HIWORD(GPIOE.BSRR) = 256;
      }
      else
      {
        backlight_on = 1;
        backlight_related_var_maybe_auto_timeout_unused = 120;
        LOWORD(GPIOE.BSRR) = 256;
      }
      beep_excitedly();
      break;
    case BTN_SETUP:
      if ( logging_active | log_playback_mode )
      {
        beep_angrily();
      }
      else if ( setup_menu_button_pressed(0) )
      {
        setup_currently_editing = setup_currently_editing != 1;
        setup_edit_timeout_2min = 0;
        setup_serial_selected_digit = 4;
        beep_excitedly();
        if ( !setup_currently_editing )
          setup_menu_button_pressed(100);
      }
      else
      {
        beep_angrily();
      }
      break;
    case BTN_MINMAX:
      if ( meter_in_cal_mode )
      {
        beep_angrily();
      }
      else if ( meter_min_max_mode )
      {
        meter_min_max_mode = 0;
        scr_update_min_max_icons(0);
        beep_excitedly();
      }
      else
      {
        beep_angrily();
      }
      break;
    case BTN_MEM:
      if ( meter_in_cal_mode )
      {
        if ( curr_meas_mode != MM_OHMS || curr_meas_range != 6 )
        {
          calibrating_thermistor_23c = 1;
        }
        else
        {
          calibrating_ohms_50M_offset = 1;
          cal_countdown_timer = 16;
        }
        beep_excitedly();
      }
      else
      {
        change_logging_enabled(0);
      }
      break;
    case BTN_RANGE:
      if ( logging_active | log_playback_mode )
      {
        beep_angrily();
      }
      else
      {
        if ( !meter_in_cal_mode )
          autoranging_disabled = 0;
        if ( !meter_in_cal_mode )
        {
          curr_meas_range = 0;
          calc_power_ranges(curr_meas_mode, 0);
          meter_range_changed = 1;
        }
        scr_update_autorange_icon(1);
        beep_excitedly();
      }
      break;
    case BTN_HOLD|BTN_MEM:
      if ( meter_in_cal_mode )
        beep_angrily();
      else
        change_logging_enabled(1);
      break;
    case BTN_REL:
      if ( (unsigned __int8)(logging_active | log_playback_mode) | (unsigned __int8)setup_currently_editing )
      {
        beep_angrily();
      }
      else if ( curr_meas_mode != MM_ACV && curr_meas_mode != MM_ACmV )
      {
        if ( curr_meas_mode != MM_ACuA
          && curr_meas_mode != MM_ACmA
          && curr_meas_mode != MM_ACA
          && curr_meas_mode != MM_DCuA
          && curr_meas_mode != MM_DCmA
          && curr_meas_mode != MM_DCA
          || curr_meas_range )
        {
          beep_angrily();
        }
        else
        {
          curr_amp_rel += curr_scr_digits;
          cal_save_amp_rel(curr_meas_mode, curr_meas_range, curr_scr_digits);
          beep_excitedly();
        }
      }
      else if ( meter_mode_acv_dcv )
      {
        beep_angrily();
      }
      else
      {
        input_lpf_enabled ^= 1u;
        meter_mode_acv_dcv = 0;
        meter_mode_changed = 1;
        beep_contentedly();
      }
      break;
    case BTN_PEAK:
      if ( setup_currently_editing )
      {
        beep_angrily();
      }
      else
      {
        bt_enabled = bt_enabled != 1;
        bt_set_the_time = 0;
        bt_new_rxed_button = 0;
        bt_pressed_keycode = 0;
        update_bt_power();
        beep_excitedly();
      }
      break;
    default:
      beep_angrily();
      break;
  }
}
// 20003858: using guessed type int curr_scr_digits;
// 200038EC: using guessed type int curr_amp_rel;
// 20003A6C: using guessed type __int16 backlight_related_var_maybe_auto_timeout_unused;
// 20003A9C: using guessed type char came_from_standby;
// 20003A9F: using guessed type char maybe_logging_was_active_at_some_point;
// 20003AD3: using guessed type char bt_enabled;
// 20003AD9: using guessed type char bt_set_the_time;
// 20003AE6: using guessed type char autoranging_disabled;
// 20003AEC: using guessed type char meter_range_changed;
// 20003B05: using guessed type char bt_new_rxed_button;
// 20003B0A: using guessed type char setup_currently_editing;
// 20003B0C: using guessed type char setup_edit_timeout_2min;
// 20003B0D: using guessed type char setup_serial_selected_digit;
// 20003B16: using guessed type char backlight_on;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B2A: using guessed type char calibrating_ohms_50M_offset;
// 20003B2F: using guessed type char cal_countdown_timer;
// 20003B30: using guessed type char calibrating_thermistor_23c;
// 20003B51: using guessed type char input_lpf_enabled;
// 20003B52: using guessed type char meter_mode_acv_dcv;
// 40021000: using guessed type GPIO_REGS GPIOE;

//----- (08016DD4) --------------------------------------------------------
void __fastcall change_logging_enabled(char activated_with_hold_held)
{
  logging_active = logging_active != 1;
  if ( activated_with_hold_held || auto_hold_is_enabled )
    meas_enable_auto_hold(logging_active, 1);
  if ( logging_active )
    logging_begin();
  else
    logging_end(1);
  scr_update_apo_status(0);
  scr_update_mem_icon(1);
  beep_excitedly();
}

//----- (08016E4C) --------------------------------------------------------
int __fastcall setup_menu_button_pressed(char button)
{
  char is_editable; // r5@1

  // act upon setup button pressed
  // 0 = return 1 if editable
  // 1 = up pressed
  // 2 = down pressed
  // 100 = SETUP held (save value)
  is_editable = 0;
  setup_edit_timeout_2min = 0;
  if ( (curr_meas_mode == MM_ACuVA
     || curr_meas_mode == MM_ACmVA
     || curr_meas_mode == MM_ACVA
     || curr_meas_mode == MM_DCuVA
     || curr_meas_mode == MM_DCmVA
     || curr_meas_mode == MM_DCVA)
    && curr_sub_mode == SM_SPL2 )
  {
    if ( button )
      change_burden_enabled_for_power_ranges(button);
    else
      is_editable = 1;
  }
  if ( curr_meas_mode != MM_ACuA
    && curr_meas_mode != MM_ACmA
    && curr_meas_mode != MM_ACA
    && curr_meas_mode != MM_DCuA
    && curr_meas_mode != MM_DCmA
    && curr_meas_mode != MM_DCA
    || curr_sub_mode != SM_SPL1 )
  {
    if ( curr_meas_mode != MM_CONTINUITY || curr_sub_mode != SM_SPL1 )
    {
      if ( curr_sub_mode )
      {
        switch ( curr_sub_mode )
        {
          case SM_APO:
            if ( button )
              change_apo_status(button);
            else
              is_editable = 1;
            break;
          case SM_CONTRAST:
            if ( button )
              change_lcd_contrast(button);
            else
              is_editable = 1;
            break;
          case SM_LOG_INTERVAL:
            if ( button )
              change_logging_interval(button);
            else
              is_editable = 1;
            break;
          case SM_YEAR:
            if ( button )
              change_year(button);
            else
              is_editable = 1;
            break;
          case SM_MONTH_DAY:
            if ( button )
              change_month_day(button);
            else
              is_editable = 1;
            break;
          case SM_HOUR_MINUTE:
            if ( button )
              change_hour_minute(button);
            else
              is_editable = 1;
            break;
          case SM_METER_SERIAL:
            if ( button )
              change_meter_serial(button);
            else
              is_editable = 1;
            break;
        }
      }
      else if ( button )
      {
        change_temp_unit(button);
      }
      else
      {
        is_editable = 1;
      }
    }
    else if ( button )
    {
      change_continuity_threshold(button);
    }
    else
    {
      is_editable = 1;
    }
  }
  else if ( button )
  {
    change_burden_enabled_for_current_ranges(button);
  }
  else
  {
    is_editable = 1;
  }
  return (unsigned __int8)is_editable;
}
// 20003B0C: using guessed type char setup_edit_timeout_2min;

//----- (08017044) --------------------------------------------------------
void __fastcall read_buttons_then_update()
{
  read_buttons();
  update_based_on_buttons();
  if ( bt_new_rxed_button )
    bt_process_rxed_button();
}
// 20003B05: using guessed type char bt_new_rxed_button;

//----- (08017064) --------------------------------------------------------
void __fastcall update_based_on_buttons()
{
  if ( new_buttons_pressed )
  {
    new_buttons_pressed = 0;
    curr_sys_error = 0;
    need_to_display_logging_ended = 0;
    update_based_on_pressed_buttons(buttons_pressed);
  }
  if ( new_buttons_held )
  {
    new_buttons_held = 0;
    curr_sys_error = 0;
    need_to_display_logging_ended = 0;
    update_based_on_held_buttons(buttons_held);
  }
}
// 20003AC5: using guessed type char need_to_display_logging_ended;
// 20003B03: using guessed type char new_buttons_pressed;
// 20003B04: using guessed type char new_buttons_held;

//----- (080170C4) --------------------------------------------------------
void read_buttons(void)
{
  if ( button_check_timer )
    --button_check_timer;
  read_button_inputs();
  if ( (unsigned __int8)curr_button_input == (unsigned __int8)last_button_input )
  {
    ++button_debounce_timer;
    if ( (signed int)(unsigned __int8)button_debounce_timer >= 2 )
    {
      if ( curr_button_input )
      {
        if ( exactly_one_range_is_active(curr_button_input)
          || hold_and_mem_are_both_being_pressed((meter_buttons)curr_button_input) )
        {
          if ( button_hold_timer )
          {
            ++button_hold_timer;
            if ( button_hold_timer == 50 )
            {
              button_hold_timer = 51;
              button_delay_flag = 0;
              if ( button_hold_is_being_held_with_mem((meter_buttons)curr_button_input) )
              {
                new_buttons_held = 1;
                buttons_held = curr_button_input;
                button_check_timer = 10;
              }
            }
            else if ( log_playback_mode | (unsigned __int8)setup_currently_editing
                   && (curr_button_input == BTN_REL || (unsigned __int8)curr_button_input == BTN_PEAK) )
            {
              button_hold_timer = 1;
              button_auto_press_up_down(1);
            }
          }
          else if ( !button_check_timer )
          {
            button_debounce_timer = 2;
            button_hold_timer = 1;
            button_auto_press_up_down(0);
            if ( !sys_boot_button_delay_timer_1ms_unit || cal_sd_state )
            {
              if ( !log_playback_mode || curr_button_input != BTN_REL && (unsigned __int8)curr_button_input != BTN_PEAK )
              {
                button_delay_flag = 1;
                button_delay_buttons = curr_button_input;
              }
            }
            else
            {
              button_delay_flag = 0;
              button_check_timer = 5;
              new_buttons_pressed = 1;
              buttons_pressed = curr_button_input;
            }
          }
        }
      }
      else
      {
        button_hold_timer = 0;
        button_debounce_timer = 2;
        if ( button_delay_flag == 1 )
        {
          button_delay_flag = 0;
          button_check_timer = 10;
          new_buttons_pressed = 1;
          buttons_pressed = button_delay_buttons;
        }
      }
    }
  }
  else
  {
    last_button_input = curr_button_input;
    button_debounce_timer = 0;
  }
}
// 80173D6: using guessed type int read_button_inputs(void);
// 2000021A: using guessed type __int16 sys_boot_button_delay_timer_1ms_unit;
// 20003A90: using guessed type char button_delay_flag;
// 20003A91: using guessed type char button_debounce_timer;
// 20003A92: using guessed type char last_button_input;
// 20003A93: using guessed type char button_delay_buttons;
// 20003A9F: using guessed type char maybe_logging_was_active_at_some_point;
// 20003B03: using guessed type char new_buttons_pressed;
// 20003B04: using guessed type char new_buttons_held;
// 20003B06: using guessed type char curr_button_input;
// 20003B0A: using guessed type char setup_currently_editing;
// 20003B0E: using guessed type char button_hold_timer;
// 20003B0F: using guessed type char button_check_timer;
// 20003B60: using guessed type char cal_sd_state;

//----- (08017288) --------------------------------------------------------
void __fastcall button_auto_press_up_down(int activate)
{
  int v1; // r2@4
  char v2; // r1@8

  if ( (_BYTE)activate )
  {
    if ( button_repress_fast_counter )
    {
      v1 = (unsigned __int8)button_repress_fast_counter - 1;
      if ( (unsigned int)v1 <= 4 )
      {
        ++button_repress_counter;
        if ( (signed int)(unsigned __int8)button_repress_counter >= 31 )
        {
          ++button_repress_fast_counter;
          button_repress_counter = 0;
          new_buttons_pressed = 1;
          buttons_pressed = curr_button_input;
        }
      }
      else if ( v1 == 5 )
      {
        ++button_repress_counter;
        if ( (signed int)(unsigned __int8)button_repress_counter >= 11 )
        {
          button_repress_fast_counter = 6;
          button_repress_counter = 0;
          new_buttons_pressed = 1;
          buttons_pressed = curr_button_input;
        }
      }
    }
    else
    {
      if ( log_playback_mode )
        v2 = 3;
      else
        v2 = 50;
      ++button_repress_counter;
      if ( (unsigned __int8)v2 < (unsigned int)(unsigned __int8)button_repress_counter )
      {
        button_repress_fast_counter = 1;
        button_repress_counter = 0;
        new_buttons_pressed = 1;
        buttons_pressed = curr_button_input;
      }
    }
  }
  else
  {
    button_repress_fast_counter = 0;
    button_repress_counter = 0;
  }
}
// 20003A94: using guessed type char button_repress_fast_counter;
// 20003A95: using guessed type char button_repress_counter;
// 20003B03: using guessed type char new_buttons_pressed;
// 20003B06: using guessed type char curr_button_input;

//----- (08017358) --------------------------------------------------------
int __fastcall button_hold_is_being_held_with_mem(meter_buttons a1)
{
  meter_buttons v1; // r1@1
  int result; // r0@1

  v1 = a1;
  LOBYTE(result) = 0;
  if ( v1 == BTN_MODE
    || v1 == BTN_SETUP
    || v1 == BTN_MINMAX
    || v1 == BTN_MEM
    || v1 == BTN_RANGE
    || v1 == (BTN_HOLD|BTN_MEM)
    || v1 == BTN_REL
    || (unsigned __int8)v1 == BTN_PEAK )
    LOBYTE(result) = 1;
  return (unsigned __int8)result;
}

//----- (08017388) --------------------------------------------------------
bool __fastcall exactly_one_range_is_active(unsigned __int8 range_switch_bits)
{
  bool result; // r0@1

  LOBYTE(result) = 0;
  if ( range_switch_bits == 1
    || range_switch_bits == 2
    || range_switch_bits == 4
    || range_switch_bits == 8
    || range_switch_bits == 16
    || range_switch_bits == 32
    || range_switch_bits == 64
    || range_switch_bits == 128 )
    LOBYTE(result) = 1;
  return result;
}

//----- (080173C4) --------------------------------------------------------
int __fastcall hold_and_mem_are_both_being_pressed(meter_buttons a1)
{
  meter_buttons v1; // r1@1
  int result; // r0@1

  v1 = a1;
  LOBYTE(result) = 0;
  if ( v1 == (BTN_HOLD|BTN_MEM) )
    LOBYTE(result) = 1;
  return (unsigned __int8)result;
}

//----- (080173D6) --------------------------------------------------------
int read_button_inputs()
{
  int result; // r0@15

  curr_button_input = 0;
  if ( !(GPIOG.IDR & 0x100) )
    curr_button_input = 1;
  if ( !(GPIOG.IDR & 0x200) )
    curr_button_input |= 2u;
  if ( !(GPIOG.IDR & 0x400) )
    curr_button_input |= 4u;
  if ( !(GPIOG.IDR & 0x800) )
    curr_button_input |= 8u;
  if ( !(GPIOG.IDR & 0x1000) )
    curr_button_input |= 0x10u;
  if ( !(GPIOG.IDR & 0x2000) )
    curr_button_input |= 0x20u;
  if ( !(GPIOG.IDR & 0x4000) )
    curr_button_input |= 0x40u;
  result = LOWORD(GPIOG.IDR) << 16;
  if ( !(GPIOG.IDR & 0x8000) )
  {
    result = (unsigned __int8)curr_button_input | 0x80;
    curr_button_input |= 0x80u;
  }
  return result;
}
// 80173D6: using guessed type int read_button_inputs(void);
// 20003B06: using guessed type char curr_button_input;
// 40021C00: using guessed type GPIO_REGS GPIOG;

//----- (08017544) --------------------------------------------------------
float __fastcall fp_from_int(int num)
{
  float result; // r0@2
  float v2; // r0@3
  int (__fastcall *v3)(_DWORD); // r12@3

  if ( num < 0 )
  {
    v2 = fp_from_uint_core(-num);
    result = COERCE_FLOAT(v3(LODWORD(v2) | 0x80000000));// return v2 | 0x80000000
  }
  else
  {
    result = fp_from_uint_core(num);
  }
  return result;
}

//----- (08017558) --------------------------------------------------------
float __fastcall fp_from_uint(unsigned int num)
{
  return fp_from_uint_core(num);
}

//----- (0801755C) --------------------------------------------------------
float __fastcall fp_from_uint_core(float result)
{
  char is_zero; // zf@0
  unsigned int v2; // r1@2

  if ( !is_zero )
  {
    v2 = __clz(LODWORD(result));
    LODWORD(result) = (LODWORD(result) << v2 >> 8)
                    + __CFADD__(LODWORD(result) << v2 << 24, __CFSHL__(LODWORD(result) << v2, 24) + 0x7FFFFFFF)
                    + ((157 - v2) << 23);
  }
  return result;
}

//----- (08017576) --------------------------------------------------------
_DWORD *__fastcall read_bss_table_and_zero(_DWORD *a1)
{
  int v1; // r9@0
  _DWORD *result; // r0@1
  int v3; // r1@1
  int v4; // t1@1
  int v5; // r2@2
  int v6; // t1@2

  while ( 1 )
  {
    v4 = *a1;
    result = a1 + 1;
    v3 = v4;
    if ( !v4 )
      break;
    v6 = *result;
    a1 = result + 1;
    v5 = v6;
    if ( v6 << 31 < 0 )
      v5 += v1 - 1;
    do
    {
      *(_DWORD *)v5 = 0;
      v5 += 4;
      v3 -= 4;
    }
    while ( v3 );
  }
  return result;
}

//----- (08017598) --------------------------------------------------------
float __fastcall fp_div(float a, float b)
{
  int bexp; // r2@0
  signed int v3; // r3@1
  char v4; // zf@1
  int aexp; // r4@1
  int endexp; // r4@7
  unsigned int bsig; // r1@7
  unsigned int asig; // r0@7
  unsigned int v9; // r2@8
  unsigned int v10; // r1@10
  int v11; // lr@10
  unsigned int v12; // r2@10
  unsigned int v13; // r0@10
  unsigned int v14; // r2@10
  int v15; // r0@10
  unsigned __int8 v16; // vf@10
  int v17; // r4@10
  float result; // r0@12
  int v19; // r4@13
  int v20; // r2@13
  char v21; // zf@15
  int v22; // r0@18
  int v23; // r1@19
  char v24; // zf@21
  unsigned int v25; // r1@33
  int v26; // r2@33
  unsigned int v27; // r0@36
  unsigned int v28; // r4@36

  v3 = 255;
  aexp = (LODWORD(a) >> 23) & 0xFF;
  v4 = aexp == 0;
  if ( aexp )
  {
    bexp = (LODWORD(b) >> 23) & 0xFF;
    v4 = bexp == 0;
  }
  if ( !v4 )
  {
    v4 = aexp == 255;
    if ( aexp != 255 )
      v4 = bexp == 255;
  }
  if ( !v4 )
  {
    endexp = aexp - bexp;
    v3 = (LODWORD(a) ^ LODWORD(b)) & 0x80000000;
    bsig = (LODWORD(b) << 8) | 0x80000000;
    asig = (LODWORD(a) << 8) | 0x80000000;
LABEL_8:
    v9 = asig - bsig;
    if ( asig < bsig )
    {
      --endexp;
      v9 = bsig + 2 * v9;
    }
    v10 = bsig >> 8;
    v11 = v9 / v10;
    v12 = (v9 - v10 * (v9 / v10)) << 8;
    v13 = v12 / v10 & 0xFFFF00FF | ((unsigned __int8)v11 << 8);
    v14 = (v12 - v10 * (v12 / v10)) << 8;
    v15 = v14 / v10 | (v13 << 8);
    v16 = __OFADD__(endexp, 127);
    v17 = endexp + 127;
    if ( !((unsigned __int8)((v17 < 0) ^ v16) | (v17 == 0)) )
    {
      if ( v17 < 254 )
      {
        LODWORD(result) = (v17 << 23) + __CFSHL__(v17, 23) + (v3 | ((unsigned int)v15 >> 1));
        return result;
      }
      goto LABEL_20;
    }
    v19 = 2 - v17;
    v20 = v14 - v10 * (v14 / v10);
    if ( v19 <= 25 )
    {
      LODWORD(result) = v3
                      + __CFADD__(
                          ((v15 | 0x1000000) << (32 - v19)) | v20,
                          __CFSHL__(v15 | 0x1000000, 32 - v19) + 0x7FFFFFFF)
                      + ((v15 | 0x1000000u) >> v19);
      return result;
    }
    return *(float *)&v3;
  }
  v21 = aexp == 255;
  if ( aexp != 255 )
  {
    bexp = (LODWORD(b) >> 23) & 0xFF;
    v21 = bexp == 255;
  }
  if ( !v21 )
  {
    v3 = (LODWORD(a) ^ LODWORD(b)) & 0x80000000;
    v22 = 2 * LODWORD(a);
    if ( v22 )
    {
      v23 = 2 * LODWORD(b);
      if ( !v23 )
      {
LABEL_20:
        LODWORD(result) = v3 | 0x7F800000;
        return result;
      }
      if ( bexp )
      {
        bsig = (v23 << 7) | 0x80000000;
        v26 = -bexp;
      }
      else
      {
        v25 = v23 << 8;
        v26 = __clz(v25);
        bsig = v25 << v26;
        if ( aexp )
        {
          endexp = aexp + v26;
          asig = (v22 << 7) | 0x80000000;
          goto LABEL_8;
        }
      }
      v27 = v22 << 8;
      v28 = __clz(v27);
      asig = v27 << v28;
      endexp = v26 - v28;
      goto LABEL_8;
    }
    v24 = 2 * LODWORD(b) == 0;
LABEL_22:
    if ( v24 )
      v3 = ~bexp;
    return *(float *)&v3;
  }
  if ( aexp == 255 )
  {
    bexp -= 255;
    v24 = bexp == 0;
    if ( !bexp )
      goto LABEL_22;
    LODWORD(result) = LODWORD(a) ^ LODWORD(b) & 0x80000000;
  }
  else if ( LODWORD(b) << 9 )
  {
    result = b;
  }
  else
  {
    LODWORD(result) = (LODWORD(a) ^ LODWORD(b)) & 0x80000000;
  }
  return result;
}

//----- (08017694) --------------------------------------------------------
int __fastcall fp_to_int(float a1)
{
  unsigned int shift; // r1@2
  unsigned __int8 is_negative; // cf@3
  int v3; // r0@3
  int result; // r0@4
  unsigned int v5; // r0@7
  char v6; // nf@12

  if ( ((((unsigned int)(2 * LODWORD(a1)) >> 24) - 127) & 0x80000000) != 0 )// abs(number) < 1
  {
    result = 0;
  }
  else
  {
    shift = 158 - ((unsigned int)(2 * LODWORD(a1)) >> 24);
    if ( (shift & 0x80000000) != 0 )            // float is too big
    {
      v6 = SLODWORD(a1) < 0;
      result = 2147483648;
      if ( !v6 )
        result = 0x7FFFFFFF;
    }
    else
    {
      is_negative = __CFSHL__(LODWORD(a1), 1);
      v3 = 2 * LODWORD(a1);
      if ( is_negative )
      {
        v5 = ((v3 << 7) | 0x80000000) >> shift;
        if ( (v5 & 0x80000000) == 0 )
          result = -v5;
        else
          result = 2147483648;
      }
      else
      {
        result = ((v3 << 7) | 0x80000000) >> shift;
        if ( result < 0 )
          result = 0x7FFFFFFF;
      }
    }
  }
  return result;
}

//----- (080176D8) --------------------------------------------------------
void unlock_data_eeprom()
{
  if ( FLASH_PECR & 1 )                         // this decompilation is incorrect
                                                // there should be FLASH_PEKEYR = 0x89ABCDEF
                                                // before the shown write
    FLASH_PEKEYR = 0x2030405;
}
// 40023C0C: using guessed type int FLASH_PEKEYR;

//----- (080176F8) --------------------------------------------------------
void lock_data_eeprom(void)
{
  FLASH_PECR |= 1u;
}
// 40023C00: using guessed type int FLASH_ACR;

//----- (0801770A) --------------------------------------------------------
int __fastcall try_write_byte_to_eeprom_without_first_erasing(int addr, char data)
{
  int v2; // r4@1
  char v3; // r5@1
  int v4; // r6@1

  v2 = addr;
  v3 = data;
  v4 = (unsigned __int8)wait_for_flash_to_not_be_busy(0x8000);
  if ( v4 == 4 )                                // success
  {
    FLASH_PECR &= 0xFFFFFEFF;                   // don't erase byte before programming (???)
    *(_BYTE *)v2 = v3;
    LOBYTE(v4) = wait_for_flash_to_not_be_busy(0x8000);
  }
  return (unsigned __int8)v4;
}

//----- (08017744) --------------------------------------------------------
void unlock_option_bytes_and_data_eeprom(void)
{
  if ( FLASH_PECR & 4 )
  {
    unlock_data_eeprom();
    FLASH_OPTKEYR = 0x24252627;                 // this decompilation is incorrect
                                                // there should be FLASH_OPTKEYR = 0xFBEAD9C8
                                                // before displayed write
  }
}
// 40023C14: using guessed type int FLASH_OPTKEYR;

//----- (0801776A) --------------------------------------------------------
void reload_option_bytes()
{
  FLASH_PECR |= 0x40000u;
}
// 40023C00: using guessed type int FLASH_ACR;

//----- (0801777C) --------------------------------------------------------
void __fastcall probably_reprogram_brownout_level_or_otherwise_init_options(int a1)
{
  unsigned int v1; // r6@1

  v1 = (~(((unsigned int)FLASH_OBR >> 16) & 0xF0 | (unsigned __int8)a1) << 16) | ((unsigned int)FLASH_OBR >> 16) & 0xF0 | (unsigned __int8)a1;
  if ( (unsigned __int8)wait_for_flash_to_not_be_busy(0x8000) == 4 )
    v1FF80004 = v1;
  wait_for_flash_to_not_be_busy(0x8000);
}
// 40023C1C: using guessed type int FLASH_OBR;

//----- (080177CA) --------------------------------------------------------
unsigned int get_brownout_level_from_option_bytes()
{
  return ((unsigned int)FLASH_OBR >> 16) & 0xF;
}
// 40023C1C: using guessed type int FLASH_OBR;

//----- (080177D6) --------------------------------------------------------
void __fastcall set_flash_sr(int value)
{
  FLASH_SR = value;
}
// 40023C18: using guessed type int FLASH_SR;

//----- (080177DC) --------------------------------------------------------
int get_flash_status()
{
  int result; // r0@2

  if ( FLASH_SR & 1 )
  {
    LOBYTE(result) = 1;                         // busy
  }
  else if ( FLASH_SR & 0x100 )
  {
    LOBYTE(result) = 2;                         // write protected
  }
  else if ( FLASH_SR & 0x1E00 )
  {
    LOBYTE(result) = 3;                         // some other error
  }
  else
  {
    LOBYTE(result) = 4;                         // success
  }
  return (unsigned __int8)result;
}
// 40023C18: using guessed type int FLASH_SR;

//----- (0801783C) --------------------------------------------------------
int __fastcall wait_for_flash_to_not_be_busy(int how_long)
{
  int v1; // r4@1
  char v3; // [sp+0h] [bp-10h]@1

  v1 = how_long;
  v3 = get_flash_status();
  while ( v3 == 1 && v1 )
  {
    v3 = get_flash_status();
    --v1;
  }
  if ( !v1 )
    v3 = 5;                                     // timeout
  return (unsigned __int8)v3;
}

//----- (08017878) --------------------------------------------------------
unsigned int __fastcall config_usart(USART_REGS *USART, int a2)
{
  USART_REGS *v2; // r4@1
  int v3; // r5@1
  __int16 v4; // t1@1
  int v5; // r6@2
  unsigned int v6; // r7@5
  unsigned int v7; // r9@7
  unsigned int v8; // r8@7
  unsigned int result; // r0@8
  __int16 v10; // r9@8
  int info; // [sp+0h] [bp-30h]@1
  int v12; // [sp+8h] [bp-28h]@3
  int v13; // [sp+Ch] [bp-24h]@2

  v2 = USART;
  v3 = a2;
  v4 = *(_WORD *)(a2 + 12);
  LOWORD(USART->CR2) = *(_WORD *)(a2 + 6) | USART->CR2 & 0xCFFF;
  LOWORD(USART->CR1) = *(_WORD *)(a2 + 4) | *(_WORD *)(a2 + 8) | *(_WORD *)(a2 + 10) | USART->CR1 & 0xE9F3;
  LOWORD(v2->CR3) = *(_WORD *)(a2 + 12) | v2->CR3 & 0xFCFF;
  get_sys_clock_info(&info);
  if ( v2 == (USART_REGS *)0x40013800 )
    v5 = v13;
  else
    v5 = v12;
  if ( v2->CR1 & 0x8000 )
    v6 = 25 * v5 / (unsigned int)(2 * *(_DWORD *)v3);
  else
    v6 = 25 * v5 / (unsigned int)(4 * *(_DWORD *)v3);
  v7 = 16 * (v6 / 0x64);
  v8 = v6 - 100 * (v6 / 0x64 & 0xFFFFFFF);
  if ( v2->CR1 & 0x8000 )
  {
    result = (8 * v8 + 50) / 0x64 & 7;
    v10 = result | v7;
  }
  else
  {
    result = (16 * v8 + 50) / 0x64 & 0xF;
    v10 = result | v7;
  }
  LOWORD(v2->BRR) = v10;
  return result;
}

//----- (08017968) --------------------------------------------------------
void __fastcall set_usart_enable(USART_REGS *USART, char enable)
{
  if ( enable )
    LOWORD(USART->CR1) |= 0x2000u;
  else
    LOWORD(USART->CR1) &= 0xDFFFu;
}

//----- (08017984) --------------------------------------------------------
void __fastcall usart_write_data_reg(USART_REGS *USART, __int16 data)
{
  LOWORD(USART->DR) = data & 0x1FF;
}

//----- (0801798C) --------------------------------------------------------
int __fastcall sub_801798C(int a1)
{
  return *(_WORD *)(a1 + 4) & 0x1FF;
}

//----- (08017994) --------------------------------------------------------
void __fastcall set_usart_control_bit(USART_REGS *USART, unsigned __int8 a2, char a3)
{
  int v3; // r3@1
  signed int v4; // r5@1
  char *v5; // r6@2

  v3 = a2 >> 5;
  v4 = 1 << (a2 & 0x1F);
  if ( v3 == 1 )
  {
    v5 = (char *)&USART->CR1;
  }
  else if ( v3 == 2 )
  {
    v5 = (char *)&USART->CR2;
  }
  else
  {
    v5 = (char *)&USART->CR3;
  }
  if ( a3 )
    *(_DWORD *)v5 |= v4;
  else
    *(_DWORD *)v5 &= ~v4;
}

//----- (080179EA) --------------------------------------------------------
bool __fastcall get_usart_status_bits(USART_REGS *USART, unsigned __int16 mask)
{
  return (USART->SR & mask) != 0;
}

//----- (08017A08) --------------------------------------------------------
int __fastcall sub_8017A08(int a1, __int16 a2)
{
  int v2; // r4@1
  signed int v3; // r5@1
  int v4; // r5@2
  int result; // r0@8

  v2 = (unsigned __int8)a2 >> 5;
  v3 = 1 << (a2 & 0x1F);
  if ( v2 == 1 )
  {
    v4 = (unsigned __int16)(v3 & *(_WORD *)(a1 + 12));
  }
  else if ( v2 == 2 )
  {
    v4 = (unsigned __int16)(v3 & *(_WORD *)(a1 + 16));
  }
  else
  {
    v4 = (unsigned __int16)(v3 & *(_WORD *)(a1 + 20));
  }
  LOBYTE(result) = v4 && (1 << SHIBYTE(a2)) & *(_WORD *)a1;
  return (unsigned __int8)result;
}

//----- (08017A76) --------------------------------------------------------
int __fastcall sub_8017A76(int result, __int16 a2)
{
  *(_WORD *)result = ~(unsigned __int16)(1 << SHIBYTE(a2));
  return result;
}

//----- (08017A9C) --------------------------------------------------------
void __fastcall hy_read_update_and_do_cap_stuff()
{
  if ( GPIOF.IDR & 8 )                          // has the HY sent an IRQ
    hy_read_regs_and_process_ints();
  if ( curr_meas_mode == MM_CAP && (signed int)curr_meas_range < 5 )// less than 10mF range
    meas_process_cap_autorange();
}
// 40021800: using guessed type GPIO_REGS GPIOF;

//----- (08017AC6) --------------------------------------------------------
void __fastcall hy_read_regs_and_process_ints()
{
  read_registers_from_hy3131(hy_regs_buf, 0, 52u);// read all registers
  curr_hy_INTF = 0;                             // clear all interrupt flags
  send_data_to_hy3131(&curr_hy_INTF, 0x1E, 1u);
  curr_hy_pendingints = hy_regs_buf[0x1E] & hy_regs_buf[0x1F];// pending interrupts are enabled (30) and flagged (31)
  curr_hy_R20 = hy_regs_buf[0x20];
  curr_hy_R29 = hy_regs_buf[0x29];
  if ( hy_regs_buf[0x1E] & hy_regs_buf[0x1F] & 4 )// AD1 interrupt
    hy_process_AD1_int();
  if ( curr_hy_pendingints & 0x10 )             // RMS interrupt
    hy_process_RMS_int();
  if ( curr_hy_R29 & 4 && !meter_mode_acv_dcv ) // peak hold enabled in chipset and not in AC/DC mode
    hy_process_peak_hold();
  if ( curr_hy_pendingints & 1 )                // CT interrupt
    hy_process_CT_int();
}
// 200038A4: using guessed type char curr_hy_INTF;
// 20003B18: using guessed type char curr_hy_R20;
// 20003B19: using guessed type char curr_hy_R29;
// 20003B1A: using guessed type char curr_hy_pendingints;
// 20003B52: using guessed type char meter_mode_acv_dcv;

//----- (08017B5C) --------------------------------------------------------
void hy_process_AD1_int(void)
{
  hy_curr_AD1_internal = hy_get_AD1();
  hy_curr_AD1 = hy_curr_AD1_internal;
  hy_AD1_new_avg = hy_add_to_AD1_avg(hy_curr_AD1_internal);
  if ( curr_meas_mode == MM_DCuVA || curr_meas_mode == MM_DCmVA || curr_meas_mode == MM_DCVA )
  {
    meas_process_dc_va();
    return;
  }
  if ( curr_meas_mode == MM_ACuVA || curr_meas_mode == MM_ACmVA || curr_meas_mode == MM_ACVA )
  {
    meas_process_ac_va();
    return;
  }
  if ( curr_meas_mode == MM_LOW_Z )
  {
    meas_process_lowz();
    return;
  }
  if ( curr_meas_mode == MM_DCV )
  {
LABEL_31:
    meas_process_dcv();
    return;
  }
  if ( curr_meas_mode == MM_ACV )
  {
    if ( !meter_mode_acv_dcv || meter_mode_acv_dcv && !acv_dcv_measuring_dc )
    {
      meas_process_acv();
      return;
    }
    goto LABEL_31;
  }
  if ( curr_meas_mode == MM_DCmV )
  {
    meas_process_dcmv();
    return;
  }
  if ( curr_meas_mode == MM_ACmV )
  {
    meas_process_acmv();
    return;
  }
  if ( curr_meas_mode == MM_TEMP )
  {
    meas_process_temp();
    return;
  }
  if ( curr_meas_mode == MM_OHMS )
  {
    meas_process_ohms();
    return;
  }
  if ( curr_meas_mode == MM_CONTINUITY )
  {
    meas_process_continuity();
    return;
  }
  if ( curr_meas_mode == MM_DIODE )
  {
    meas_process_diode();
    return;
  }
  if ( curr_meas_mode == MM_ACuA )
    goto LABEL_38;
  if ( curr_meas_mode == MM_DCuA )
    goto LABEL_37;
  if ( curr_meas_mode == MM_ACmA )
  {
LABEL_38:
    meas_process_ac_amps();
    return;
  }
  if ( curr_meas_mode == MM_DCmA )
  {
LABEL_37:
    meas_process_dc_amps();
    return;
  }
  if ( curr_meas_mode == MM_ACA )
    goto LABEL_38;
  if ( curr_meas_mode == MM_DCA )
    goto LABEL_37;
}
// 20003860: using guessed type int hy_curr_AD1;
// 200038AC: using guessed type int hy_curr_AD1_internal;
// 20003B1C: using guessed type char hy_AD1_new_avg;
// 20003B52: using guessed type char meter_mode_acv_dcv;
// 20003B55: using guessed type char acv_dcv_measuring_dc;

//----- (08017C70) --------------------------------------------------------
int hy_get_AD1()
{
  int result; // r0@2

  hy_curr_AD1_unsigned = hy_regs_buf[0] + (hy_regs_buf[1] << 8) + (hy_regs_buf[2] << 16);
  if ( hy_regs_buf[0] + (hy_regs_buf[1] << 8) + ((unsigned int)hy_regs_buf[2] << 16) <= 0x800000 )
    result = hy_curr_AD1_unsigned;
  else
    result = -(0xFFFFFF - hy_curr_AD1_unsigned);
  return result;
}
// 200038A8: using guessed type int hy_curr_AD1_unsigned;

//----- (08017CBA) --------------------------------------------------------
int __fastcall hy_add_to_AD1_avg(int ad1)
{
  int v1; // r1@1
  signed int avgs; // r2@1

  v1 = ad1;
  LOBYTE(ad1) = 0;
  avgs = 16;
  if ( curr_meas_mode != MM_DCuA
    && curr_meas_mode != MM_DCmA
    && curr_meas_mode != MM_DCA
    && curr_meas_mode != MM_DCV
    && curr_meas_mode != MM_DCmV )
  {
    if ( curr_meas_mode == MM_OHMS )
      avgs = 8;
  }
  else
  {
    avgs = 16;
  }
  if ( hy_ad1_avg_ctr )
    hy_ad1_avg_sum += v1;
  else
    hy_ad1_avg_sum = v1;
  ++hy_ad1_avg_ctr;
  if ( (unsigned __int8)hy_ad1_avg_ctr >= avgs )
  {
    hy_AD1_avg = hy_ad1_avg_sum / (unsigned __int8)hy_ad1_avg_ctr;
    hy_ad1_avg_ctr = 0;
    hy_ad1_avg_sum = 0;
    LOBYTE(ad1) = 1;
  }
  return (unsigned __int8)ad1;
}
// 200038B0: using guessed type int hy_ad1_avg_sum;
// 200038B4: using guessed type int hy_AD1_avg;
// 20003B1B: using guessed type char hy_ad1_avg_ctr;

//----- (08017D6C) --------------------------------------------------------
void __fastcall meas_calc_final_scr_digits()
{
  if ( (curr_meas_mode == MM_ACuVA
     || curr_meas_mode == MM_ACmVA
     || curr_meas_mode == MM_ACVA
     || curr_meas_mode == MM_DCuVA
     || curr_meas_mode == MM_DCmVA
     || curr_meas_mode == MM_DCVA)
    && calibrating_offset )
  {
    curr_scr_digits = hy_AD1_avg;
  }
  else
  {
    curr_scr_digits = meas_apply_offset_adj(hy_AD1_avg);
    if ( curr_meas_mode != MM_ACuVA
      && curr_meas_mode != MM_ACmVA
      && curr_meas_mode != MM_ACVA
      && curr_meas_mode != MM_DCuVA
      && curr_meas_mode != MM_DCmVA
      && curr_meas_mode != MM_DCVA
      || !calibrating_gain )
      curr_scr_digits = meas_apply_gain_adj(curr_scr_digits);
  }
}
// 20003858: using guessed type int curr_scr_digits;
// 200038B4: using guessed type int hy_AD1_avg;
// 20003B26: using guessed type char calibrating_offset;
// 20003B28: using guessed type char calibrating_gain;

//----- (08017E2A) --------------------------------------------------------
void __fastcall meas_calc_bargraph_digits()
{
  if ( curr_meas_mode != MM_DCuVA
    && curr_meas_mode != MM_DCmVA
    && curr_meas_mode != MM_DCVA
    && curr_meas_mode != MM_ACuVA
    && curr_meas_mode != MM_ACmVA
    && curr_meas_mode != MM_ACVA )
  {
    curr_bargraph_digits = meas_perform_offset_adj(hy_curr_AD1);
    curr_bargraph_digits = meas_perform_gain_adj(curr_bargraph_digits);
    need_to_update_bargraph = 1;
  }
}
// 2000385C: using guessed type int curr_bargraph_digits;
// 20003860: using guessed type int hy_curr_AD1;
// 20003AFA: using guessed type char need_to_update_bargraph;

//----- (08017E94) --------------------------------------------------------
void __fastcall meas_process_lowz()
{
  if ( lowz_measuring_ac )
    meas_process_acv();
  else
    meas_process_dcv();
}
// 20003B32: using guessed type char lowz_measuring_ac;

//----- (08017EAC) --------------------------------------------------------
void meter_process_new_lowz_meas()
{
  signed int v0; // r4@2

  if ( lowz_active_cause_of_enough_volts )
    v0 = 30;
  else
    v0 = 100;
  if ( v0 < curr_scr_digits || (curr_scr_digits + v0 < 0) ^ __OFADD__(curr_scr_digits, v0) || curr_scr_overflow )
  {
    set_lowz_acdc_switch_counter();
    if ( !lowz_active_cause_of_enough_volts )
    {
      curr_scr_digits = 0;
      --lowz_active_lockout_timer;
      if ( !lowz_active_lockout_timer )
      {
        lowz_active_cause_of_enough_volts = 1;
        scr_need_to_refresh_meas_units_and_icons = 1;
      }
    }
  }
  else
  {
    curr_scr_digits = 0;
    lowz_active_cause_of_enough_volts = 0;
    lowz_active_lockout_timer = 5;
    scr_need_to_refresh_meas_units_and_icons = 1;
    --lowz_acdc_switch_timer;
    if ( !lowz_acdc_switch_timer )
    {
      lowz_measuring_ac = lowz_measuring_ac == 0;
      set_lowz_acdc_switch_counter();
      meter_process_range_mode_changed(0);
    }
  }
}
// 20000224: using guessed type char lowz_acdc_switch_timer;
// 20000225: using guessed type char lowz_active_lockout_timer;
// 20003858: using guessed type int curr_scr_digits;
// 20003AFC: using guessed type char scr_need_to_refresh_meas_units_and_icons;
// 20003B32: using guessed type char lowz_measuring_ac;
// 20003B33: using guessed type char lowz_active_cause_of_enough_volts;

//----- (08017F78) --------------------------------------------------------
void set_lowz_acdc_switch_counter()
{
  lowz_acdc_switch_timer = 5;                   // this factor is set to 5 whether maybe_lowz_ac is true or not
}
// 20000224: using guessed type char lowz_acdc_switch_timer;
// 20003B32: using guessed type char lowz_measuring_ac;

//----- (08017F96) --------------------------------------------------------
void __fastcall meas_process_ac_amps()
{
  if ( (unsigned __int8)meter_in_cal_mode | (unsigned __int8)(burden_enabled_for_current_ranges ^ 1) )
  {
    meas_process_ac_amps_core();
  }
  else
  {
    if ( measuring_amps_of_va_or_volts_of_burden )
    {
      meas_process_acv();
      if ( hy_AD1_new_avg )
        burden_last_volts = curr_scr_digits;
    }
    else
    {
      meas_process_ac_amps_core();
    }
    if ( meas_was_updated )
    {
      ++meas_amp_burden_timer;
      if ( (unsigned __int8)meas_amp_burden_timer > 6u )
      {
        if ( measuring_amps_of_va_or_volts_of_burden )
        {
          burden_last_volts = meas_process_burden_volts(burden_last_volts);
          burden_overflow = 0;
          if ( burden_last_volts >= 5001 )
            burden_overflow = 1;
          need_to_update_bargraph = 0;
          meas_was_updated = 0;
          if ( curr_sub_mode == SM_SPL2 )
            need_to_update_subscr = 1;
        }
        meas_amp_burden_timer = 0;
        measuring_amps_of_va_or_volts_of_burden ^= 1u;
        prepare_reading_ac_amps(measuring_amps_of_va_or_volts_of_burden != 0);
      }
      else
      {
        need_to_update_bargraph = 0;
        meas_was_updated = 0;
      }
    }
  }
}
// 20003858: using guessed type int curr_scr_digits;
// 2000394C: using guessed type int burden_last_volts;
// 20003AFA: using guessed type char need_to_update_bargraph;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B1C: using guessed type char hy_AD1_new_avg;
// 20003B23: using guessed type char cal_mode_load_from_sd;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B3D: using guessed type char burden_enabled_for_current_ranges;
// 20003B3F: using guessed type char burden_overflow;
// 20003B59: using guessed type char measuring_amps_of_va_or_volts_of_burden;
// 20003B5A: using guessed type char meas_amp_burden_timer;

//----- (080180AE) --------------------------------------------------------
void __fastcall prepare_reading_ac_amps(char measuring_burden_voltage)
{
  if ( measuring_burden_voltage )
  {
    config_hy_based_on_mode_range(MM_ACV, 0);
    cal_load_factors_for_mode_and_range(MM_ACV, 0);
    meas_setup_hw(MM_ACV, 0);
  }
  else
  {
    config_hy_based_on_mode_range(curr_meas_mode, curr_meas_range);
    cal_load_factors_for_mode_and_range(curr_meas_mode, curr_meas_range);
    meas_setup_hw(curr_meas_mode, curr_meas_range);
  }
  meter_set_mode_range_change_delay();
  hy_change_CTA_val_timer = 0;
}

//----- (08018110) --------------------------------------------------------
void __fastcall meas_process_ac_amps_core()
{
  if ( hy_AD1_new_avg )
  {
    if ( curr_meas_mode != MM_ACuVA && curr_meas_mode != MM_ACmVA && curr_meas_mode != MM_ACVA )
    {
      if ( calibrating_offset )
      {
        cal_ac_offset_temp_result = cal_update_ac_offset_accu(hy_AD1_avg);
      }
      else if ( calibrating_gain
             && curr_meas_mode != MM_ACuVA
             && curr_meas_mode != MM_ACmVA
             && curr_meas_mode != MM_ACVA )
      {
        cal_update_ac_gain_accu(hy_AD1_avg, cal_ac_offset_temp_result);
      }
      else
      {
        curr_scr_digits = meas_perform_offset_adj_ac(hy_AD1_avg);
        if ( curr_scr_digits < 0 )
          curr_scr_digits = 0;
        curr_scr_digits = meas_perform_gain_adj(curr_scr_digits);
        meas_apply_ac_freq_dependent_offset(curr_meas_mode);
      }
      if ( !curr_meas_range )
      {
        curr_scr_digits -= curr_amp_rel;
        if ( curr_scr_digits < 0 )
          curr_scr_digits = 0;
      }
    }
    else
    {
      meas_display_ac_amps();
    }
    curr_scr_digits = meas_add_rolling_average_buf1(curr_scr_digits, 20, 10u);
    cal_save_scr_to_ac_factor();
    if ( (curr_meas_mode == MM_ACuA || curr_meas_mode == MM_ACmA || curr_meas_mode == MM_ACA)
      && !curr_meas_range
      && curr_scr_digits < 31 )
      curr_scr_digits = 0;
    meas_was_updated = 1;
  }
  if ( curr_meas_mode != MM_ACuVA && curr_meas_mode != MM_ACmVA && curr_meas_mode != MM_ACVA )
    meas_calc_bargraph_digits_ac(hy_curr_AD1);
  if ( (curr_meas_mode == MM_ACuA
     || curr_meas_mode == MM_ACmA
     || curr_meas_mode == MM_ACA
     || curr_meas_mode == MM_DCuA
     || curr_meas_mode == MM_DCmA
     || curr_meas_mode == MM_DCA)
    && curr_sub_mode == SM_SPL1 )
    need_to_update_subscr = 1;
}
// 20003858: using guessed type int curr_scr_digits;
// 20003860: using guessed type int hy_curr_AD1;
// 200038B4: using guessed type int hy_AD1_avg;
// 200038E8: using guessed type int cal_ac_offset_temp_result;
// 200038EC: using guessed type int curr_amp_rel;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B1C: using guessed type char hy_AD1_new_avg;
// 20003B26: using guessed type char calibrating_offset;
// 20003B28: using guessed type char calibrating_gain;

//----- (080182D6) --------------------------------------------------------
void __fastcall meas_display_ac_amps()
{
  meas_calc_final_scr_digits();
  if ( curr_scr_digits < 0 )
    curr_scr_digits = 0;
}
// 20003858: using guessed type int curr_scr_digits;

//----- (080182F0) --------------------------------------------------------
void __fastcall meas_process_acmv()
{
  if ( hy_AD1_new_avg && !input_1ms_peak_enabled )
  {
    if ( curr_meas_mode != MM_ACuVA && curr_meas_mode != MM_ACmVA && curr_meas_mode != MM_ACVA )
    {
      if ( calibrating_offset )
      {
        cal_ac_offset_temp_result = cal_update_ac_offset_accu(hy_AD1_avg);
      }
      else if ( calibrating_gain )
      {
        cal_update_ac_gain_accu(hy_AD1_avg, cal_ac_offset_temp_result);
      }
      else
      {
        curr_scr_digits = meas_perform_offset_adj_ac(hy_AD1_avg);
        if ( curr_scr_digits < 0 )
          curr_scr_digits = 0;
        curr_scr_digits = meas_perform_gain_adj(curr_scr_digits);
        meas_apply_ac_freq_dependent_offset(curr_meas_mode);
        curr_scr_digits = meas_add_rolling_average_buf1(curr_scr_digits, 20, 0xAu);
        cal_save_scr_to_ac_factor();
        meas_was_updated = 1;
      }
    }
    else
    {
      meas_display_acv_acmv();
    }
  }
  meas_calc_bargraph_digits_ac(hy_curr_AD1);
}
// 20003858: using guessed type int curr_scr_digits;
// 20003860: using guessed type int hy_curr_AD1;
// 200038B4: using guessed type int hy_AD1_avg;
// 200038E8: using guessed type int cal_ac_offset_temp_result;
// 20003B1C: using guessed type char hy_AD1_new_avg;
// 20003B26: using guessed type char calibrating_offset;
// 20003B28: using guessed type char calibrating_gain;
// 20003B4F: using guessed type char input_1ms_peak_enabled;

//----- (080183C2) --------------------------------------------------------
void __fastcall meas_display_acv_acmv()
{
  meas_calc_final_scr_digits();
  if ( curr_scr_digits < 0 )
    curr_scr_digits = 0;
  curr_scr_digits = meas_add_rolling_average_buf1(curr_scr_digits, 20, 10u);
  meas_calc_acv_subscr_vals();
}
// 20003858: using guessed type int curr_scr_digits;

//----- (080183FC) --------------------------------------------------------
void __fastcall meas_process_acv()
{
  if ( hy_AD1_new_avg && !input_1ms_peak_enabled )
  {
    if ( curr_meas_mode != MM_ACuVA && curr_meas_mode != MM_ACmVA && curr_meas_mode != MM_ACVA )
    {
      if ( calibrating_offset )
      {
        cal_ac_offset_temp_result = cal_update_ac_offset_accu(hy_AD1_avg);
      }
      else if ( calibrating_gain
             && curr_meas_mode != MM_ACuVA
             && curr_meas_mode != MM_ACmVA
             && curr_meas_mode != MM_ACVA )
      {
        cal_update_ac_gain_accu(hy_AD1_avg, cal_ac_offset_temp_result);
      }
      else
      {
        curr_scr_digits = meas_perform_offset_adj_ac(hy_AD1_avg);
        if ( curr_scr_digits < 0 )
          curr_scr_digits = 0;
        curr_scr_digits = meas_perform_gain_adj(curr_scr_digits);
        meas_apply_ac_freq_dependent_offset(curr_meas_mode);
        curr_scr_digits = meas_add_rolling_average_buf1(curr_scr_digits, 20, 10u);
        cal_save_scr_to_ac_factor();
        meas_calc_acv_subscr_vals();
      }
    }
    else
    {
      meas_display_acv_acmv();
    }
  }
  if ( curr_meas_mode != MM_ACuVA
    && curr_meas_mode != MM_ACmVA
    && curr_meas_mode != MM_ACVA
    && curr_meas_mode != MM_ACuA
    && curr_meas_mode != MM_ACmA
    && curr_meas_mode != MM_ACA
    && curr_meas_mode != MM_DCuA
    && curr_meas_mode != MM_DCmA
    && curr_meas_mode != MM_DCA
    && (curr_meas_mode != MM_ACV || !meter_mode_acv_dcv)
    && (curr_meas_mode || curr_meas_mode == MM_LOW_Z && lowz_acdc_switch_timer == 5) )
    meas_calc_bargraph_digits_ac(hy_curr_AD1);
}
// 20000224: using guessed type char lowz_acdc_switch_timer;
// 20003858: using guessed type int curr_scr_digits;
// 20003860: using guessed type int hy_curr_AD1;
// 200038B4: using guessed type int hy_AD1_avg;
// 200038E8: using guessed type int cal_ac_offset_temp_result;
// 20003B1C: using guessed type char hy_AD1_new_avg;
// 20003B26: using guessed type char calibrating_offset;
// 20003B28: using guessed type char calibrating_gain;
// 20003B4F: using guessed type char input_1ms_peak_enabled;
// 20003B52: using guessed type char meter_mode_acv_dcv;

//----- (08018568) --------------------------------------------------------
void __fastcall meas_apply_ac_freq_dependent_offset(meter_meas_mode mode)
{
  char range; // r5@1

  range = 0;
  if ( !burden_enabled_for_current_ranges
    && !meter_in_cal_mode
    && (mode == MM_ACuA || mode == MM_ACmA || mode == MM_ACA || mode == MM_ACV || mode == MM_ACmV) )
  {
    if ( mode == MM_ACmV )
    {
      range = curr_meas_range;
    }
    else if ( mode == MM_ACV )
    {
      range = curr_meas_range + 2;
    }
    else if ( mode )
    {
      if ( mode == MM_ACuA || mode == MM_ACmA || mode == MM_ACA )
      {
        if ( mode == MM_ACuA )
        {
          range = 6;
        }
        else if ( mode == MM_ACmA )
        {
          range = 7;
        }
        else
        {
          range = 8;
        }
      }
    }
    else
    {
      range = 5;
    }
    curr_ac_offset = meas_calc_ac_freq_dependent_offset(range, curr_scr_digits);
    curr_scr_digits -= curr_ac_offset;
  }
}
// 20003858: using guessed type int curr_scr_digits;
// 2000393C: using guessed type int curr_ac_offset;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B3D: using guessed type char burden_enabled_for_current_ranges;

//----- (08018624) --------------------------------------------------------
void __fastcall cal_save_scr_to_ac_factor()
{
  if ( !burden_enabled_for_current_ranges
    && meter_in_cal_mode
    && (curr_meas_mode == MM_ACuA
     || curr_meas_mode == MM_ACmA
     || curr_meas_mode == MM_ACA
     || curr_meas_mode == MM_ACV
     || curr_meas_mode == MM_ACmV) )
  {
    if ( cal_save_ac_factor_decirange )
    {
      cal_save_ac_factor_decirange = 0;
      cal_ac_factor_update_and_save(1, curr_scr_digits);
      beep_contentedly();
    }
    if ( cal_save_ac_factor_fullrange )
    {
      cal_save_ac_factor_fullrange = 0;
      cal_ac_factor_update_and_save(2, curr_scr_digits);
      beep_contentedly();
    }
    if ( cal_save_ac_factor_decirange_lf )
    {
      cal_save_ac_factor_decirange_lf = 0;
      cal_ac_factor_update_and_save(3, curr_scr_digits);
      beep_contentedly();
    }
    if ( cal_save_ac_factor_fullrange_lf )
    {
      cal_save_ac_factor_fullrange_lf = 0;
      cal_ac_factor_update_and_save(4, curr_scr_digits);
      beep_contentedly();
    }
  }
}
// 20003858: using guessed type int curr_scr_digits;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B36: using guessed type char cal_save_ac_factor_decirange;
// 20003B37: using guessed type char cal_save_ac_factor_fullrange;
// 20003B38: using guessed type char cal_save_ac_factor_decirange_lf;
// 20003B39: using guessed type char cal_save_ac_factor_fullrange_lf;
// 20003B3D: using guessed type char burden_enabled_for_current_ranges;

//----- (080186FC) --------------------------------------------------------
int __fastcall meas_calc_ac_freq_dependent_offset(unsigned __int8 range, signed int digits)
{
  if ( curr_meas_mode != MM_ACuA
    && curr_meas_mode != MM_ACmA
    && curr_meas_mode != MM_ACA
    && curr_meas_mode != MM_ACV
    && curr_meas_mode != MM_ACmV )
  {
    if ( curr_meas_mode == MM_LOW_Z && lowz_measuring_ac )
    {
      ac_input_freq = ac_input_freq_lowz;
      ac_input_freq_range = ac_input_freq_range_lowz;
    }
  }
  else if ( curr_meas_mode == MM_ACV && meter_mode_acv_dcv )
  {
    ac_input_freq = ac_input_freq_acv;
    ac_input_freq_range = ac_input_freq_range_acv;
  }
  return meas_calc_ac_freq_dependent_offset_core(
           digits,
           cal_ac_factor_decirange,
           cal_ac_factor_fullrange,
           cal_ac_factor_decirange_lf,
           cal_ac_factor_fullrange_lf,
           range,
           ac_input_freq,
           ac_input_freq_range);
}
// 20003870: using guessed type int ac_input_freq;
// 20003940: using guessed type int ac_input_freq_acv;
// 20003944: using guessed type int ac_input_freq_lowz;
// 20003B32: using guessed type char lowz_measuring_ac;
// 20003B3A: using guessed type char ac_input_freq_range_acv;
// 20003B3B: using guessed type char ac_input_freq_range_lowz;
// 20003B52: using guessed type char meter_mode_acv_dcv;

//----- (080187D0) --------------------------------------------------------
void __fastcall meas_calc_acv_subscr_vals()
{
  if ( curr_meas_mode == MM_ACV && meter_mode_acv_dcv )
  {
    if ( !acv_dcv_measuring_dc )
      meas_acv_dcv_calc_next_mode(acv_dcv_measuring_dc);
  }
  else
  {
    meas_was_updated = 1;
  }
  meas_calc_dBm();
  if ( curr_meas_mode == MM_ACV && curr_sub_mode == SM_SPL2 )
    need_to_update_subscr = 1;
}
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B52: using guessed type char meter_mode_acv_dcv;
// 20003B55: using guessed type char acv_dcv_measuring_dc;

//----- (08018830) --------------------------------------------------------
void __fastcall meas_process_dcv()
{
  if ( hy_AD1_new_avg )
  {
    meas_calc_final_scr_digits();
    curr_scr_digits = meas_add_rolling_average_buf2(curr_scr_digits, 2, 2u);
    if ( curr_meas_mode != MM_ACV || !meter_mode_acv_dcv )
      meas_was_updated = 1;
    if ( curr_meas_mode == MM_ACV && meter_mode_acv_dcv && acv_dcv_measuring_dc == 1 )
      meas_acv_dcv_calc_next_mode(acv_dcv_measuring_dc);
  }
  if ( (curr_meas_mode != MM_ACV || !meter_mode_acv_dcv)
    && curr_meas_mode != MM_ACuA
    && curr_meas_mode != MM_ACmA
    && curr_meas_mode != MM_ACA
    && curr_meas_mode != MM_DCuA
    && curr_meas_mode != MM_DCmA
    && curr_meas_mode != MM_DCA
    && (curr_meas_mode || curr_meas_mode == MM_LOW_Z && lowz_acdc_switch_timer == 5) )
    meas_calc_bargraph_digits();
}
// 20000224: using guessed type char lowz_acdc_switch_timer;
// 20003858: using guessed type int curr_scr_digits;
// 20003B1C: using guessed type char hy_AD1_new_avg;
// 20003B52: using guessed type char meter_mode_acv_dcv;
// 20003B55: using guessed type char acv_dcv_measuring_dc;

//----- (08018920) --------------------------------------------------------
void __fastcall meas_process_dcmv()
{
  if ( hy_AD1_new_avg )
  {
    meas_calc_final_scr_digits();
    curr_scr_digits = meas_add_rolling_average_buf2(curr_scr_digits, 5, 10u);
    meas_was_updated = 1;
  }
  meas_calc_bargraph_digits();
}
// 20003858: using guessed type int curr_scr_digits;
// 20003B1C: using guessed type char hy_AD1_new_avg;

//----- (08018964) --------------------------------------------------------
void __fastcall meas_process_temp()
{
  int v0; // r4@3
  int v1; // r4@5

  meas_process_dcmv();
  if ( meas_was_updated )
  {
    meas_calc_temp_from_dcmv(temp_offset + curr_scr_digits);
    v0 = temp_meas_val;
    if ( !temp_in_c )
      v0 = temp_conv_c_to_f(temp_meas_val);
    v1 = v0 / 10;
    if ( v1 % 10 >= 5 )
      ++v1;
    if ( meas_was_updated )
      curr_scr_digits = v1;
    curr_bargraph_digits = v1;
  }
  else
  {
    need_to_update_bargraph = 0;
  }
}
// 20003858: using guessed type int curr_scr_digits;
// 2000385C: using guessed type int curr_bargraph_digits;
// 2000395C: using guessed type int temp_offset;
// 20003960: using guessed type int temp_meas_val;
// 20003AFA: using guessed type char need_to_update_bargraph;
// 20003B43: using guessed type char temp_in_c;

//----- (080189DC) --------------------------------------------------------
void __fastcall meas_process_continuity()
{
  meas_process_ohms();
  meas_do_continuity(curr_bargraph_digits);
}
// 2000385C: using guessed type int curr_bargraph_digits;

//----- (080189F8) --------------------------------------------------------
void __fastcall meas_do_continuity(unsigned int bargraph_digits)
{
  unsigned int v1; // r4@1
  signed int v2; // r5@1

  v1 = bargraph_digits;
  v2 = meas_calc_beep_threshold();
  if ( curr_continuity_threshold && curr_continuity_threshold != 2 )
  {
    if ( v1 < v2 )
    {
      continuity_beeping = 0;
    }
    else
    {
      continuity_beeping = 1;
      beep_ms(0x64u);
    }
  }
  else if ( v2 < v1 )
  {
    continuity_beeping = 0;
  }
  else
  {
    continuity_beeping = 1;
    beep_ms(0x64u);
  }
}
// 20003B4D: using guessed type char continuity_beeping;
// 20003B4E: using guessed type char curr_continuity_threshold;

//----- (08018A58) --------------------------------------------------------
signed int meas_calc_beep_threshold()
{
  signed int result; // r0@1

  // calculate the digits to trigger the continuity beeper
  // if currently beeping, this threshold is changed by 5 ohms so that beeping stays "latched"
  result = 3000;
  if ( continuity_beeping )
  {
    if ( curr_continuity_threshold )
    {
      if ( curr_continuity_threshold == 2 )
      {
        result = 30500;
      }
      else if ( (unsigned __int8)curr_continuity_threshold >= 2u )
      {
        if ( curr_continuity_threshold == 3 )
          result = 29500;
      }
      else
      {
        result = 2500;
      }
    }
    else
    {
      result = 3500;
    }
  }
  else if ( (unsigned __int8)curr_continuity_threshold <= 1u )
  {
    result = 3000;
  }
  else if ( (unsigned int)(unsigned __int8)curr_continuity_threshold - 2 <= 1 )
  {
    result = 30000;
  }
  return result;
}
// 20003B4D: using guessed type char continuity_beeping;
// 20003B4E: using guessed type char curr_continuity_threshold;

//----- (08018AD4) --------------------------------------------------------
void __fastcall meas_process_ohms()
{
  int avg_max_delta; // r4@6
  unsigned __int16 avg_num; // r5@6
  int v2; // r6@15
  int v3; // r6@19

  if ( hy_AD1_new_avg )
  {
    meas_calc_final_scr_digits();
    if ( curr_scr_digits < 0 )
      curr_scr_digits = 0;
    if ( (signed int)curr_meas_range >= 2 && (signed int)curr_meas_range < 4 )
    {
      if ( curr_meas_range == 2 )
      {
        avg_max_delta = 10;
        avg_num = 10;
      }
      else if ( curr_meas_range == 3 )
      {
        avg_max_delta = 20;
        avg_num = 10;
      }
      else
      {
        avg_max_delta = 10;
        avg_num = 5;
      }
    }
    else
    {
      avg_max_delta = 20;
      avg_num = 10;
    }
    curr_scr_digits = meas_add_rolling_average_buf2(curr_scr_digits, avg_max_delta, avg_num);
    if ( !meter_in_cal_mode && curr_meas_mode == MM_OHMS && curr_meas_range == 5 )
    {
      v2 = curr_scr_digits;
      curr_scr_digits = v2 - meas_ohms_calc_5M_offset(curr_scr_digits);
    }
    if ( !meter_in_cal_mode && curr_meas_mode == MM_OHMS && curr_meas_range == 6 )
    {
      v3 = curr_scr_digits;
      curr_scr_digits = v3 - meas_ohms_calc_50M_offset(curr_scr_digits, cal_ohms_50M_offset_factor);
    }
    meas_was_updated = 1;
  }
  meas_calc_bargraph_digits();
  if ( curr_bargraph_digits < 0 )
    curr_bargraph_digits = 0;
}
// 20003858: using guessed type int curr_scr_digits;
// 2000385C: using guessed type int curr_bargraph_digits;
// 200038F4: using guessed type int cal_ohms_50M_offset_factor;
// 20003B1C: using guessed type char hy_AD1_new_avg;
// 20003B24: using guessed type char meter_in_cal_mode;

//----- (08018BF8) --------------------------------------------------------
signed int __fastcall meas_ohms_calc_5M_offset(signed int a1)
{
  signed int v1; // r1@1
  signed int result; // r0@1

  v1 = a1;
  result = 0;
  if ( v1 < 50000 )
  {
    if ( v1 >= 1000 )
    {
      if ( v1 >= 2000 )
      {
        if ( v1 >= 3000 )
        {
          if ( v1 >= 4000 )
          {
            if ( v1 >= 5000 )
            {
              if ( v1 >= 6000 )
              {
                if ( v1 >= 7000 )
                {
                  if ( v1 >= 8000 )
                  {
                    if ( v1 >= 9000 )
                    {
                      if ( v1 >= 10000 )
                      {
                        if ( v1 >= 11000 )
                        {
                          if ( v1 >= 12000 )
                          {
                            if ( v1 >= 13000 )
                            {
                              if ( v1 >= 14000 )
                              {
                                if ( v1 >= 15000 )
                                {
                                  if ( v1 >= 36000 )
                                  {
                                    if ( v1 >= 37000 )
                                    {
                                      if ( v1 >= 38000 )
                                      {
                                        if ( v1 >= 39000 )
                                        {
                                          if ( v1 >= 40000 )
                                          {
                                            if ( v1 >= 41000 )
                                            {
                                              if ( v1 >= 42000 )
                                              {
                                                if ( v1 >= 43000 )
                                                {
                                                  if ( v1 >= 44000 )
                                                  {
                                                    if ( v1 >= 45000 )
                                                    {
                                                      if ( v1 >= 46000 )
                                                      {
                                                        if ( v1 >= 47000 )
                                                        {
                                                          if ( v1 >= 48000 )
                                                          {
                                                            if ( v1 >= 49000 )
                                                            {
                                                              if ( v1 < 50000 )
                                                                result = 1;
                                                            }
                                                            else
                                                            {
                                                              result = 2;
                                                            }
                                                          }
                                                          else
                                                          {
                                                            result = 3;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          result = 4;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        result = 5;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      result = 6;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    result = 7;
                                                  }
                                                }
                                                else
                                                {
                                                  result = 8;
                                                }
                                              }
                                              else
                                              {
                                                result = 9;
                                              }
                                            }
                                            else
                                            {
                                              result = 10;
                                            }
                                          }
                                          else
                                          {
                                            result = 11;
                                          }
                                        }
                                        else
                                        {
                                          result = 12;
                                        }
                                      }
                                      else
                                      {
                                        result = 13;
                                      }
                                    }
                                    else
                                    {
                                      result = 14;
                                    }
                                  }
                                  else
                                  {
                                    result = 15;
                                  }
                                }
                                else
                                {
                                  result = 14;
                                }
                              }
                              else
                              {
                                result = 13;
                              }
                            }
                            else
                            {
                              result = 12;
                            }
                          }
                          else
                          {
                            result = 11;
                          }
                        }
                        else
                        {
                          result = 10;
                        }
                      }
                      else
                      {
                        result = 9;
                      }
                    }
                    else
                    {
                      result = 8;
                    }
                  }
                  else
                  {
                    result = 7;
                  }
                }
                else
                {
                  result = 6;
                }
              }
              else
              {
                result = 5;
              }
            }
            else
            {
              result = 4;
            }
          }
          else
          {
            result = 3;
          }
        }
        else
        {
          result = 2;
        }
      }
      else
      {
        result = 1;
      }
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    result = 0;
  }
  return result;
}

//----- (08018DA6) --------------------------------------------------------
int __fastcall meas_ohms_calc_50M_offset(int digits, int factor)
{
  unsigned __int8 v2; // r7@0
  unsigned __int8 i; // r6@3
  float digits_of_range; // r8@8
  float digits_in_range; // r0@8
  float digits_in_cal_range; // r8@8
  float cal_range_start; // r0@8
  float correction_factor; // r0@8
  float v10; // r0@8
  float v11; // r0@8

  // calculate an offset for the 50M ohm range

  // takes the current value and splits into hi = x/5000 and lo=x%5000
  // multiplies lo by a factor selected by hi and adds another factor
  // then multiplies that by an application factor and returns the offset.
  meas_ohms_50M_offset_val = 0;
  if ( digits < 56000 )
  {
    for ( i = 0; (signed int)i < 13; ++i )
    {
      if ( 1000 * cal_ohms_50M_factor_tbl[i] >= digits )
      {
        v2 = i;
        break;
      }
    }
    C50MO_range_start = cal_ohms_50M_factor_tbl[v2 - 1];
    C50MO_range_stop = cal_ohms_50M_factor_tbl[v2];
    digits_of_range = fp_from_int(digits - 1000 * C50MO_range_start);
    digits_in_range = fp_from_int(1000 * (C50MO_range_stop - C50MO_range_start));
    C50MO_frac_into_range = fp_div(digits_of_range, digits_in_range);
    C50MO_digits_in_cal_range = fp_from_int(cal_ohms_50M_factor_tbl[v2 + 13] - cal_ohms_50M_factor_tbl[v2 + 12]);
    digits_in_cal_range = fp_mul(C50MO_frac_into_range, C50MO_digits_in_cal_range);
    cal_range_start = fp_from_int(cal_ohms_50M_factor_tbl[v2 + 12]);
    C50MO_digits_in_cal_range = fp_add(cal_range_start, digits_in_cal_range);
    correction_factor = fp_from_int(factor);
    v10 = fp_mul(correction_factor, C50MO_digits_in_cal_range);
    v11 = fp_div(v10, 100.0);
    meas_ohms_50M_offset_val = fp_to_int(v11);
  }
  else
  {
    meas_ohms_50M_offset_val = 0;
  }
  return meas_ohms_50M_offset_val;
}
// 8022114: using guessed type int cal_ohms_50M_factor_tbl[26];
// 200037C0: using guessed type int meas_ohms_50M_offset_val;
// 200037CC: using guessed type int C50MO_range_start;
// 200037D0: using guessed type int C50MO_range_stop;

//----- (08018EEC) --------------------------------------------------------
void __fastcall meas_process_diode()
{
  if ( hy_AD1_new_avg )
  {
    meas_calc_final_scr_digits();
    if ( high_voltage_diode )
      curr_scr_digits /= 10;
    curr_scr_digits = meas_add_rolling_average_buf2(curr_scr_digits, 2, 2u);
    if ( curr_scr_digits >= 1000 || curr_scr_digits < -999 )
    {
      if ( (meas_diode_last_digits + 1000 < curr_scr_digits || curr_scr_digits < meas_diode_last_digits - 1000)
        && !meas_diode_reprocess_timer_1s )
      {
        meas_diode_last_digits = curr_scr_digits;
        meas_diode_reprocess_timer_1s = 100;
        beep_angrily();
      }
    }
    else
    {
      beep_ms(0x1F4u);
      meas_diode_last_digits = curr_scr_digits;
    }
    meas_was_updated = 1;
  }
  meas_calc_bargraph_digits();
  if ( high_voltage_diode )
    curr_bargraph_digits /= 10;
}
// 200037D4: using guessed type int meas_diode_last_digits;
// 20003858: using guessed type int curr_scr_digits;
// 2000385C: using guessed type int curr_bargraph_digits;
// 20003B1C: using guessed type char hy_AD1_new_avg;
// 20003B4B: using guessed type char high_voltage_diode;
// 20003B4C: using guessed type char meas_diode_reprocess_timer_1s;

//----- (08019000) --------------------------------------------------------
void __fastcall meas_process_dc_amps()
{
  if ( (unsigned __int8)meter_in_cal_mode | (unsigned __int8)(burden_enabled_for_current_ranges ^ 1) )
  {
    meas_process_dc_amps_core();
  }
  else
  {
    if ( measuring_amps_of_va_or_volts_of_burden )
    {
      meas_process_dcv();
      if ( hy_AD1_new_avg )
        burden_last_volts = curr_scr_digits;
    }
    else
    {
      meas_process_dc_amps_core();
    }
    if ( meas_was_updated )
    {
      ++meas_amp_burden_timer;
      if ( (unsigned __int8)meas_amp_burden_timer > 3u )
      {
        if ( measuring_amps_of_va_or_volts_of_burden )
        {
          burden_last_volts = meas_process_burden_volts(burden_last_volts);
          burden_overflow = 0;
          if ( burden_last_volts >= 5001 )
            burden_overflow = 1;
          need_to_update_bargraph = 0;
          meas_was_updated = 0;
          if ( curr_sub_mode == SM_SPL2 )
            need_to_update_subscr = 1;
        }
        meas_amp_burden_timer = 0;
        measuring_amps_of_va_or_volts_of_burden ^= 1u;
        prepare_reading_dc_amps(measuring_amps_of_va_or_volts_of_burden != 0);
      }
      else
      {
        need_to_update_bargraph = 0;
        meas_was_updated = 0;
      }
    }
  }
}
// 20003858: using guessed type int curr_scr_digits;
// 2000394C: using guessed type int burden_last_volts;
// 20003AFA: using guessed type char need_to_update_bargraph;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B1C: using guessed type char hy_AD1_new_avg;
// 20003B23: using guessed type char cal_mode_load_from_sd;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B3D: using guessed type char burden_enabled_for_current_ranges;
// 20003B3F: using guessed type char burden_overflow;
// 20003B59: using guessed type char measuring_amps_of_va_or_volts_of_burden;
// 20003B5A: using guessed type char meas_amp_burden_timer;

//----- (0801910C) --------------------------------------------------------
void __fastcall prepare_reading_dc_amps(char measuring_burden_voltage)
{
  if ( measuring_burden_voltage )
  {
    config_hy_based_on_mode_range(MM_DCV, 0);
    cal_load_factors_for_mode_and_range(MM_DCV, 0);
    meas_setup_hw(MM_DCV, 0);
  }
  else
  {
    config_hy_based_on_mode_range(curr_meas_mode, curr_meas_range);
    cal_load_factors_for_mode_and_range(curr_meas_mode, curr_meas_range);
    meas_setup_hw(curr_meas_mode, curr_meas_range);
  }
  meter_set_mode_range_change_delay();
}

//----- (0801916A) --------------------------------------------------------
void __fastcall meas_process_dc_amps_core()
{
  if ( hy_AD1_new_avg )
  {
    meas_calc_final_scr_digits();
    curr_scr_digits = meas_add_rolling_average_buf2(curr_scr_digits, 10, 10u);
    if ( !curr_meas_range )
      curr_scr_digits -= curr_amp_rel;
    meas_was_updated = 1;
  }
  meas_calc_bargraph_digits();
  if ( (curr_meas_mode == MM_ACuA
     || curr_meas_mode == MM_ACmA
     || curr_meas_mode == MM_ACA
     || curr_meas_mode == MM_DCuA
     || curr_meas_mode == MM_DCmA
     || curr_meas_mode == MM_DCA)
    && curr_sub_mode == SM_SPL1 )
    need_to_update_subscr = 1;
}
// 20003858: using guessed type int curr_scr_digits;
// 200038EC: using guessed type int curr_amp_rel;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B1C: using guessed type char hy_AD1_new_avg;

//----- (08019204) --------------------------------------------------------
void __cdecl hy_process_RMS_int()
{
  hy_rms_data = hy_read_rms_data_from_buf();
  hy_curr_rms_data = hy_rms_data;
  hy_rms_new_avg = hy_update_rms_avg(hy_rms_data) != 0;
  if ( curr_meas_mode )
  {
    switch ( curr_meas_mode )
    {
      case MM_ACV:
        nullsub_1();
        break;
      case MM_ACmV:
        nullsub_2();
        break;
      case MM_ACuA:
      case MM_ACmA:
      case MM_ACA:
        nullsub_3();
        break;
    }
  }
  else
  {
    rms_int_in_lowz_does_nothing();
  }
}
// 8019FC4: using guessed type int nullsub_2(void);
// 8019FC6: using guessed type int nullsub_3(void);
// 20003864: using guessed type int hy_curr_rms_data;
// 200038C0: using guessed type int hy_rms_data;
// 20003B1D: using guessed type char hy_rms_new_avg;

//----- (08019268) --------------------------------------------------------
int hy_read_rms_data_from_buf()
{
  double v0; // r0@1
  double v1; // r0@1

  hy_RMS_DATA_msb = hy_regs_buf[10] + (hy_regs_buf[12] << 16) + (hy_regs_buf[13] << 24) + (hy_regs_buf[11] << 8);
  hy_RMS_DATA_lsb = hy_regs_buf[9];
  v0 = dp_from_uint(hy_RMS_DATA_msb);
  v1 = dp_sqrt(v0);
  return 8 * dp_to_int(v1);
}
// 200038B8: using guessed type int hy_RMS_DATA_lsb;
// 200038BC: using guessed type int hy_RMS_DATA_msb;

//----- (080192C4) --------------------------------------------------------
int __fastcall hy_update_rms_avg(int result)
{
  int v1; // r1@1

  v1 = result;
  LOBYTE(result) = 0;
  if ( hy_rms_avg_count )
    hy_rms_avg_accu += v1;
  else
    hy_rms_avg_accu = v1;
  ++hy_rms_avg_count;
  if ( (signed int)(unsigned __int8)hy_rms_avg_count >= 4 )
  {
    hy_rms_avg_val = hy_rms_avg_accu / (unsigned int)(unsigned __int8)hy_rms_avg_count;
    hy_rms_avg_count = 0;
    hy_rms_avg_accu = 0;
    LOBYTE(result) = 1;
  }
  return (unsigned __int8)result;
}
// 200038C4: using guessed type int hy_rms_avg_accu;
// 200038C8: using guessed type int hy_rms_avg_val;
// 20003B1E: using guessed type char hy_rms_avg_count;

//----- (08019340) --------------------------------------------------------
int __fastcall meas_add_rolling_average_buf1(int num, int max_delta, unsigned __int16 averages)
{
  __int64 v3; // r6@1
  signed int i; // r9@9
  signed int j; // r9@12

  // this function adds a number to a rolling average buffer
  // averages: number of numbers to average over
  // max_delta: if the new number is more than this far away from the last number, the average is reset
  // returns the current average

  // it has an identical counterpart with another buffer, meas_add_rolling_average_buf2
  v3 = 0LL;
  if ( max_delta < num - meas_ara1_last
    || (num - meas_ara1_last + max_delta < 0) ^ __OFADD__(num - meas_ara1_last, max_delta) )
    meas_ara1_count = 0;
  if ( meas_ara1_count )
  {
    ++meas_ara1_count;
    if ( averages < (unsigned int)(unsigned __int8)meas_ara1_count )
      meas_ara1_count = averages;
    for ( i = 1; i < (unsigned __int8)meas_ara1_count; ++i )
      meas_ara1_buf[(unsigned __int8)meas_ara1_count - i] = meas_ara1_buf[(unsigned __int8)meas_ara1_count - 1 - i];
    meas_ara1_buf[0] = num;
    for ( j = 0; j < (unsigned __int8)meas_ara1_count; ++j )
      v3 += meas_ara1_buf[j];
    num = int64_div(v3, (unsigned __int8)meas_ara1_count);
    meas_ara1_last = num;
  }
  else
  {
    meas_ara1_buf[(unsigned __int8)meas_ara1_count++] = num;
    meas_ara1_last = num;
  }
  return num;
}
// 200037D8: using guessed type int meas_ara1_last;
// 20003B1F: using guessed type char meas_ara1_count;

//----- (08019456) --------------------------------------------------------
void __fastcall meas_calc_bargraph_digits_ac(int digits)
{
  curr_bargraph_digits = meas_perform_offset_adj_ac(digits);
  curr_bargraph_digits = meas_perform_gain_adj(curr_bargraph_digits);
  need_to_update_bargraph = 1;
}
// 2000385C: using guessed type int curr_bargraph_digits;
// 20003AFA: using guessed type char need_to_update_bargraph;

//----- (08019490) --------------------------------------------------------
void __fastcall meas_process_dc_va()
{
  char v0; // r4@12
  __int64 v1; // r0@26
  __int64 v2; // r0@26

  meas_va_never_processed = 0;
  if ( measuring_amps_of_va_or_volts_of_burden )
  {
    if ( measuring_amps_of_va_or_volts_of_burden == 1 )
    {
      meas_process_dc_amps_core();
      if ( hy_AD1_new_avg )
        meas_va_last_amps = curr_scr_digits;
    }
  }
  else
  {
    meas_process_dcv();
    if ( hy_AD1_new_avg )
      meas_va_last_volts = curr_scr_digits;
  }
  if ( meas_was_updated )
  {
    if ( measuring_amps_of_va_or_volts_of_burden )
      v0 = 6;
    else
      v0 = 3;
    ++meas_amp_burden_timer;
    if ( (unsigned __int8)v0 < (unsigned int)(unsigned __int8)meas_amp_burden_timer )
    {
      meas_amp_burden_timer = 0;
      if ( meter_in_cal_mode
        && measuring_amps_of_va_or_volts_of_burden
        && (unsigned __int8)calibrating_offset | (unsigned __int8)calibrating_gain )
      {
        if ( (signed int)(unsigned __int8)cal_countdown_timer-- < 3 )
        {
          cal_dcva_volts_accu += meas_va_last_volts;
          cal_dcva_amps_accu += meas_va_last_amps;
        }
        else
        {
          cal_dcva_volts_accu = meas_va_last_volts;
          cal_dcva_amps_accu = meas_va_last_amps;
        }
        if ( !cal_countdown_timer )
        {
          if ( calibrating_offset )
          {
            calibrating_offset = 0;
            calibrating_offset_finished = 1;
            cal_curr_offset_va_volts = int64_div(cal_dcva_volts_accu, 3LL);
            cal_curr_offset_va_amps = int64_div(cal_dcva_amps_accu, 3LL);
            cal_write_factor(0, 0);
          }
          else if ( calibrating_gain )
          {
            calibrating_gain = 0;
            calibrating_gain_finished = 1;
            v1 = int64_div(cal_dcva_volts_accu, 3LL);
            cal_curr_gain_accu_float = fp_from_int64(v1);
            cal_calc_gain_from_gain_accu();
            cal_curr_gain_va_volts = cal_curr_gain_val;
            v2 = int64_div(cal_dcva_amps_accu, 3LL);
            cal_curr_gain_accu_float = fp_from_int64(v2);
            cal_calc_gain_from_gain_accu();
            cal_curr_gain_va_amps = cal_curr_gain_val;
            cal_write_factor(1, 0);
          }
        }
      }
      if ( measuring_amps_of_va_or_volts_of_burden )
        update_power_amps(meas_va_last_amps);
      else
        update_power_volts(meas_va_last_volts);
      if ( curr_power_volts_overflow || curr_power_amps_overflow )
        curr_scr_overflow = 1;
      if ( !meas_va_never_processed )
      {
        measuring_amps_of_va_or_volts_of_burden ^= 1u;
        meas_prepare_for_new_mode_range(0);
        calc_va_subscr_digits(meas_va_last_volts, meas_va_last_amps);
      }
      meas_was_updated = 1;
      scr_need_to_refresh_meas_units_and_icons = 0;
      need_to_update_subscr = 0;
      need_to_update_bargraph = 1;
      if ( curr_meas_mode == MM_ACVA && curr_power_amps_range )
        curr_bargraph_digits = curr_scr_digits;
      else
        curr_bargraph_digits = curr_scr_digits;
    }
    else
    {
      meas_was_updated = 0;
      need_to_update_bargraph = 0;
    }
  }
  else
  {
    need_to_update_bargraph = 0;
  }
}
// 20003780: using guessed type __int64 cal_dcva_amps_accu;
// 20003858: using guessed type int curr_scr_digits;
// 2000385C: using guessed type int curr_bargraph_digits;
// 20003868: using guessed type int meas_va_last_volts;
// 2000386C: using guessed type int meas_va_last_amps;
// 20003904: using guessed type int cal_curr_offset_va_volts;
// 20003908: using guessed type int cal_curr_offset_va_amps;
// 20003AFA: using guessed type char need_to_update_bargraph;
// 20003AFC: using guessed type char scr_need_to_refresh_meas_units_and_icons;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B1C: using guessed type char hy_AD1_new_avg;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B25: using guessed type char setting_last_cal_year_month;
// 20003B26: using guessed type char calibrating_offset;
// 20003B27: using guessed type char calibrating_offset_finished;
// 20003B28: using guessed type char calibrating_gain;
// 20003B29: using guessed type char calibrating_gain_finished;
// 20003B2F: using guessed type char cal_countdown_timer;
// 20003B58: using guessed type char meas_va_never_processed;
// 20003B59: using guessed type char measuring_amps_of_va_or_volts_of_burden;
// 20003B5A: using guessed type char meas_amp_burden_timer;
// 20003B5C: using guessed type char curr_power_amps_range;
// 20003B5D: using guessed type char curr_power_volts_overflow;
// 20003B5E: using guessed type char curr_power_amps_overflow;

//----- (0801978C) --------------------------------------------------------
void __fastcall meas_process_ac_va()
{
  char v0; // r4@12
  __int64 v1; // r0@26
  __int64 v2; // r0@26

  meas_va_never_processed = 0;
  if ( measuring_amps_of_va_or_volts_of_burden )
  {
    if ( measuring_amps_of_va_or_volts_of_burden == 1 )
    {
      meas_process_ac_amps_core();
      if ( hy_AD1_new_avg )
        meas_va_last_amps = curr_scr_digits;
    }
  }
  else
  {
    meas_process_acv();
    if ( hy_AD1_new_avg )
      meas_va_last_volts = curr_scr_digits;
  }
  if ( meas_was_updated )
  {
    if ( measuring_amps_of_va_or_volts_of_burden )
      v0 = 6;
    else
      v0 = 3;
    ++meas_amp_burden_timer;
    if ( (unsigned __int8)v0 < (unsigned int)(unsigned __int8)meas_amp_burden_timer )
    {
      meas_amp_burden_timer = 0;
      if ( meter_in_cal_mode
        && measuring_amps_of_va_or_volts_of_burden
        && (unsigned __int8)calibrating_offset | (unsigned __int8)calibrating_gain )
      {
        if ( (signed int)(unsigned __int8)cal_countdown_timer-- < 3 )
        {
          cal_acva_volts_accu += meas_va_last_volts;
          cal_acva_amps_accu += meas_va_last_amps;
        }
        else
        {
          cal_acva_volts_accu = meas_va_last_volts;
          cal_acva_amps_accu = meas_va_last_amps;
        }
        if ( !cal_countdown_timer )
        {
          if ( calibrating_offset )
          {
            calibrating_offset = 0;
            calibrating_offset_finished = 1;
            cal_curr_offset_va_volts = int64_div(cal_acva_volts_accu, 3LL);
            cal_curr_offset_va_amps = int64_div(cal_acva_amps_accu, 3LL);
            cal_write_factor(0, 0);
          }
          else if ( calibrating_gain )
          {
            calibrating_gain = 0;
            calibrating_gain_finished = 1;
            v1 = int64_div(cal_acva_volts_accu, 3LL);
            cal_curr_gain_accu_float = fp_from_int64(v1);
            cal_calc_gain_from_gain_accu();
            cal_curr_gain_va_volts = cal_curr_gain_val;
            v2 = int64_div(cal_acva_amps_accu, 3LL);
            cal_curr_gain_accu_float = fp_from_int64(v2);
            cal_calc_gain_from_gain_accu();
            cal_curr_gain_va_amps = cal_curr_gain_val;
            cal_write_factor(1, 0);
          }
        }
      }
      if ( measuring_amps_of_va_or_volts_of_burden )
        update_power_amps(meas_va_last_amps);
      else
        update_power_volts(meas_va_last_volts);
      if ( curr_power_volts_overflow || curr_power_amps_overflow )
        curr_scr_overflow = 1;
      if ( !meas_va_never_processed )
      {
        measuring_amps_of_va_or_volts_of_burden ^= 1u;
        meas_prepare_for_new_mode_range(0);
        calc_va_subscr_digits(meas_va_last_volts, meas_va_last_amps);
      }
      meas_was_updated = 1;
      scr_need_to_refresh_meas_units_and_icons = 0;
      need_to_update_subscr = 0;
      need_to_update_bargraph = 1;
      if ( curr_meas_mode == MM_ACVA && curr_power_amps_range )
        curr_bargraph_digits = curr_scr_digits;
      else
        curr_bargraph_digits = curr_scr_digits;
    }
    else
    {
      meas_was_updated = 0;
      need_to_update_bargraph = 0;
    }
  }
  else
  {
    need_to_update_bargraph = 0;
  }
}
// 20003790: using guessed type __int64 cal_acva_amps_accu;
// 20003858: using guessed type int curr_scr_digits;
// 2000385C: using guessed type int curr_bargraph_digits;
// 20003868: using guessed type int meas_va_last_volts;
// 2000386C: using guessed type int meas_va_last_amps;
// 20003904: using guessed type int cal_curr_offset_va_volts;
// 20003908: using guessed type int cal_curr_offset_va_amps;
// 20003AFA: using guessed type char need_to_update_bargraph;
// 20003AFC: using guessed type char scr_need_to_refresh_meas_units_and_icons;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B1C: using guessed type char hy_AD1_new_avg;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B25: using guessed type char setting_last_cal_year_month;
// 20003B26: using guessed type char calibrating_offset;
// 20003B27: using guessed type char calibrating_offset_finished;
// 20003B28: using guessed type char calibrating_gain;
// 20003B29: using guessed type char calibrating_gain_finished;
// 20003B2F: using guessed type char cal_countdown_timer;
// 20003B58: using guessed type char meas_va_never_processed;
// 20003B59: using guessed type char measuring_amps_of_va_or_volts_of_burden;
// 20003B5A: using guessed type char meas_amp_burden_timer;
// 20003B5C: using guessed type char curr_power_amps_range;
// 20003B5D: using guessed type char curr_power_volts_overflow;
// 20003B5E: using guessed type char curr_power_amps_overflow;

//----- (08019A64) --------------------------------------------------------
void __fastcall update_power_volts(signed int a1)
{
  signed int v1; // r4@1

  v1 = a1;
  curr_power_volts_overflow = 0;
  if ( a1 < 55001 )
  {
    if ( a1 < 3200
      && !((unsigned __int8)meter_in_cal_mode | (unsigned __int8)autoranging_disabled)
      && !meter_min_max_mode
      && curr_power_volts_range )
    {
      curr_power_volts_range = 0;
      curr_meas_range = get_meas_range_from_power_ranges();
      update_stuff_based_on_new_power_range();
    }
  }
  else
  {
    curr_power_volts_overflow = 1;
    if ( !((unsigned __int8)meter_in_cal_mode | (unsigned __int8)autoranging_disabled)
      && !meter_min_max_mode
      && !curr_power_volts_range )
    {
      curr_power_volts_range = 1;
      curr_meas_range = get_meas_range_from_power_ranges();
      update_stuff_based_on_new_power_range();
    }
  }
  meter_power_volts = v1;
  if ( curr_sub_mode == SM_SPL1 )
    need_to_update_subscr = 1;
}
// 2000398C: using guessed type int meter_power_volts;
// 20003AE6: using guessed type char autoranging_disabled;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B23: using guessed type char cal_mode_load_from_sd;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B5B: using guessed type char curr_power_volts_range;
// 20003B5D: using guessed type char curr_power_volts_overflow;

//----- (08019B2C) --------------------------------------------------------
void __fastcall update_power_amps(signed int a1)
{
  signed int v1; // r4@1
  signed int v2; // r5@4
  signed int v3; // r6@4

  v1 = a1;
  if ( (curr_meas_mode == MM_ACVA || curr_meas_mode == MM_DCVA) && curr_power_amps_range )
  {
    v2 = 11000;
    v3 = 400;
  }
  else
  {
    v2 = 55000;
    v3 = 4000;
  }
  curr_power_amps_overflow = 0;
  if ( v2 >= a1 )
  {
    if ( a1 < v3
      && !((unsigned __int8)meter_in_cal_mode | (unsigned __int8)autoranging_disabled)
      && !meter_min_max_mode
      && curr_power_amps_range )
    {
      curr_power_amps_range = 0;
      curr_meas_range = get_meas_range_from_power_ranges();
      update_stuff_based_on_new_power_range();
    }
  }
  else
  {
    curr_power_amps_overflow = 1;
    if ( !((unsigned __int8)meter_in_cal_mode | (unsigned __int8)autoranging_disabled)
      && !meter_min_max_mode
      && !curr_power_amps_range )
    {
      curr_power_amps_range = 1;
      curr_meas_range = get_meas_range_from_power_ranges();
      update_stuff_based_on_new_power_range();
    }
  }
  if ( curr_meas_mode != MM_ACuVA && curr_meas_mode != MM_DCuVA )
  {
    meter_power_amps = v1;
  }
  else
  {
    if ( curr_power_amps_range )
    {
      if ( curr_power_amps_range == 1 )
        meter_power_amps = v1 / 10;
    }
    else
    {
      meter_power_amps = v1 / 100;
    }
    meter_power_amps_uVA_precise = v1;
  }
  if ( curr_sub_mode == SM_SPL2 )
    need_to_update_subscr = 1;
}
// 20003990: using guessed type int meter_power_amps;
// 20003994: using guessed type int meter_power_amps_uVA_precise;
// 20003AE6: using guessed type char autoranging_disabled;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B23: using guessed type char cal_mode_load_from_sd;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B5C: using guessed type char curr_power_amps_range;
// 20003B5E: using guessed type char curr_power_amps_overflow;

//----- (08019C5C) --------------------------------------------------------
int __fastcall calc_va_subscr_digits(signed int a1, signed int a2)
{
  signed int v2; // r9@1
  __int64 v3; // r10@1
  __int64 v4; // r6@3
  __int64 v5; // r0@10
  int result; // r0@10

  v2 = a1 >> 31;
  LODWORD(v3) = a2;
  if ( curr_meas_mode != MM_ACmVA && curr_meas_mode != MM_DCmVA )
  {
    if ( curr_meas_mode != MM_ACuVA && curr_meas_mode != MM_DCuVA )
    {
      if ( (signed int)curr_meas_range < 2 )
        v4 = 100000LL;
      else
        v4 = 10000LL;
    }
    else
    {
      v4 = 100000LL;
    }
  }
  else
  {
    v4 = 100000LL;
  }
  HIDWORD(v3) = a2 >> 31;
  v5 = (unsigned int)a1 * v3;
  HIDWORD(v5) += v2 * v3;
  result = int64_div(v5, v4);
  curr_scr_digits = result;
  return result;
}
// 20003858: using guessed type int curr_scr_digits;

//----- (08019D00) --------------------------------------------------------
void __cdecl rms_int_in_lowz_does_nothing()
{
  nullsub_1();
}

//----- (08019D0A) --------------------------------------------------------
void __fastcall meas_acv_dcv_calc_next_mode(char dc)
{
  if ( dc )
  {
    ++meas_acv_dcv_mode_switch_timer;
    if ( (signed int)meas_acv_dcv_mode_switch_timer >= 3 )
      meas_acv_dcv_switch_mode(0);
  }
  else
  {
    ++meas_acv_dcv_mode_switch_timer;
    if ( (signed int)meas_acv_dcv_mode_switch_timer >= 20 )
      meas_acv_dcv_switch_mode(1);
  }
}

//----- (08019D5C) --------------------------------------------------------
void __fastcall meas_acv_dcv_switch_mode(char to_dc)
{
  meas_acv_dcv_mode_switch_timer = 0;
  acv_dcv_measuring_dc = to_dc;
  if ( to_dc == 1 )
  {
    meas_acv_dcv_dc_value = curr_scr_digits;
    meas_acv_dcv_dc_value_updated = 1;
  }
  else
  {
    meas_acv_dcv_ac_value = curr_scr_digits;
    meas_acv_dcv_ac_value_updated = 1;
  }
  if ( to_dc == 1 && meas_acv_dcv_ac_value_updated || !to_dc && meas_acv_dcv_dc_value_updated )
  {
    meas_acv_dcv_calc_distance_between_ac_and_dc_as_if_they_were_vectors_90_degrees_apart();
    curr_scr_digits = meas_add_rolling_average_buf2(curr_scr_digits, 20, 10u);
    meas_was_updated = 1;
    need_to_update_bargraph = 1;
    curr_bargraph_digits = curr_scr_digits;
  }
  config_hy_based_on_mode_range(curr_meas_mode, curr_meas_range);
  cal_load_factors_for_mode_and_range(curr_meas_mode, curr_meas_range);
}
// 20003858: using guessed type int curr_scr_digits;
// 2000385C: using guessed type int curr_bargraph_digits;
// 2000397C: using guessed type int meas_acv_dcv_dc_value;
// 20003980: using guessed type int meas_acv_dcv_ac_value;
// 20003AFA: using guessed type char need_to_update_bargraph;
// 20003B53: using guessed type char meas_acv_dcv_ac_value_updated;
// 20003B54: using guessed type char meas_acv_dcv_dc_value_updated;
// 20003B55: using guessed type char acv_dcv_measuring_dc;

//----- (08019E20) --------------------------------------------------------
void __fastcall meas_acv_dcv_calc_distance_between_ac_and_dc_as_if_they_were_vectors_90_degrees_apart()
{
  double v0; // r0@8
  double v1; // r0@8

  if ( meas_acv_dcv_dc_value < 0 )
    meas_acv_dcv_dc_value = -meas_acv_dcv_dc_value;
  if ( meas_acv_dcv_ac_value < 0 )
    meas_acv_dcv_ac_value = -meas_acv_dcv_ac_value;
  if ( meas_acv_dcv_dc_value < 60001 && meas_acv_dcv_ac_value < 60001 )
  {
    meas_acv_dcv_dc_value_squared = meas_acv_dcv_dc_value * meas_acv_dcv_dc_value;
    meas_acv_dcv_ac_value_squared = meas_acv_dcv_ac_value * meas_acv_dcv_ac_value;
    v0 = dp_from_uint(meas_acv_dcv_ac_value * meas_acv_dcv_ac_value + meas_acv_dcv_dc_value * meas_acv_dcv_dc_value);
    v1 = dp_sqrt(v0);
    curr_scr_digits = dp_to_int(v1);
  }
  else
  {
    curr_scr_digits = 100000;
  }
}
// 20003858: using guessed type int curr_scr_digits;
// 2000397C: using guessed type int meas_acv_dcv_dc_value;
// 20003980: using guessed type int meas_acv_dcv_ac_value;
// 20003984: using guessed type int meas_acv_dcv_dc_value_squared;
// 20003988: using guessed type int meas_acv_dcv_ac_value_squared;

//----- (08019EC4) --------------------------------------------------------
void __fastcall meas_calc_dBm()
{
  float v0; // r4@0
  float v1; // r0@7
  float v2; // r0@4
  float v3; // r0@8
  float v4; // r0@9
  float v5; // r0@10
  double v6; // r0@10
  double v7; // r0@10
  float v8; // r0@10
  double v9; // r0@10
  double v10; // r0@10
  double v11; // r0@10

  if ( curr_meas_range )
  {
    if ( curr_meas_range == 2 )
    {
      v3 = fp_from_int(curr_scr_digits);
      v0 = fp_div(v3, 100.0);
    }
    else if ( curr_meas_range >= 2u )
    {
      if ( curr_meas_range == 3 )
      {
        v4 = fp_from_int(curr_scr_digits);
        v0 = fp_div(v4, 10.0);
      }
    }
    else
    {
      v2 = fp_from_int(curr_scr_digits);
      v0 = fp_div(v2, 1000.0);
    }
  }
  else
  {
    v1 = fp_from_int(curr_scr_digits);
    v0 = fp_div(v1, 10000.0);
  }
  v5 = fp_mul(v0, v0);
  v6 = dp_from_fp(v5);
  v7 = dp_div(v6, 0.6);
  v8 = fp_from_dp(v7);
  v9 = dp_from_fp(v8);
  v10 = dp_log10(v9);
  v11 = dp_mul(v10, 10.0);
  curr_subscr_dBm = fp_from_dp(v11);
}
// 20003858: using guessed type int curr_scr_digits;

//----- (08019FC8) --------------------------------------------------------
void hy_process_peak_hold(void)
{
  char a1; // [sp+0h] [bp-8h]@5

  if ( curr_meas_mode != MM_ACuVA && curr_meas_mode != MM_ACmVA && curr_meas_mode != MM_ACVA )
  {
    hy_PKHMAX = hy_regs_buf[17] + (hy_regs_buf[18] << 8) + (hy_regs_buf[19] << 16);
    hy_PKHMIN = hy_regs_buf[14] + (hy_regs_buf[15] << 8) + (hy_regs_buf[16] << 16);
    // turn peak hold enable off and back on again
    a1 = curr_hy_R29 & 0xFB;
    send_data_to_hy3131(&a1, 0x29, 1u);
    spinloop(10u);
    a1 = curr_hy_R29;
    send_data_to_hy3131(&a1, 0x29, 1u);
    if ( (curr_meas_mode == MM_ACV || curr_meas_mode == MM_ACmV) && input_1ms_peak_enabled == 1 )
    {
      if ( peakdet_show_min_always_zero )
      {
        curr_scr_digits = ~hy_PKHMIN & 0x3FFFF;
        if ( !meter_mode_range_change_delay )
        {
          if ( peakhold_min_value >= (unsigned int)curr_scr_digits )
          {
            curr_scr_digits = peakhold_min_value;
          }
          else
          {
            peakhold_min_value = curr_scr_digits;
            hy_last_PKHMIN = hy_PKHMIN;
          }
        }
        meter_overflow_was_negative = 1;
      }
      else if ( (unsigned int)hy_PKHMAX < 0x40000 )
      {
        curr_scr_digits = hy_PKHMAX;
        if ( calibrating_offset )
        {
          cal_ac_offset_temp_result = cal_update_ac_offset_accu(curr_scr_digits);
        }
        else if ( calibrating_gain )
        {
          cal_update_ac_gain_accu(curr_scr_digits, cal_ac_offset_temp_result);
        }
        else
        {
          if ( !meter_mode_range_change_delay )
          {
            curr_scr_digits = meas_perform_offset_adj_ac(curr_scr_digits);
            if ( curr_scr_digits < 0 )
              curr_scr_digits = 0;
            curr_scr_digits = meas_perform_gain_adj(curr_scr_digits);
            if ( !meter_in_cal_mode )
            {
              if ( peakhold_max_value >= (unsigned int)curr_scr_digits )
                curr_scr_digits = peakhold_max_value;
              else
                peakhold_max_value = curr_scr_digits;
            }
          }
          meter_overflow_was_negative = 0;
        }
        meas_was_updated = 1;
        need_to_update_bargraph = 1;
        curr_bargraph_digits = curr_scr_digits;
      }
    }
  }
}
// 20000223: using guessed type char meter_mode_range_change_delay;
// 20003858: using guessed type int curr_scr_digits;
// 2000385C: using guessed type int curr_bargraph_digits;
// 200038CC: using guessed type int hy_PKHMIN;
// 200038D0: using guessed type int hy_PKHMAX;
// 200038D4: using guessed type int hy_last_PKHMIN;
// 200038E8: using guessed type int cal_ac_offset_temp_result;
// 2000396C: using guessed type int peakhold_max_value;
// 20003970: using guessed type int peakhold_min_value;
// 20003AE7: using guessed type char meter_overflow_was_negative;
// 20003AFA: using guessed type char need_to_update_bargraph;
// 20003B19: using guessed type char curr_hy_R29;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B26: using guessed type char calibrating_offset;
// 20003B28: using guessed type char calibrating_gain;
// 20003B4F: using guessed type char input_1ms_peak_enabled;
// 20003B50: using guessed type char peakdet_show_min_always_zero;

//----- (0801A1D8) --------------------------------------------------------
void __cdecl hy_process_CT_int()
{
  if ( curr_meas_mode == MM_ACuVA || curr_meas_mode == MM_ACmVA || curr_meas_mode == MM_ACVA )
    return;
  hy_read_freq_counters_and_reset();
  hy_change_CTA_val_timer = 0;
  if ( curr_meas_mode && curr_meas_mode != MM_ACV && curr_meas_mode != MM_ACmV )
  {
    if ( curr_meas_mode == MM_HZ )
    {
      meas_process_hz(0, curr_meas_range);
      goto LABEL_21;
    }
    if ( curr_meas_mode == MM_mSEC )
    {
      meas_process_msec();
      goto LABEL_21;
    }
    if ( curr_meas_mode == MM_DUTY )
    {
      meas_process_duty();
      goto LABEL_21;
    }
    if ( curr_meas_mode == MM_CAP )
    {
      meas_process_cap();
      goto LABEL_21;
    }
    if ( curr_meas_mode != MM_ACuA && curr_meas_mode != MM_ACmA && curr_meas_mode != MM_ACA )
      goto LABEL_21;
  }
  meas_process_hz(1, ac_input_freq_range);
LABEL_21:
  freq_input_timeout_timer_10ms_unit = 0;
  if ( curr_meas_mode == MM_HZ || curr_meas_mode == MM_mSEC || curr_meas_mode == MM_DUTY )
    scr_need_to_refresh_meas_units_and_icons = 1;
  if ( curr_meas_mode == MM_ACuA
    || curr_meas_mode == MM_ACmA
    || curr_meas_mode == MM_ACA
    || curr_meas_mode == MM_ACV && !meter_mode_acv_dcv
    || curr_meas_mode == MM_ACmV )
  {
    if ( curr_meas_mode )
      subscr_update_units();
  }
  if ( (curr_meas_mode == MM_ACuA
     || curr_meas_mode == MM_ACmA
     || curr_meas_mode == MM_ACA
     || curr_meas_mode == MM_ACV
     || curr_meas_mode == MM_ACmV)
    && !burden_enabled_for_current_ranges )
    need_to_update_subscr = 1;
}
// 20003A74: using guessed type __int16 freq_input_timeout_timer_10ms_unit;
// 20003AFC: using guessed type char scr_need_to_refresh_meas_units_and_icons;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B3D: using guessed type char burden_enabled_for_current_ranges;
// 20003B52: using guessed type char meter_mode_acv_dcv;

//----- (0801A32C) --------------------------------------------------------
void __cdecl hy_read_freq_counters_and_reset()
{
  hy_curr_CTA_gate_time = hy_regs_buf[0x1B] + (hy_regs_buf[0x1C] << 8) + (hy_regs_buf[0x1D] << 16);
  hy_curr_CTB_freqdata = hy_regs_buf[0x18] + (hy_regs_buf[0x19] << 8) + (hy_regs_buf[0x1A] << 16);
  hy_curr_CTC_duty = hy_regs_buf[0x15] + (hy_regs_buf[0x16] << 8) + (hy_regs_buf[0x17] << 16);
  hy_ctr_gate_time = 0x1000000 - (hy_CTA_initial_val << 8);
  hy_ctr_cyc_elapsed = 0x1000000
                     - (hy_CTA_initial_val << 8)
                     + hy_regs_buf[0x1B]
                     + (hy_regs_buf[0x1C] << 8)
                     + (hy_regs_buf[0x1D] << 16);
  hy_reset_freq_counter();
}
// 2000020C: using guessed type int hy_CTA_initial_val;
// 20003918: using guessed type int hy_ctr_gate_time;
// 2000391C: using guessed type int hy_curr_CTA_gate_time;
// 20003920: using guessed type int hy_curr_CTB_freqdata;
// 20003924: using guessed type int hy_curr_CTC_duty;
// 20003928: using guessed type int hy_ctr_cyc_elapsed;

//----- (0801A3EC) --------------------------------------------------------
void __fastcall meas_process_hz(char for_ac_input, char ac_hz_range)
{
  unsigned int v3; // r5@1

  LOBYTE(v3) = ac_hz_range;
  meas_calc_curr_freq();
  meter_overflow_was_negative = 0;
  curr_scr_overflow = 0;
  if ( for_ac_input || (unsigned __int8)meter_in_cal_mode | (unsigned __int8)(autoranging_disabled ^ 1) )
  {
    if ( (unsigned __int64)curr_freq_in_millihz < 1000000000 )
    {
      if ( (unsigned __int64)curr_freq_in_millihz < 100000000 )
      {
        if ( (unsigned __int8)v3 != 4 || (unsigned __int64)curr_freq_in_millihz < 80000000 )
        {
          if ( (unsigned __int64)curr_freq_in_millihz < 10000000 )
          {
            if ( (unsigned __int8)v3 != 3 || (unsigned __int64)curr_freq_in_millihz < 8000000 )
            {
              if ( (unsigned __int64)curr_freq_in_millihz < 1000000 )
              {
                if ( (unsigned __int8)v3 != 2 || (unsigned __int64)curr_freq_in_millihz < 800000 )
                {
                  if ( (unsigned __int64)curr_freq_in_millihz < 100000 )
                  {
                    if ( (unsigned __int8)v3 != 1 || (unsigned __int64)curr_freq_in_millihz < 80000 )
                      meas_calc_hz_digits(for_ac_input, 0);
                    else
                      meas_calc_hz_digits(for_ac_input, 1);
                  }
                  else
                  {
                    meas_calc_hz_digits(for_ac_input, 1);
                  }
                }
                else
                {
                  meas_calc_hz_digits(for_ac_input, 2);
                }
              }
              else
              {
                meas_calc_hz_digits(for_ac_input, 2);
              }
            }
            else
            {
              meas_calc_hz_digits(for_ac_input, 3);
            }
          }
          else
          {
            meas_calc_hz_digits(for_ac_input, 3);
          }
        }
        else
        {
          meas_calc_hz_digits(for_ac_input, 4);
        }
      }
      else
      {
        meas_calc_hz_digits(for_ac_input, 4);
      }
    }
    else
    {
      meas_calc_hz_digits(for_ac_input, 9);
    }
  }
  else
  {
    v3 = (unsigned __int8)v3;
    if ( (_BYTE)v3 )
    {
      if ( v3 == 2 )
      {
        if ( (unsigned __int64)curr_freq_in_millihz < 10000000 )
          meas_calc_hz_digits(0, 2);
        else
          curr_scr_overflow = 1;
      }
      else if ( v3 < 2 )
      {
        if ( (unsigned __int64)curr_freq_in_millihz < 1000000 )
          meas_calc_hz_digits(0, 1);
        else
          curr_scr_overflow = 1;
      }
      else if ( v3 == 4 )
      {
        if ( (unsigned __int64)curr_freq_in_millihz < 1000000000 )
          meas_calc_hz_digits(0, 4);
        else
          curr_scr_overflow = 1;
      }
      else if ( v3 < 4 )
      {
        if ( (unsigned __int64)curr_freq_in_millihz < 100000000 )
          meas_calc_hz_digits(0, 3);
        else
          curr_scr_overflow = 1;
      }
    }
    else if ( (unsigned __int64)curr_freq_in_millihz < 100000 )
    {
      meas_calc_hz_digits(0, 0);
    }
    else
    {
      curr_scr_overflow = 1;
    }
  }
  if ( !for_ac_input )
  {
    meas_was_updated = 1;
    curr_scr_decimal_place = calc_decimal_place_for_mode_range(curr_meas_mode, curr_meas_range);
  }
}
// 200037B0: using guessed type __int64 curr_freq_in_millihz;
// 20003AE3: using guessed type char curr_scr_decimal_place;
// 20003AE6: using guessed type char autoranging_disabled;
// 20003AE7: using guessed type char meter_overflow_was_negative;
// 20003B23: using guessed type char cal_mode_load_from_sd;
// 20003B24: using guessed type char meter_in_cal_mode;

//----- (0801A6BC) --------------------------------------------------------
void __fastcall meas_calc_hz_digits(char for_ac_input, char range)
{
  unsigned __int8 v2; // r6@0
  int v3; // r7@0
  char v4; // r5@1
  unsigned __int64 v5; // r0@12

  v4 = for_ac_input;
  if ( range )
  {
    switch ( range )
    {
      case 1:
        v2 = 1;
        curr_freq_in_millihz += 5LL;
        v3 = uint64_div(curr_freq_in_millihz, 10uLL);
        break;
      case 2:
        v2 = 2;
        curr_freq_in_millihz += 50LL;
        v3 = uint64_div(curr_freq_in_millihz, 100uLL);
        break;
      case 3:
        v2 = 3;
        curr_freq_in_millihz += 500LL;
        v3 = uint64_div(curr_freq_in_millihz, 1000uLL);
        break;
      case 4:
        v2 = 4;
        v5 = curr_freq_in_millihz + 5000;
        HIDWORD(v5) = (unsigned __int64)(curr_freq_in_millihz + 5000) >> 32;
        curr_freq_in_millihz = v5;
        v3 = uint64_div(v5, 10000uLL);
        break;
      case 9:
        v2 = 4;
        if ( for_ac_input == 1 )
          ac_input_hz_overflow = 1;
        else
          curr_scr_overflow = 1;
        break;
    }
  }
  else
  {
    v2 = 0;
    v3 = uint64_div(curr_freq_in_millihz, 1uLL);
  }
  if ( v4 )
  {
    ac_input_freq = v3;
    ac_input_freq_acv = v3;
    ac_input_freq_lowz = v3;
    ac_input_freq_range = v2;
    ac_input_freq_range_acv = v2;
    ac_input_freq_range_lowz = v2;
  }
  else
  {
    curr_scr_digits = v3;
    curr_meas_range = v2;
  }
}
// 200037B0: using guessed type __int64 curr_freq_in_millihz;
// 20003858: using guessed type int curr_scr_digits;
// 20003870: using guessed type int ac_input_freq;
// 20003940: using guessed type int ac_input_freq_acv;
// 20003944: using guessed type int ac_input_freq_lowz;
// 20003AE9: using guessed type char ac_input_hz_overflow;
// 20003B3A: using guessed type char ac_input_freq_range_acv;
// 20003B3B: using guessed type char ac_input_freq_range_lowz;

//----- (0801A828) --------------------------------------------------------
int meas_process_msec()
{
  int v1; // [sp+0h] [bp-8h]@0

  meter_overflow_was_negative = 0;
  meas_calc_msec();
  if ( (unsigned __int8)meter_in_cal_mode | (unsigned __int8)(autoranging_disabled ^ 1) )
  {
    if ( (unsigned __int64)curr_msec_val < 10000000 )
    {
      if ( (unsigned __int64)curr_msec_val < 1000000 )
      {
        if ( curr_meas_range != 2 || (unsigned __int64)curr_msec_val < 800000 )
        {
          if ( (unsigned __int64)curr_msec_val < 100000 )
          {
            if ( curr_meas_range != 1 || (unsigned __int64)curr_msec_val < 80000 )
              meas_set_msec_range_and_digits(0);
            else
              meas_set_msec_range_and_digits(1);
          }
          else
          {
            meas_set_msec_range_and_digits(1);
          }
        }
        else
        {
          meas_set_msec_range_and_digits(2);
        }
      }
      else
      {
        meas_set_msec_range_and_digits(2);
      }
    }
    else
    {
      meas_set_msec_range_and_digits(9);
    }
  }
  else if ( curr_meas_range )
  {
    if ( curr_meas_range == 2 )
    {
      if ( (unsigned __int64)curr_msec_val < 10000000 )
        meas_set_msec_range_and_digits(2);
      else
        curr_scr_overflow = 1;
    }
    else if ( curr_meas_range < 2u )
    {
      if ( (unsigned __int64)curr_msec_val < 1000000 )
        meas_set_msec_range_and_digits(1);
      else
        curr_scr_overflow = 1;
    }
  }
  else if ( (unsigned __int64)curr_msec_val < 100000 )
  {
    meas_set_msec_range_and_digits(0);
  }
  else
  {
    curr_scr_overflow = 1;
  }
  meas_was_updated = 1;
  curr_scr_decimal_place = calc_decimal_place_for_mode_range(curr_meas_mode, curr_meas_range);
  return v1;
}
// 200037B8: using guessed type __int64 curr_msec_val;
// 20003AE3: using guessed type char curr_scr_decimal_place;
// 20003AE6: using guessed type char autoranging_disabled;
// 20003AE7: using guessed type char meter_overflow_was_negative;
// 20003B23: using guessed type char cal_mode_load_from_sd;
// 20003B24: using guessed type char meter_in_cal_mode;

//----- (0801A9C8) --------------------------------------------------------
void __fastcall meas_set_msec_range_and_digits(int a1)
{
  a1 = (unsigned __int8)a1;
  if ( (_BYTE)a1 )
  {
    switch ( a1 )
    {
      case 1:
        curr_meas_range = 1;
        curr_scr_digits = uint64_div(curr_msec_val, 0xAuLL);
        break;
      case 2:
        curr_meas_range = 2;
        curr_scr_digits = uint64_div(curr_msec_val, 0x64uLL);
        break;
      case 9:
        curr_meas_range = 2;
        curr_scr_overflow = 1;
        break;
    }
  }
  else
  {
    curr_meas_range = 0;
    curr_scr_digits = uint64_div(curr_msec_val, 1uLL);
  }
}
// 200037B8: using guessed type __int64 curr_msec_val;
// 20003858: using guessed type int curr_scr_digits;

//----- (0801AA5C) --------------------------------------------------------
void __fastcall meas_process_duty()
{
  meter_overflow_was_negative = 0;
  meas_calc_duty();
  curr_scr_digits = curr_duty_val;
  meas_was_updated = 1;
}
// 20003858: using guessed type int curr_scr_digits;
// 20003914: using guessed type int curr_duty_val;
// 20003AE7: using guessed type char meter_overflow_was_negative;

//----- (0801AAB8) --------------------------------------------------------
void meas_process_cap()
{
  char v0; // zf@14
  float v1; // r0@16
  float v2; // r0@16
  float v3; // r0@19
  float v4; // r0@19
  unsigned int v5; // r4@23

  meter_overflow_was_negative = 0;
  if ( curr_meas_range == 5 )
  {
    curr_cap_val = hy_curr_CTC_duty / (unsigned int)hy_curr_CTB_freqdata;
  }
  else if ( (signed int)curr_meas_range >= 2 )
  {
    curr_cap_val = 100 * hy_curr_CTC_duty / (unsigned int)hy_curr_CTB_freqdata;
  }
  else
  {
    curr_cap_val = hy_curr_CTC_duty / (unsigned int)hy_curr_CTB_freqdata;
  }
  if ( (signed int)curr_meas_range >= 2 )
  {
    if ( calibrating_gain )
    {
      cal_update_curr_gain_accu(curr_cap_val);
    }
    else
    {
      v3 = fp_from_uint(curr_cap_val);
      v4 = fp_div(v3, cal_curr_gain_val);
      curr_cap_val = fp_to_uint(v4);
    }
  }
  else if ( calibrating_offset )
  {
    cap_offset_temp = cal_update_cap_offset_accu(curr_cap_val);
  }
  else if ( calibrating_gain )
  {
    cal_update_cap_gain_accu(curr_cap_val, cap_offset_temp);
  }
  else
  {
    if ( cal_curr_offset_val < (unsigned int)curr_cap_val )
      curr_cap_val -= cal_curr_offset_val;
    else
      curr_cap_val = 0;
    fp_equals(cal_curr_gain_val, 0.0);
    if ( !v0 && curr_cap_val )
    {
      v1 = fp_from_uint(curr_cap_val);
      v2 = fp_div(v1, cal_curr_gain_val);
      curr_cap_val = fp_to_uint(v2);
    }
  }
  if ( (signed int)curr_meas_range < 5 )
    curr_cap_val /= 10u;
  if ( curr_meas_range == 5 )
    v5 = curr_cap_val / 10u;
  else
    v5 = curr_cap_val / 50u;
  if ( (signed int)(unsigned __int16)v5 < 20 )
    LOWORD(v5) = 20;
  curr_scr_digits = meas_add_rolling_average_buf2(curr_cap_val, (unsigned __int16)v5, 10u);
  meas_was_updated = 1;
  meas_cap_reset_no_reading_timeout_timer();
}
// 200037DC: using guessed type int cap_offset_temp;
// 20003858: using guessed type int curr_scr_digits;
// 200038E0: using guessed type int cal_curr_offset_val;
// 20003920: using guessed type int hy_curr_CTB_freqdata;
// 20003924: using guessed type int hy_curr_CTC_duty;
// 20003948: using guessed type int curr_cap_val;
// 20003AE7: using guessed type char meter_overflow_was_negative;
// 20003B26: using guessed type char calibrating_offset;
// 20003B28: using guessed type char calibrating_gain;

//----- (0801AC74) --------------------------------------------------------
void __cdecl meas_process_cap_autorange()
{
  // if we didn't get a reading on the cap range
  // increase the range so that the cap will charge faster
  // and we can detect it without waiting forever
  if ( meas_cap_no_reading_timeout_elapsed )
  {
    meas_cap_no_reading_timeout_elapsed = 0;
    if ( (unsigned __int8)autoranging_disabled | (unsigned __int8)meter_in_cal_mode )
    {
      curr_scr_overflow = 1;
      meas_was_updated = 1;
    }
    else
    {
      if ( (signed int)curr_meas_range >= 2 )
      {
        if ( (signed int)curr_meas_range < 5 )
          curr_meas_range = 5;
      }
      else
      {
        curr_meas_range = 2;
      }
      hy_cap_related_always_set_to_zero = 0;
      meter_mode_changed = 0;
      meter_range_changed = 1;
    }
  }
}
// 20003AE6: using guessed type char autoranging_disabled;
// 20003AEC: using guessed type char meter_range_changed;
// 20003B17: using guessed type char hy_cap_related_always_set_to_zero;
// 20003B23: using guessed type char cal_mode_load_from_sd;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B3C: using guessed type char meas_cap_no_reading_timeout_elapsed;

//----- (0801ACE8) --------------------------------------------------------
void __fastcall meas_calc_curr_freq()
{
  signed __int64 v0; // r4@4
  unsigned __int64 v1; // r2@4
  unsigned __int64 v2; // r0@4

  if ( calibrating_gain && curr_meas_mode == MM_HZ )
    cal_update_sysclk();
  v0 = (unsigned int)hy_curr_CTB_freqdata * (signed __int64)hy_sysclk_in_decihz;
  v1 = uint64_div((unsigned int)hy_ctr_cyc_elapsed, 10uLL);
  v2 = 10 * v0;
  HIDWORD(v2) = (unsigned __int64)(10 * v0) >> 32;
  curr_freq_in_millihz = uint64_div(v2, v1);
}
// 200037B0: using guessed type __int64 curr_freq_in_millihz;
// 20003920: using guessed type int hy_curr_CTB_freqdata;
// 20003928: using guessed type int hy_ctr_cyc_elapsed;
// 20003B28: using guessed type char calibrating_gain;

//----- (0801AD58) --------------------------------------------------------
void __fastcall meas_calc_msec()
{
  unsigned __int64 v0; // r6@1
  __int64 v1; // r4@1
  unsigned __int64 v2; // r0@1
  unsigned __int64 v3; // r2@1

  v0 = 100000LL * (unsigned int)hy_ctr_cyc_elapsed;
  v1 = (unsigned int)hy_curr_CTB_freqdata;
  v2 = uint64_div(hy_sysclk_in_decihz, 1000uLL);
  v3 = (unsigned int)v2 * v1;
  HIDWORD(v3) += HIDWORD(v2) * v1;
  curr_msec_val = uint64_div(v0, v3);
}
// 200037B8: using guessed type __int64 curr_msec_val;
// 20003920: using guessed type int hy_curr_CTB_freqdata;
// 20003928: using guessed type int hy_ctr_cyc_elapsed;

//----- (0801ADA8) --------------------------------------------------------
void __cdecl meas_calc_duty()
{
  curr_duty_val = hy_curr_CTC_duty / (hy_ctr_cyc_elapsed / 1000u);
}
// 20003914: using guessed type int curr_duty_val;
// 20003924: using guessed type int hy_curr_CTC_duty;
// 20003928: using guessed type int hy_ctr_cyc_elapsed;

//----- (0801ADCC) --------------------------------------------------------
void __fastcall cal_update_sysclk()
{
  calibrating_gain = 0;
  hy_sysclk_in_decihz = uint64_div(
                          150000000LL * (unsigned int)hy_ctr_cyc_elapsed,
                          (unsigned int)(100 * hy_curr_CTB_freqdata));
  cal_write_factor(1, hy_sysclk_in_decihz);
}
// 20003920: using guessed type int hy_curr_CTB_freqdata;
// 20003928: using guessed type int hy_ctr_cyc_elapsed;
// 20003B28: using guessed type char calibrating_gain;

//----- (0801AE30) --------------------------------------------------------
int __fastcall meas_add_rolling_average_buf2(int num, int max_delta, unsigned __int16 averages)
{
  __int64 v3; // r6@4
  signed int i; // r9@12
  signed int j; // r9@15

  // consult meas_add_rolling_average_buf1
  if ( max_delta && averages )
  {
    v3 = 0LL;
    if ( max_delta < num - meas_ara2_last
      || (num - meas_ara2_last + max_delta < 0) ^ __OFADD__(num - meas_ara2_last, max_delta) )
      meas_ara2_count = 0;
    if ( meas_ara2_count )
    {
      ++meas_ara2_count;
      if ( averages < (unsigned int)(unsigned __int8)meas_ara2_count )
        meas_ara2_count = averages;
      for ( i = 1; i < (unsigned __int8)meas_ara2_count; ++i )
        meas_ara2_buf[(unsigned __int8)meas_ara2_count - i] = meas_ara2_buf[(unsigned __int8)meas_ara2_count - 1 - i];
      meas_ara2_buf[0] = num;
      for ( j = 0; j < (unsigned __int8)meas_ara2_count; ++j )
        v3 += meas_ara2_buf[j];
      num = int64_div(v3, (unsigned __int8)meas_ara2_count);
      meas_ara2_last = num;
    }
    else
    {
      meas_ara2_buf[(unsigned __int8)meas_ara2_count++] = num;
      meas_ara2_last = num;
    }
  }
  return num;
}
// 200038D8: using guessed type int meas_ara2_last;
// 20003B20: using guessed type char meas_ara2_count;

//----- (0801AF6C) --------------------------------------------------------
int __fastcall meas_process_burden_volts(int result)
{
  if ( result - dword_20003950 >= 11 || (result - dword_20003950 + 10 < 0) ^ __OFADD__(result - dword_20003950, 10) )
    dword_20003958 = 0;
  if ( dword_20003958 )
  {
    ++dword_20003958;
    if ( dword_20003958 < 4 )
    {
      dword_20003954 += result;
    }
    else
    {
      dword_20003958 = 3;
      dword_20003954 = result + dword_20003954 - dword_20003950;
    }
    dword_20003950 = dword_20003954 / dword_20003958;
    result = dword_20003954 / dword_20003958;
  }
  else
  {
    dword_20003958 = 1;
    dword_20003954 = result;
    dword_20003950 = result;
  }
  return result;
}
// 20003950: using guessed type int dword_20003950;
// 20003954: using guessed type int dword_20003954;
// 20003958: using guessed type int dword_20003958;

//----- (0801B050) --------------------------------------------------------
void __fastcall config_hy_based_on_mode_range(meter_meas_mode mode, unsigned __int8 range)
{
  meter_meas_mode v2; // r4@1

  v2 = mode;
  hy_set_regs_from_table(mode, range);
  config_hy_intregs(v2);
  hy_reset_freq_counter();
}

//----- (0801B070) --------------------------------------------------------
void __fastcall hy_set_regs_from_table(meter_meas_mode mode, unsigned __int8 range)
{
  unsigned __int8 i; // r6@1
  signed int v3; // r8@48
  signed int v4; // r8@62
  _BYTE regs[20]; // [sp+0h] [bp-30h]@6

  for ( i = 0; i < 20u; ++i )
  {
    if ( mode )
    {
      if ( mode == MM_ACV )
      {
        if ( meter_mode_acv_dcv )
        {
          if ( acv_dcv_measuring_dc )
            regs[i] = hy_regtbl_dcv[range][i];
          else
            regs[i] = hy_regtbl_acv[range][i];
        }
        else if ( input_lpf_enabled )
        {
          regs[i] = hy_regtbl_acv[range][i];
        }
        else if ( input_1ms_peak_enabled )
        {
          regs[i] = hy_regtbl_acv_1ms_peak[range][i];
        }
        else
        {
          regs[i] = hy_regtbl_acv[range][i];
        }
      }
      else
      {
        if ( mode < (unsigned int)MM_ACV )
        {
          regs[i] = hy_regtbl_dcv[range][i];    // DCV
          continue;
        }
        if ( mode == MM_ACmV )
        {
          if ( input_lpf_enabled )
          {
            regs[i] = hy_regtbl_acmv[range][i];
          }
          else if ( input_1ms_peak_enabled )
          {
            regs[i] = hy_regtbl_acmv_1ms_peak[range][i];
          }
          else
          {
            regs[i] = hy_regtbl_acmv[range][i];
          }
        }
        else
        {
          if ( mode < (unsigned int)MM_ACmV )
          {
            regs[i] = hy_regtbl_dcmv[range][i]; // DCmV
            continue;
          }
          if ( mode == MM_HZ )
            goto LABEL_91;
          if ( mode < (unsigned int)MM_HZ )
          {
            regs[i] = hy_regtbl_dcmv[0][i];     // TEMP
            continue;
          }
          if ( mode == MM_DUTY || mode < (unsigned int)MM_DUTY )// DUTY or mS
          {
LABEL_91:
            regs[i] = hy_regtbl_freq[i];
            continue;
          }
          if ( mode == MM_CONTINUITY )
          {
            regs[i] = hy_regtbl_continuity[i];
            continue;
          }
          if ( mode < (unsigned int)MM_CONTINUITY )// OHMS
          {
            regs[i] = hy_regtbl_ohms[range][i];
            continue;
          }
          if ( mode == MM_CAP )
          {
            regs[i] = hy_regtbl_cap[range][i];
            continue;
          }
          if ( mode < (unsigned int)MM_CAP )    // DIODE
          {
            regs[i] = hy_regtbl_diode[range][i];
            continue;
          }
          if ( mode == MM_ACmVA )
          {
            if ( measuring_amps_of_va_or_volts_of_burden )
              regs[i] = hy_regtbl_ac_amps[(unsigned __int8)curr_power_amps_range][i];
            else
              regs[i] = hy_regtbl_acv[(unsigned __int8)curr_power_volts_range][i];
          }
          else if ( mode < (unsigned int)MM_ACmVA )
          {
            if ( measuring_amps_of_va_or_volts_of_burden )
              regs[i] = hy_regtbl_ac_amps[(unsigned __int8)curr_power_amps_range][i];
            else
              regs[i] = hy_regtbl_acv[(unsigned __int8)curr_power_volts_range][i];
          }
          else
          {
            if ( mode == MM_ACuA )
              goto LABEL_85;
            if ( mode < (unsigned int)MM_ACuA ) // ACVA
            {
              if ( measuring_amps_of_va_or_volts_of_burden )
              {
                v4 = 0;
                if ( curr_power_amps_range )
                  v4 = 2;
                regs[i] = hy_regtbl_ac_amps[v4][i];
              }
              else
              {
                regs[i] = hy_regtbl_acv[(unsigned __int8)curr_power_volts_range][i];
              }
            }
            else
            {
              if ( mode == MM_ACmA )
                goto LABEL_85;
              if ( mode < (unsigned int)MM_ACmA )// DCuA
                goto LABEL_86;
              if ( mode == MM_ACA )
              {
LABEL_85:
                regs[i] = hy_regtbl_ac_amps[range][i];
                continue;
              }
              if ( mode < (unsigned int)MM_ACA )// DCmA
              {
LABEL_86:
                regs[i] = hy_regtbl_dc_amps[range][i];
                continue;
              }
              if ( mode == MM_DCuVA )
              {
                if ( measuring_amps_of_va_or_volts_of_burden )
                  regs[i] = hy_regtbl_dc_amps[(unsigned __int8)curr_power_amps_range][i];
                else
                  regs[i] = hy_regtbl_dcv[(unsigned __int8)curr_power_volts_range][i];
              }
              else
              {
                if ( mode < (unsigned int)MM_DCuVA )// DCA
                  goto LABEL_86;
                if ( mode == MM_DCVA )
                {
                  if ( measuring_amps_of_va_or_volts_of_burden )
                  {
                    v3 = 0;
                    if ( curr_power_amps_range )
                      v3 = 2;
                    regs[i] = hy_regtbl_dc_amps[v3][i];
                  }
                  else
                  {
                    regs[i] = hy_regtbl_dcv[(unsigned __int8)curr_power_volts_range][i];
                  }
                }
                else if ( mode < (unsigned int)MM_DCVA )
                {
                  if ( measuring_amps_of_va_or_volts_of_burden )
                    regs[i] = hy_regtbl_dc_amps[(unsigned __int8)curr_power_amps_range][i];
                  else
                    regs[i] = hy_regtbl_dcv[(unsigned __int8)curr_power_volts_range][i];
                }
              }
            }
          }
        }
      }
    }
    else if ( lowz_measuring_ac )               // LowZ
    {
      regs[i] = hy_regtbl_acv[3][i];
    }
    else
    {
      regs[i] = hy_regtbl_dcv[3][i];
    }
  }
  curr_hy_R20 = regs[0];
  send_data_to_hy3131(regs, 32, 20u);
}
// 20003B18: using guessed type char curr_hy_R20;
// 20003B32: using guessed type char lowz_measuring_ac;
// 20003B4F: using guessed type char input_1ms_peak_enabled;
// 20003B51: using guessed type char input_lpf_enabled;
// 20003B52: using guessed type char meter_mode_acv_dcv;
// 20003B55: using guessed type char acv_dcv_measuring_dc;
// 20003B59: using guessed type char measuring_amps_of_va_or_volts_of_burden;
// 20003B5B: using guessed type char curr_power_volts_range;
// 20003B5C: using guessed type char curr_power_amps_range;

//----- (0801B4E0) --------------------------------------------------------
void __fastcall config_hy_intregs(meter_meas_mode mode)
{
  _BYTE intregs[8]; // [sp+0h] [bp-10h]@1

  intregs[0] = 0;
  if ( mode == MM_LOW_Z )
  {
    if ( lowz_measuring_ac )
      intregs[1] = 5;
    else
      intregs[1] = 4;
    goto LABEL_41;
  }
  if ( mode == MM_ACV )
  {
    if ( meter_mode_acv_dcv && acv_dcv_measuring_dc )
    {
      intregs[1] = 4;
      goto LABEL_41;
    }
LABEL_35:
    if ( input_1ms_peak_enabled == 1 )
    {
      intregs[1] = 17;
      goto LABEL_41;
    }
    goto LABEL_37;
  }
  if ( mode < (unsigned int)MM_ACV )
    goto LABEL_38;
  if ( mode == MM_ACmV )
    goto LABEL_35;
  if ( mode < (unsigned int)MM_ACmV )
    goto LABEL_38;
  if ( mode == MM_HZ )
    goto LABEL_44;
  if ( mode < (unsigned int)MM_HZ )
    goto LABEL_38;
  if ( mode == MM_DUTY || mode < (unsigned int)MM_DUTY )
  {
LABEL_44:
    intregs[1] = 1;
    goto LABEL_41;
  }
  if ( mode == MM_CONTINUITY || mode < (unsigned int)MM_CONTINUITY )
    goto LABEL_38;
  if ( mode == MM_CAP )
  {
    intregs[1] = 1;
    goto LABEL_41;
  }
  if ( mode < (unsigned int)MM_CAP )
    goto LABEL_38;
  if ( mode == MM_ACmVA
    || mode < (unsigned int)MM_ACmVA
    || mode == MM_ACuA
    || mode < (unsigned int)MM_ACuA
    || mode == MM_ACmA )
    goto LABEL_37;
  if ( mode < (unsigned int)MM_ACmA )
    goto LABEL_38;
  if ( mode == MM_ACA )
  {
LABEL_37:
    intregs[1] = 5;
    goto LABEL_41;
  }
  if ( mode < (unsigned int)MM_ACA || mode == MM_DCuVA )
    goto LABEL_38;
  if ( mode < (unsigned int)MM_DCuVA )
  {
    intregs[1] = 4;
    goto LABEL_41;
  }
  if ( mode == MM_DCVA || mode < (unsigned int)MM_DCVA )
LABEL_38:
    intregs[1] = 4;
LABEL_41:
  send_data_to_hy3131(intregs, 30, 2u);
}
// 20003B32: using guessed type char lowz_measuring_ac;
// 20003B4F: using guessed type char input_1ms_peak_enabled;
// 20003B52: using guessed type char meter_mode_acv_dcv;
// 20003B55: using guessed type char acv_dcv_measuring_dc;

//----- (0801B5B8) --------------------------------------------------------
void hy_reset_freq_counter()
{
  char regs; // [sp+0h] [bp-8h]@4
  __int16 v1; // [sp+1h] [bp-7h]@6

  if ( curr_meas_mode != MM_HZ && curr_meas_mode != MM_mSEC && curr_meas_mode != MM_DUTY )
    regs = curr_hy_R20 & 0xF5;                  // turn off ENCTR (frequency counter) and set source to ACPO
  else
    regs = curr_hy_R20 & 0xFD;                  // turn off ENCTR (frequency counter)
  send_data_to_hy3131(&regs, 0x20, 1u);         // activate change
  spinloop(10000u);
  regs = 0;                                     // write initial value to CTA (low 8 bits = 0)
  v1 = hy_CTA_initial_val;
  send_data_to_hy3131(&regs, 0x1B, 3u);
  read_registers_from_hy3131(hy_regs_buf, 0x1B, 3u);// reread CTA into AD1 cache (for some reason)
  // enable frequency counter
  if ( curr_meas_mode != MM_HZ && curr_meas_mode != MM_mSEC && curr_meas_mode != MM_DUTY )
    regs = curr_hy_R20 | 2;                     // turn on counter (either way for some reason)
  else
    regs = curr_hy_R20 | 2;
  send_data_to_hy3131(&regs, 0x20, 1u);         // activate change
}
// 2000020C: using guessed type int hy_CTA_initial_val;
// 20003B18: using guessed type char curr_hy_R20;

//----- (0801B66C) --------------------------------------------------------
void __fastcall send_data_to_hy3131(_BYTE *data, char address, unsigned __int16 count)
{
  _BYTE *v3; // r4@1
  char v4; // r5@1
  unsigned __int16 v5; // r6@1
  int i; // r8@1

  v3 = data;
  v4 = address;
  v5 = count;
  GPIOF.BSRR = 0x20004;
  spinloop(0xAu);
  send_byte_to_hy3131(2 * v4, 0);
  spinloop(0xAu);
  for ( i = 0; (unsigned __int8)i < (unsigned int)v5; ++i )
  {
    send_byte_to_hy3131(v3[i], 0);
    spinloop(0xAu);
  }
  LOWORD(GPIOF.BSRR) = 2;
}
// 40021800: using guessed type GPIO_REGS GPIOF;

//----- (0801B6EC) --------------------------------------------------------
void __fastcall read_registers_from_hy3131(_BYTE *data, char a2, unsigned __int16 count)
{
  char v3; // r5@1
  unsigned __int16 v4; // r6@1
  int i; // r9@1

  v3 = a2;
  v4 = count;
  GPIOF.BSRR = 0x20004;
  spinloop(5u);
  send_byte_to_hy3131(2 * v3 | 1, 1);
  spinloop(5u);
  for ( i = 0; (unsigned __int8)i < (unsigned int)v4; ++i )
  {
    hy_regs_buf[i] = recv_byte_from_hy3131();
    spinloop(2u);
  }
  LOWORD(GPIOF.BSRR) = 2;
}
// 40021800: using guessed type GPIO_REGS GPIOF;

//----- (0801B764) --------------------------------------------------------
unsigned __int8 recv_byte_from_hy3131()
{
  int v0; // r0@1
  unsigned __int8 i; // r1@1

  v0 = 0;
  HIWORD(GPIOF.BSRR) = 1;
  for ( i = 0; (signed int)i < 8; ++i )
  {
    LOWORD(GPIOF.BSRR) = 1;
    if ( GPIOF.IDR & 8 )
      v0 |= 128 >> i;
    HIWORD(GPIOF.BSRR) = 1;
  }
  return v0;
}
// 40021800: using guessed type GPIO_REGS GPIOF;

//----- (0801B798) --------------------------------------------------------
void __fastcall send_byte_to_hy3131(unsigned __int8 data, char doing_read_of_register)
{
  unsigned __int8 v2; // r4@1
  char v3; // r5@1
  unsigned __int8 i; // r6@1

  v2 = data;
  v3 = doing_read_of_register;
  for ( i = 0; (signed int)i < 8; ++i )
  {
    if ( v2 & (128 >> i) )
      LOWORD(GPIOF.BSRR) = 4;
    else
      HIWORD(GPIOF.BSRR) = 4;
    pulse_hy3131_clock();
  }
  if ( v3 == 1 )
  {
    HIWORD(GPIOF.BSRR) = 4;
    pulse_hy3131_clock();
  }
  LOWORD(GPIOF.BSRR) = 4;
}
// 40021800: using guessed type GPIO_REGS GPIOF;

//----- (0801B7E8) --------------------------------------------------------
void pulse_hy3131_clock()
{
  spinloop(1u);
  LOWORD(GPIOF.BSRR) = 1;
  spinloop(1u);
  HIWORD(GPIOF.BSRR) = 1;
}
// 40021800: using guessed type GPIO_REGS GPIOF;

//----- (0801B8A8) --------------------------------------------------------
__int64 __fastcall int64_div(__int64 a, __int64 b)
{
  unsigned int bsign; // r12@1
  int v3; // r12@3
  int v4; // r4@4
  unsigned int v5; // r4@19
  __int64 v6; // r2@20
  unsigned int v7; // r6@20
  int v8; // off@24
  unsigned __int8 v9; // cf@21
  int v10; // off@23
  char v11; // r6@28
  __int64 v12; // r4@29
  int v13; // off@33
  unsigned __int8 v14; // cf@30
  int v15; // lr@30
  int v16; // off@32
  int v17; // off@32
  int v18; // r4@35
  unsigned int v19; // r5@35

  bsign = HIDWORD(b) & 0x80000000;
  if ( (HIDWORD(b) & 0x80000000 & 0x80000000) != 0 )
  {
    v9 = (unsigned int)b <= 0;
    LODWORD(b) = -(signed int)b;
    HIDWORD(b) = -HIDWORD(b) - !v9;
  }
  v3 = bsign ^ (SHIDWORD(a) >> 32);
  if ( v3 )
  {
    v4 = v3;
    if ( a < 0 )
    {
      v9 = (unsigned int)a <= 0;
      LODWORD(a) = -(signed int)a;
      HIDWORD(a) = -HIDWORD(a) - !v9;
    }
    a = uint64_div(a, b);
    if ( __CFSHL__(v4, 1) )
    {
      v9 = (unsigned int)a <= 0;
      LODWORD(a) = -(signed int)a;
      HIDWORD(a) = -HIDWORD(a) - !v9;
    }
    return a;
  }
  if ( HIDWORD(b) )
  {
    if ( !__CFADD__(HIDWORD(a), ~HIDWORD(b) + ((unsigned int)a >= (unsigned int)b)) )
      return 0LL;
    v5 = __clz(HIDWORD(b)) - __clz(HIDWORD(a));
    HIDWORD(b) <<= v5;
  }
  else
  {
    if ( !HIDWORD(a) )
    {
      if ( (_DWORD)b )
        LODWORD(a) = (unsigned int)a / (unsigned int)b;
      return a;
    }
    if ( (unsigned int)b <= 1 )
    {
      (unsigned int)b < 1;
      return a;
    }
    if ( !((unsigned int)b >> 16) )
    {
      v18 = HIDWORD(a);
      HIDWORD(a) /= (unsigned int)b;
      v19 = ((v18 - (_DWORD)b * HIDWORD(a)) << 16) | ((unsigned int)a >> 16);
      LODWORD(a) = ((unsigned __int16)a | ((v19 - (_DWORD)b * (v19 / (unsigned int)b)) << 16)) / (unsigned int)b | (v19 / (unsigned int)b << 16);
      return a;
    }
    v5 = 32 - __clz(HIDWORD(a)) + __clz(b);
    v11 = v5 - 32;
    if ( v5 >= 0x20 )
    {
      LODWORD(b) = (_DWORD)b << v11;
      v12 = 0x80000000 >> v11;
      while ( 1 )
      {
        v14 = __CFADD__(HIDWORD(a), ~(_DWORD)b + ((unsigned int)a >= HIDWORD(b)));
        v15 = (a - __PAIR__((unsigned int)b, HIDWORD(b))) >> 32;
        if ( __CFADD__(HIDWORD(a), ~(_DWORD)b + ((unsigned int)a >= HIDWORD(b))) )
        {
          LODWORD(a) = a - HIDWORD(b);
          HIDWORD(a) = v15;
        }
        v16 = v14 + (_DWORD)v12;
        v9 = __CFADD__(v14, (_DWORD)v12) | __CFADD__((_DWORD)v12, v16);
        LODWORD(v12) = v12 + v16;
        v17 = v9 + HIDWORD(v12);
        v9 = __CFADD__(v9, HIDWORD(v12)) | __CFADD__(HIDWORD(v12), v17);
        HIDWORD(v12) += v17;
        if ( v9 )
          break;
        LODWORD(b) = (unsigned int)b >> 1;
        v13 = __RCR__(HIDWORD(b), 1);
        HIDWORD(b) = v13;
      }
      return v12;
    }
  }
  HIDWORD(b) |= (unsigned int)b >> (32 - v5);
  LODWORD(v6) = (_DWORD)b << v5;
  v7 = 0x80000000 >> v5;
  while ( 1 )
  {
    v9 = __CFADD__(HIDWORD(a), ~HIDWORD(v6) + ((unsigned int)a >= (unsigned int)v6));
    if ( __CFADD__(HIDWORD(a), ~HIDWORD(v6) + ((unsigned int)a >= (unsigned int)v6)) )
      a -= v6;
    v10 = v9 + v7;
    v9 = __CFADD__(v9, v7) | __CFADD__(v7, v10);
    v7 += v10;
    if ( v9 )
      break;
    HIDWORD(v6) >>= 1;
    v8 = __RCR__(v6, 1);
    LODWORD(v6) = v8;
  }
  return v7;
}

//----- (0801B9DC) --------------------------------------------------------
int __fastcall meas_calc_ac_freq_dependent_offset_core(signed int digits, int decirange_factor, int fullrange_factor, int decirange_factor_lf, int fullrange_factor_lf, unsigned __int8 range, int ac_in_freq, unsigned __int8 ac_in_range)
{
  signed int in_gt_5000; // r10@1
  signed int infreq_table_len; // r11@1
  int result; // r0@3
  int infreq_table_loc; // r8@15
  int i; // r0@15
  float v17; // r6@28
  float v18; // r0@28
  int v19; // r6@43
  float v20; // r0@43
  float v21; // r0@43
  double v22; // r0@43
  double v23; // r0@43
  float v24; // r6@43
  float v25; // r0@43
  float v26; // r0@43
  float v27; // r0@43
  float v28; // r6@43
  float v29; // r0@43
  float v30; // r0@43
  float v31; // r0@43
  float v32; // r4@47
  float v33; // r0@47
  float v34; // r4@47
  float v35; // r0@47
  float v36; // r4@48
  float v37; // r0@48
  float v38; // r0@48
  double v39; // r0@48
  double v40; // r0@48
  float v41; // r0@48
  int v42; // r4@49


  // Range Values
  // ACmV
  // 0 -> 50.000mV
  // 1 -> 500.00mV
  // ACV
  // 2 -> 5.0000V
  // 3 -> 50.000V
  // 4 -> 500.00V
  // 5 -> 600.0V (and LowZ, though I don't think this applies?)
  //      return 0 if >= 660.0V
  // ACuA
  // 6 -> 50.000uA/500.00uA
  // ACmA
  // 7 -> 5.0000mA/50.000mA
  // ACA
  // 8 -> 500.00mA/5.0000A/10.000A
  //      return 0 always

  // return 0 if >= 55000 counts or freq <= 50Hz

  in_gt_5000 = 1;
  infreq_table_len = 9;
  mcafdoc_result_offset = 0;
  mcafdoc_is_always_zero = 0;
  if ( range != 5 || digits < 6600 )
  {
    if ( digits < 55000 )
    {
      if ( (signed int)range < 8 )
      {
        mcafdoc_ac_input_hz = ac_input_freq_to_hz(ac_in_range, ac_in_freq);
        if ( mcafdoc_ac_input_hz >= 51 )
        {
          if ( range != 2 && range != 3 )
          {
            if ( (signed int)range >= 4 )
              infreq_table_len = 7;
            infreq_table_loc = infreq_table_len - 1;
            for ( i = 0; i < infreq_table_len; ++i )
            {
              if ( (signed int)range >= 2 )
              {
                if ( (signed int)range >= 4 && mcafdoc_infreq_tbl_10khz[i] >= mcafdoc_ac_input_hz )
                {
                  infreq_table_loc = i;
                  break;
                }
              }
              else if ( mcafdoc_infreq_tbl_100khz[i] >= mcafdoc_ac_input_hz )
              {
                infreq_table_loc = i;
                break;
              }
            }
            mcafdoc_decirange_factor = decirange_factor;
            mcafdoc_fullrange_factor = fullrange_factor;
            if ( (signed int)range >= 2 )
            {
              if ( (signed int)range >= 4 )
              {
                mcafdoc_freq_range_hi = mcafdoc_infreq_tbl_10khz[infreq_table_loc];
                mcafdoc_freq_range_lo = mcafdoc_infreq_tbl_10khz[infreq_table_loc - 1];
              }
            }
            else
            {
              mcafdoc_freq_range_hi = mcafdoc_infreq_tbl_100khz[infreq_table_loc];
              mcafdoc_freq_range_lo = mcafdoc_infreq_tbl_100khz[infreq_table_loc - 1];
            }
            mcafdoc_freq_range_size = mcafdoc_freq_range_hi - mcafdoc_freq_range_lo;
            mcafdoc_freq_dist_into_range = mcafdoc_ac_input_hz - mcafdoc_freq_range_lo;
            v17 = fp_from_int(mcafdoc_ac_input_hz - mcafdoc_freq_range_lo);
            v18 = fp_from_int(mcafdoc_freq_range_size);
            mcafdoc_frac_into_range = fp_div(v17, v18);
            if ( digits < 5001 )
              in_gt_5000 = 0;
            if ( range )
            {
              switch ( range )
              {
                case 1u:
                  mcafdoc_freq_range_hi = mcafdoc_corr_tbl_acmv500[in_gt_5000][infreq_table_loc];
                  mcafdoc_freq_range_lo = mcafdoc_corr_tbl_acmv500[in_gt_5000][infreq_table_loc - 1];
                  break;
                case 4u:
                  mcafdoc_freq_range_hi = mcafdoc_corr_tbl_acv500[in_gt_5000][infreq_table_loc];
                  mcafdoc_freq_range_lo = mcafdoc_corr_tbl_acv500[in_gt_5000][infreq_table_loc - 1];
                  break;
                case 5u:
                  mcafdoc_freq_range_hi = mcafdoc_corr_tbl_acv600[in_gt_5000][infreq_table_loc];
                  mcafdoc_freq_range_lo = mcafdoc_corr_tbl_acv600[in_gt_5000][infreq_table_loc - 1];
                  break;
                case 6u:
                  mcafdoc_freq_range_hi = mcafdoc_corr_tbl_acuA[in_gt_5000][infreq_table_loc];
                  mcafdoc_freq_range_lo = mcafdoc_corr_tbl_acuA[in_gt_5000][infreq_table_loc - 1];
                  break;
                case 7u:
                  mcafdoc_freq_range_hi = mcafdoc_corr_tbl_acmA[in_gt_5000][infreq_table_loc];
                  mcafdoc_freq_range_lo = mcafdoc_corr_tbl_acmA[in_gt_5000][infreq_table_loc - 1];
                  break;
              }
            }
            else
            {
              mcafdoc_freq_range_hi = mcafdoc_corr_tbl_acmv50[in_gt_5000][infreq_table_loc];
              mcafdoc_freq_range_lo = mcafdoc_corr_tbl_acmv50[in_gt_5000][infreq_table_loc - 1];
            }
            mcafdoc_freq_range_size = mcafdoc_freq_range_lo;
            mcafdoc_freq_dist_into_range = mcafdoc_freq_range_hi - mcafdoc_freq_range_lo;
            v19 = mcafdoc_freq_range_lo;
            v20 = fp_from_int(mcafdoc_freq_range_hi - mcafdoc_freq_range_lo);
            v21 = fp_mul(v20, mcafdoc_frac_into_range);
            v22 = dp_from_fp(v21);
            v23 = dp_add(v22, 0.5);
            mcafdoc_corr_val = dp_to_int(v23) + v19;
            v24 = fp_from_int(mcafdoc_decirange_factor);
            v25 = fp_from_int(mcafdoc_corr_val);
            v26 = fp_mul(v25, v24);
            v27 = fp_div(v26, 100.0);
            mcafdoc_corr_val_decirange = fp_to_int(v27);
            v28 = fp_from_int(mcafdoc_fullrange_factor);
            v29 = fp_from_int(mcafdoc_corr_val);
            v30 = fp_mul(v29, v28);
            v31 = fp_div(v30, 100.0);
            mcafdoc_corr_val_fullrange = fp_to_int(v31);
            if ( range == 5 )
            {
              mcafdoc_corr_digits_decirange = mcafdoc_corr_val_decirange + 600;
              mcafdoc_corr_digits_fullrange = mcafdoc_corr_val_fullrange + 5400;
              mcafdoc_digits_decirange = 600;
            }
            else
            {
              mcafdoc_corr_digits_decirange = mcafdoc_corr_val_decirange + 5000;
              mcafdoc_corr_digits_fullrange = mcafdoc_corr_val_fullrange + 45000;
              mcafdoc_digits_decirange = 5000;
            }
            if ( mcafdoc_corr_digits_decirange < digits )
            {
              mcafdoc_freq_range_hi = mcafdoc_corr_val_fullrange;
              mcafdoc_freq_range_lo = mcafdoc_corr_val_fullrange - mcafdoc_corr_val_decirange;
              v36 = fp_from_int(digits - mcafdoc_digits_decirange);
              v37 = fp_from_int(mcafdoc_corr_digits_fullrange);
              v38 = fp_div(v36, v37);
              v39 = dp_from_fp(v38);
              v40 = dp_add(v39, -1.0);
              mcafdoc_corr_in_range = fp_from_dp(v40);
              v41 = fp_from_int(mcafdoc_freq_range_lo);
              mcafdoc_corr_in_range = fp_mul(v41, mcafdoc_corr_in_range);
            }
            else
            {
              mcafdoc_freq_range_hi = 0;
              v32 = fp_from_int(digits);
              v33 = fp_from_int(mcafdoc_corr_digits_decirange);
              v34 = fp_div(v32, v33);
              v35 = fp_from_int(mcafdoc_corr_val_decirange);
              mcafdoc_corr_in_range = fp_mul(v35, v34);
            }
            v42 = mcafdoc_freq_range_hi;
            result = mcafdoc_is_always_zero + fp_to_int(mcafdoc_corr_in_range) + v42;
            mcafdoc_result_offset = result;
          }
          else
          {
            result = meas_calc_ac_freq_dependent_offset_core_for_ACV_5_50V(
                       digits,
                       decirange_factor,
                       fullrange_factor,
                       decirange_factor_lf,
                       fullrange_factor_lf,
                       range,
                       mcafdoc_ac_input_hz);
            mcafdoc_result_offset = result;
          }
        }
        else
        {
          result = mcafdoc_result_offset;
        }
      }
      else
      {
        result = mcafdoc_result_offset;
      }
    }
    else
    {
      result = mcafdoc_result_offset;
    }
  }
  else
  {
    result = mcafdoc_result_offset;
  }
  return result;
}
// 200039C0: using guessed type int mcafdoc_result_offset;
// 200039C4: using guessed type int mcafdoc_ac_input_hz;
// 200039C8: using guessed type int mcafdoc_corr_val;
// 200039CC: using guessed type int mcafdoc_freq_range_size;
// 200039D0: using guessed type int mcafdoc_freq_dist_into_range;
// 200039D4: using guessed type int mcafdoc_corr_val_decirange;
// 200039D8: using guessed type int mcafdoc_corr_val_fullrange;
// 200039DC: using guessed type int mcafdoc_corr_digits_decirange;
// 200039E0: using guessed type int mcafdoc_corr_digits_fullrange;
// 200039E4: using guessed type int mcafdoc_freq_range_hi;
// 200039E8: using guessed type int mcafdoc_freq_range_lo;
// 200039EC: using guessed type int mcafdoc_digits_decirange;
// 200039F0: using guessed type int mcafdoc_decirange_factor;
// 200039F4: using guessed type int mcafdoc_fullrange_factor;
// 200039F8: using guessed type int mcafdoc_is_always_zero;

//----- (0801BEB6) --------------------------------------------------------
int __fastcall meas_calc_ac_freq_dependent_offset_core_for_ACV_5_50V(int digits, int decirange_factor, int fullrange_factor, int decirange_factor_lf, int fullrange_factor_lf, int range, int ac_in_hz)
{
  signed int v9; // r9@1
  signed int i; // r1@1
  float v11; // r10@12
  float v12; // r0@12
  int v13; // r8@22
  float v14; // r0@22
  float v15; // r0@22
  double v16; // r0@22
  double v17; // r0@22
  int v18; // r8@22
  float v19; // r0@22
  float v20; // r0@22
  double v21; // r0@22
  double v22; // r0@22
  float v23; // r4@26
  float v24; // r0@26
  float v25; // r4@26
  float v26; // r0@26
  float v27; // r0@26
  float v28; // r0@26
  float v29; // r0@26
  float v30; // r5@27
  float v31; // r0@27
  float v32; // r4@27
  float v33; // r0@27
  float v34; // r0@27
  float v35; // r0@27

  mcafdoc_ac_fullrange_factor_diff = fullrange_factor - fullrange_factor_lf;
  mcafdoc_ac_decirange_factor_diff = decirange_factor - decirange_factor_lf;
  v9 = 8;
  for ( i = 0; i < 9; ++i )
  {
    if ( ac_in_hz < 20001 )
    {
      if ( mcafdoc_ac_infreq_tbl_20khz[i] >= ac_in_hz )
      {
        v9 = i;
        break;
      }
    }
    else if ( mcafdoc_ac_infreq_tbl_100khz[i] >= ac_in_hz )
    {
      v9 = i;
      break;
    }
  }
  if ( ac_in_hz < 20001 )
  {
    mcafdoc_ac_range_hi = mcafdoc_ac_infreq_tbl_20khz[v9];
    mcafdoc_ac_range_lo = mcafdoc_ac_infreq_tbl_20khz[v9 - 1];
  }
  else
  {
    mcafdoc_ac_range_hi = mcafdoc_ac_infreq_tbl_100khz[v9];
    mcafdoc_ac_range_lo = mcafdoc_ac_infreq_tbl_100khz[v9 - 1];
  }
  mcafdoc_ac_range_diff = mcafdoc_ac_range_hi - mcafdoc_ac_range_lo;
  mcafdoc_ac_digits_into_range = ac_in_hz - mcafdoc_ac_range_lo;
  v11 = fp_from_int(ac_in_hz - mcafdoc_ac_range_lo);
  v12 = fp_from_int(mcafdoc_ac_range_diff);
  mcafdoc_ac_infreq_frac_into_range = fp_div(v11, v12);
  if ( range == 2 )
  {
    if ( ac_in_hz < 20001 )
    {
      mcafdoc_ac_range_hi = mcafdoc_ac_corr_tbl_acv5[v9];
      mcafdoc_ac_range_lo = mcafdoc_ac_corr_tbl_acv5[v9 - 1];
      mcafdoc_ac_range_lf_hi = mcafdoc_ac_corr_tbl_acv5[v9 + 9];
      mcafdoc_ac_range_lf_lo = mcafdoc_ac_corr_tbl_acv5[v9 + 8];
    }
    else
    {
      mcafdoc_ac_range_hi = mcafdoc_ac_corr_tbl_acv5[v9 + 18];
      mcafdoc_ac_range_lo = mcafdoc_ac_corr_tbl_acv5[v9 + 17];
      mcafdoc_ac_range_lf_hi = mcafdoc_ac_corr_tbl_acv5[v9 + 27];
      mcafdoc_ac_range_lf_lo = mcafdoc_ac_corr_tbl_acv5[v9 + 26];
    }
  }
  else if ( range == 3 )
  {
    if ( ac_in_hz < 20001 )
    {
      mcafdoc_ac_range_hi = mcafdoc_ac_corr_tbl_acv50[v9];
      mcafdoc_ac_range_lo = mcafdoc_ac_corr_tbl_acv50[v9 - 1];
      mcafdoc_ac_range_lf_hi = mcafdoc_ac_corr_tbl_acv50[v9 + 9];
      mcafdoc_ac_range_lf_lo = mcafdoc_ac_corr_tbl_acv50[v9 + 8];
    }
    else
    {
      mcafdoc_ac_range_hi = mcafdoc_ac_corr_tbl_acv50[v9 + 18];
      mcafdoc_ac_range_lo = mcafdoc_ac_corr_tbl_acv50[v9 + 17];
      mcafdoc_ac_range_lf_hi = mcafdoc_ac_corr_tbl_acv50[v9 + 27];
      mcafdoc_ac_range_lf_lo = mcafdoc_ac_corr_tbl_acv50[v9 + 26];
    }
  }
  mcafdoc_ac_range_diff = mcafdoc_ac_range_lo;
  mcafdoc_ac_digits_into_range = mcafdoc_ac_range_hi - mcafdoc_ac_range_lo;
  v13 = mcafdoc_ac_range_lo;
  v14 = fp_from_int(mcafdoc_ac_range_hi - mcafdoc_ac_range_lo);
  v15 = fp_mul(v14, mcafdoc_ac_infreq_frac_into_range);
  v16 = dp_from_fp(v15);
  v17 = dp_add(v16, 0.5);
  mcafdoc_ac_corr_factor = dp_to_int(v17) + v13;
  mcafdoc_ac_range_diff = mcafdoc_ac_range_lf_lo;
  mcafdoc_ac_digits_into_range = mcafdoc_ac_range_lf_hi - mcafdoc_ac_range_lf_lo;
  v18 = mcafdoc_ac_range_lf_lo;
  v19 = fp_from_int(mcafdoc_ac_range_lf_hi - mcafdoc_ac_range_lf_lo);
  v20 = fp_mul(v19, mcafdoc_ac_infreq_frac_into_range);
  v21 = dp_from_fp(v20);
  v22 = dp_add(v21, 0.5);
  mcafdoc_ac_corr_factor_lf = dp_to_int(v22) + v18;
  if ( ac_in_hz < 20001 )
  {
    mcafdoc_ac_corr_val_lo = mcafdoc_ac_corr_factor * decirange_factor_lf / 100;
    mcafdoc_ac_corr_val_hi = mcafdoc_ac_corr_factor_lf * fullrange_factor_lf / 100;
  }
  else
  {
    mcafdoc_ac_corr_val_lo = decirange_factor_lf + mcafdoc_ac_decirange_factor_diff * mcafdoc_ac_corr_factor / 100;
    mcafdoc_ac_corr_val_hi = fullrange_factor_lf + mcafdoc_ac_fullrange_factor_diff * mcafdoc_ac_corr_factor_lf / 100;
  }
  mcafdoc_ac_decirange_factor_lf_digits = decirange_factor_lf + 5000;
  if ( decirange_factor_lf + 5000 >= digits )
  {
    v30 = fp_from_int(mcafdoc_ac_decirange_factor_lf_digits);
    v31 = fp_from_int(digits);
    v32 = fp_sub(v30, v31);
    v33 = fp_from_int(mcafdoc_ac_decirange_factor_lf_digits);
    v34 = fp_div(v32, v33);
    v35 = fp_mul(v34, 100.0);
    mcafdoc_ac_amt_digits_into_range = fp_to_int(v35);
    mcafdoc_corr_val_diff = mcafdoc_ac_corr_val_lo;
    mcafdoc_ac_result = mcafdoc_ac_corr_val_lo - mcafdoc_ac_corr_val_lo * mcafdoc_ac_amt_digits_into_range / 100;
  }
  else
  {
    v23 = fp_from_int(digits);
    v24 = fp_from_int(mcafdoc_ac_decirange_factor_lf_digits);
    v25 = fp_sub(v23, v24);
    v26 = fp_from_int(mcafdoc_ac_decirange_factor_lf_digits);
    v27 = fp_sub(50000.0, v26);
    v28 = fp_div(v25, v27);
    v29 = fp_mul(v28, 100.0);
    mcafdoc_ac_amt_digits_into_range = fp_to_int(v29);
    mcafdoc_corr_val_diff = mcafdoc_ac_corr_val_hi - mcafdoc_ac_corr_val_lo;
    mcafdoc_ac_result = mcafdoc_ac_corr_val_hi
                      - mcafdoc_ac_corr_val_lo
                      - (mcafdoc_ac_corr_val_hi - mcafdoc_ac_corr_val_lo) * mcafdoc_ac_amt_digits_into_range / 100;
    mcafdoc_ac_result = mcafdoc_ac_corr_val_hi - mcafdoc_ac_result;
  }
  mcafdoc_ac_what = mcafdoc_ac_result;
  return mcafdoc_ac_result;
}
// 20003A04: using guessed type int mcafdoc_ac_what;
// 20003A08: using guessed type int mcafdoc_ac_fullrange_factor_diff;
// 20003A0C: using guessed type int mcafdoc_ac_decirange_factor_diff;
// 20003A10: using guessed type int mcafdoc_ac_corr_factor;
// 20003A14: using guessed type int mcafdoc_ac_corr_factor_lf;
// 20003A18: using guessed type int mcafdoc_ac_range_diff;
// 20003A1C: using guessed type int mcafdoc_ac_digits_into_range;
// 20003A20: using guessed type int mcafdoc_ac_amt_digits_into_range;
// 20003A24: using guessed type int mcafdoc_ac_decirange_factor_lf_digits;
// 20003A28: using guessed type int mcafdoc_ac_range_hi;
// 20003A2C: using guessed type int mcafdoc_ac_range_lo;
// 20003A30: using guessed type int mcafdoc_ac_range_lf_hi;
// 20003A34: using guessed type int mcafdoc_ac_range_lf_lo;
// 20003A38: using guessed type int mcafdoc_ac_corr_val_lo;
// 20003A3C: using guessed type int mcafdoc_ac_corr_val_hi;
// 20003A40: using guessed type int mcafdoc_ac_result;
// 20003A44: using guessed type int mcafdoc_corr_val_diff;

//----- (0801C34C) --------------------------------------------------------
signed int __fastcall ac_input_freq_to_hz(unsigned int point, signed int num)
{
  point = (unsigned __int8)point;
  if ( (_BYTE)point )
  {
    if ( point == 2 )
    {
      num /= 10;
    }
    else if ( point >= 2 )
    {
      if ( point == 4 )
        num *= 10;
    }
    else
    {
      num /= 100;
    }
  }
  else
  {
    num /= 1000;
  }
  return num;
}

//----- (0801C384) --------------------------------------------------------
void __cdecl fp_equals(float a, float b)
{
  ;                                             // this function returns Z = 1 if numbers equal
                                                // details are in the assembly
}

//----- (0801C3A0) --------------------------------------------------------
double __fastcall dp_from_fp(float num)
{
  char is_zero_or_inf; // zf@1
  int exp; // r1@1
  double result; // r0@4
  unsigned int v4; // r12@7

  exp = (LODWORD(num) >> 23) & 0xFF;
  is_zero_or_inf = exp == 0;
  if ( exp )
    is_zero_or_inf = exp == 255;
  if ( is_zero_or_inf )
  {
    if ( exp )
    {
      if ( LODWORD(num) << 9 )
        HIDWORD(result) = -1;
      else
        HIDWORD(result) = LODWORD(num) | 0x700000;
      LODWORD(result) = 0;                      // infinity/nan in goes to zero
    }
    else                                        // number is subnormal
    {
      HIDWORD(result) = LODWORD(num) & 0x80000000;
      LODWORD(result) = LODWORD(num) << 8;
      if ( LODWORD(result) )
      {
        v4 = __clz(LODWORD(result));
        LODWORD(result) <<= v4;
        HIDWORD(result) = HIDWORD(result) + 0x38000000 - (v4 << 20) + (LODWORD(result) >> 11);
        LODWORD(result) <<= 21;
      }
    }
  }
  else
  {
    *(_QWORD *)&result = (signed __int64)SLODWORD(num) << 29;
    HIDWORD(result) = (HIDWORD(result) & 0x8FFFFFFF) + 0x38000000;
  }
  return result;
}

//----- (0801C3F0) --------------------------------------------------------
double __fastcall dp_add(double a, double b)
{
  int v2; // r4@3
  unsigned int v3; // r6@3
  unsigned __int8 v4; // cf@5
  int v5; // r4@8
  int v6; // r6@8
  char v7; // r5@10
  int v8; // r6@11
  unsigned int v9; // r3@11
  int v10; // r5@11
  __int64 v11; // r0@13
  int v12; // r5@15
  int v13; // off@17
  int v14; // off@17
  int v15; // r4@29
  unsigned int v16; // r6@30
  unsigned __int8 v17; // cf@31
  int v18; // r4@34
  int v19; // r6@34
  unsigned int v20; // r4@39
  unsigned int v21; // r6@42
  int v22; // r6@41
  unsigned int v23; // off@44
  int v24; // r4@44
  char v25; // zf@44
  unsigned int v26; // r6@44
  unsigned int v27; // off@44
  unsigned int v28; // r6@45
  int v29; // r2@45
  unsigned __int8 v30; // cf@46
  unsigned int v31; // r0@46
  int v32; // r1@46
  char v33; // r5@50
  unsigned int v34; // r6@51
  int v35; // r5@51
  unsigned int v36; // r0@51
  int v37; // r1@51
  int v38; // r5@52
  int v39; // r5@52
  int v40; // r12@52
  int v41; // t0@52
  int v42; // off@55
  unsigned __int8 v43; // cf@58

  if ( (HIDWORD(a) ^ HIDWORD(b)) >= 0 )         // same sign
  {
    v2 = LODWORD(a) - LODWORD(b);
    v3 = (*(_QWORD *)&a - *(_QWORD *)&b) >> 32;
    if ( !__CFADD__(HIDWORD(a), ~HIDWORD(b) + (LODWORD(a) >= LODWORD(b))) )
    {
      *(_QWORD *)&a -= __PAIR__(v3, v2);
      *(_QWORD *)&b += __PAIR__(v3, v2);
    }
    v4 = __CFADD__(2 * HIDWORD(a), 0x200000);
    if ( (unsigned int)(2 * HIDWORD(a)) < 0xFFE00000 )
      v4 = __CFADD__(~(2 * HIDWORD(b)) + __CFSHL__(HIDWORD(b), 1), 0x200000);
    if ( v4 )
    {
      if ( (unsigned int)(2 * HIDWORD(a)) >= 0xFFE00000 || !(LODWORD(b) | 2 * HIDWORD(b)) )
        return a;
      if ( (unsigned int)(2 * HIDWORD(a)) < 0x200000 )
      {
        HIDWORD(b) &= 0x7FFFFFFFu;
        *(_QWORD *)&a += *(_QWORD *)&b;
        return a;
      }
      v5 = HIDWORD(a) >> 20;
      HIDWORD(b) &= 0x7FFFFFFFu;
      v6 = (HIDWORD(a) >> 20) - 1;
      if ( v6 > 52 )
        return a;
    }
    else
    {
      v5 = HIDWORD(a) >> 20;
      v6 = (HIDWORD(a) >> 20) - (HIDWORD(b) >> 20);
      if ( v6 > 53 )
        return a;
      HIDWORD(b) = ((HIDWORD(b) << 11) | 0x80000000) >> 11;
    }
    HIDWORD(a) = (signed int)((HIDWORD(a) << 11) | 0x80000000) >> 11;
    v7 = v6 - 32;
    if ( v6 <= 32 )
    {
      v12 = __ROR4__(LODWORD(b), v6);
      LODWORD(b) >>= v6;
      v10 = v12 ^ LODWORD(b);
      HIDWORD(b) = __ROR4__(HIDWORD(b), v6);
      LODWORD(b) ^= HIDWORD(b);
      HIDWORD(b) = HIDWORD(b) << v6 >> v6;
      LODWORD(b) ^= HIDWORD(b);
      v4 = __CFADD__(__CFADD__(LODWORD(a), LODWORD(b)), HIDWORD(a));
      v11 = *(_QWORD *)&a + LODWORD(b);
      v4 |= __CFADD__(HIDWORD(b), HIDWORD(v11));
      HIDWORD(v11) += HIDWORD(b);
      if ( !v4 )
      {
LABEL_19:
        HIDWORD(v11) += 0x100000;
        *(_QWORD *)&a = __PAIR__(v5 << 20, __CFADD__(v10, (v11 & 1) + 0x7FFFFFFF)) + v11;
        if ( (unsigned int)(2 * HIDWORD(a)) >= 0xFFE00000 )
        {
          LODWORD(a) = 0;
          HIDWORD(a) = HIDWORD(a) >> 20 << 20;
        }
        return a;
      }
    }
    else
    {
      v8 = __ROR4__(HIDWORD(b), v7);
      HIDWORD(b) >>= v7;
      v10 = v8 ^ HIDWORD(b);
      if ( LODWORD(b) )
        v10 |= 1u;
      v4 = __CFADD__(__CFADD__(LODWORD(a), v9), HIDWORD(a));
      v11 = *(_QWORD *)&a + v9;
      if ( !v4 )
        goto LABEL_19;
    }
    HIDWORD(v11) >>= 1;
    v13 = __RCR__(v11, 1);
    LODWORD(v11) = v13;
    v4 = v10 & 1;
    v14 = __RCR__(v10, 1);
    v10 = v14;
    if ( v4 )
      v10 |= 1u;
    goto LABEL_19;
  }
  HIDWORD(b) ^= 0x80000000;
  v15 = LODWORD(a) - LODWORD(b);
  if ( !__CFADD__(HIDWORD(a), ~HIDWORD(b) + (LODWORD(a) >= LODWORD(b))) )
  {
    v16 = ((*(_QWORD *)&a - *(_QWORD *)&b) >> 32) ^ 0x80000000;
    *(_QWORD *)&a -= __PAIR__(v16, v15);
    *(_QWORD *)&b += __PAIR__(v16, v15);
  }
  v17 = __CFADD__(2 * HIDWORD(a), 0x200000);
  if ( (unsigned int)(2 * HIDWORD(a)) < 0xFFE00000 )
    v17 = __CFADD__(~(2 * HIDWORD(b)) + __CFSHL__(HIDWORD(b), 1), 0x200000);
  if ( v17 )
  {
    v43 = __CFADD__(2 * HIDWORD(a), 0x200000);
    if ( (unsigned int)(2 * HIDWORD(a)) >= 0xFFE00000 )
    {
      if ( 2 * HIDWORD(a) == -2097152 )
        v43 = __CFADD__(2 * HIDWORD(b), 0x200000);
      if ( v43 )
        HIDWORD(a) = -1;
      return a;
    }
    HIDWORD(b) &= 0x7FFFFFFFu;
    if ( LODWORD(b) | 2 * HIDWORD(b) )
    {
      if ( (unsigned int)(2 * HIDWORD(a)) >= 0x400000 )
      {
        v18 = HIDWORD(a) >> 20;
        v19 = (HIDWORD(a) >> 20) - 1;
        if ( v19 > 52 )
          return a;
        goto LABEL_50;
      }
      *(_QWORD *)&a -= *(_QWORD *)&b;
    }
    if ( !(LODWORD(a) | 2 * HIDWORD(a)) )
      HIDWORD(a) = 0;
    return a;
  }
  v18 = HIDWORD(a) >> 20;
  v19 = (HIDWORD(a) >> 20) - (HIDWORD(b) >> 20);
  if ( v19 > 54 )
    return a;
  if ( v19 > 1 )
  {
    HIDWORD(b) = ((HIDWORD(b) << 11) | 0x80000000) >> 11;
LABEL_50:
    HIDWORD(a) = ((HIDWORD(a) << 11) | 0x80000000) >> 11;
    v33 = v19 - 32;
    if ( v19 <= 32 )
    {
      v38 = __ROR4__(LODWORD(b), v19);
      LODWORD(b) >>= v19;
      v39 = v38 ^ LODWORD(b);
      v40 = __ROR4__(HIDWORD(b), v19);
      HIDWORD(b) >>= v19;
      LODWORD(b) ^= v40 ^ HIDWORD(b);
      v4 = (unsigned int)v39 <= 0;
      v35 = -v39;
      v41 = v4;
      v4 = __CFADD__(LODWORD(a), ~LODWORD(b) + v4);
      LODWORD(a) -= !v41 + LODWORD(b);
      v37 = HIDWORD(a) - (!v4 + HIDWORD(b));
    }
    else
    {
      LODWORD(b) = (unsigned int)(LODWORD(b) | (LODWORD(b) << 16)) >> 16;
      v34 = HIDWORD(b) << (64 - v19);
      HIDWORD(b) >>= v33;
      v35 = -(LODWORD(b) | v34);
      v4 = __CFADD__(LODWORD(a), ~HIDWORD(b) + ((LODWORD(b) | v34) <= 0));
      LODWORD(a) -= ((LODWORD(b) | v34) > 0) + HIDWORD(b);
      v37 = HIDWORD(a) - !v4;
    }
    if ( !(v37 & 0x100000) )
    {
      --v18;
      if ( v18 << 21 )
      {
        v4 = __CFSHL__(v35, 1);
        v35 *= 2;
        v42 = v4 + v36;
        v4 = __CFADD__(v4, v36) | __CFADD__(v36, v42);
        v36 += v42;
        v37 += v4 + v37;
      }
    }
    *(_QWORD *)&a = __PAIR__(v37 & 0xFFEFFFFF, __CFADD__(v35, (v36 & 1) + 0x7FFFFFFF)) + __PAIR__(v18 << 20, v36);
    return a;
  }
  HIDWORD(b) = (HIDWORD(b) << 11) | 0x80000000 | (LODWORD(b) >> 21);
  if ( v19 == 1 )
  {
    LODWORD(b) <<= 10;
    HIDWORD(b) >>= 1;
  }
  else
  {
    LODWORD(b) <<= 11;
  }
  v20 = v18 << 20;
  *(_QWORD *)&a = __PAIR__((HIDWORD(a) << 11) | 0x80000000 | (LODWORD(a) >> 21), LODWORD(a) << 11) - *(_QWORD *)&b;
  if ( SHIDWORD(a) >= 0 )
  {
    if ( HIDWORD(a) )
    {
      v22 = __clz(HIDWORD(a));
      HIDWORD(a) = (HIDWORD(a) << v22) | (LODWORD(a) >> (32 - v22));
      LODWORD(a) <<= v22;
    }
    else
    {
      v21 = __clz(LODWORD(a));
      HIDWORD(a) = LODWORD(a) << v21;
      if ( !(LODWORD(a) << v21) )
        return a;
      LODWORD(a) = 0;
      v22 = v21 + 32;
    }
    v23 = __ROR4__(v20, 31);
    v4 = v23 >= v22 << 21;
    v24 = v23 - (v22 << 21);
    v26 = v24 & 0xFFFFFFFE;
    v25 = (v24 & 0xFFFFFFFE) == 0;
    v27 = __ROR4__(v24, 1);
    v20 = v27;
    if ( !(!v25 & v4) )
    {
      v28 = (0x200000 - v26) >> 21;
      v20 &= 0x80000000;
      v29 = __ROR4__(HIDWORD(a), v28);
      HIDWORD(a) >>= v28;
      LODWORD(a) = (LODWORD(a) >> v28) ^ v29 ^ HIDWORD(a);
    }
  }
  v30 = __CFSHR__(LODWORD(a), 11);
  LODWORD(a) = *(_QWORD *)&a >> 11;
  v32 = HIDWORD(a) & 0x7FFFFFFF;
  if ( v30 )
    v30 = v31 & 1;
  *(_QWORD *)&a = __PAIR__((unsigned int)v32 >> 11, v30) + __PAIR__(v20, v31);
  return a;
}

//----- (0801C4D8) --------------------------------------------------------
int __fastcall dp_to_int(double num)
{
  unsigned __int8 v1; // cf@1
  double v2; // r0@1
  int v3; // r0@2
  int (__fastcall *v4)(_DWORD); // r12@2
  int result; // r0@4
  int v6; // r0@5
  int (__fastcall *v7)(_DWORD); // r12@5
  int v8; // r0@6

  LODWORD(num) = *(_QWORD *)&num >> 21;
  v1 = __CFSHL__(HIDWORD(num), 1);
  HIDWORD(v2) = 2 * HIDWORD(num);
  if ( v1 )
  {
    v6 = dp_to_int_core(v2);
    if ( (unsigned int)v6 <= 0x80000000 )
      v8 = -v6;
    else
      v8 = 0x80000000;
    result = v7(v8);                            // return v8
  }
  else
  {
    v3 = dp_to_int_core(v2);
    if ( v3 < 0 )
      v3 = 2147483647;
    result = v4(v3);                            // return v3
  }
  return result;
}

//----- (0801C504) --------------------------------------------------------
int __fastcall dp_to_int_core(double a1)
{
  unsigned int v1; // r0@1
  int exp; // r1@1
  int v3; // r1@2
  int result; // r0@3

  LODWORD(a1) |= 0x80000000;
  exp = (HIDWORD(a1) >> 21) - 1023;
  if ( exp < 0 )                                // a fraction
  {
    result = 0;
  }
  else
  {
    v3 = 31 - exp;
    if ( v3 < 0 )
      result = (signed int)v1 >> 31;
    else
      result = v1 >> v3;
  }
  return result;
}

//----- (0801C524) --------------------------------------------------------
double __fastcall dp_div(double a, double b)
{
  int bexp; // r7@0
  unsigned int v3; // r12@1
  unsigned __int8 v4; // cf@1
  char v5; // zf@1
  int aexp; // r4@1
  int v7; // r4@7
  signed __int64 v8; // r0@8
  int v9; // t0@8
  int v10; // r6@10
  unsigned __int64 v11; // kr00_8@10
  signed __int64 v12; // r0@10
  int v13; // t0@10
  int v14; // lr@12
  unsigned __int64 v15; // kr08_8@12
  signed __int64 v16; // r0@12
  int v17; // t0@12
  int v18; // lr@14
  int v19; // r6@14
  unsigned __int64 v20; // kr10_8@14
  signed __int64 v21; // r0@14
  int v22; // t0@14
  int v23; // lr@16
  int v24; // r6@16
  unsigned __int64 v25; // kr18_8@16
  signed __int64 v26; // r0@16
  int v27; // t0@16
  int v28; // r7@18
  unsigned __int64 v29; // kr20_8@18
  int v30; // r0@18
  char v31; // zf@18
  int v32; // r1@18
  int v33; // t0@18
  int v34; // r7@18
  unsigned int v35; // r7@22
  unsigned int v36; // r1@22
  unsigned int v37; // r0@22
  unsigned __int8 v38; // vf@22
  int v39; // r4@22
  unsigned int v40; // r5@26
  int v41; // r0@26
  int v42; // r1@26
  int v43; // r4@26
  char v44; // r6@26
  int v45; // r2@27
  int v46; // r3@27
  __int64 v47; // r0@27
  unsigned __int8 v48; // cf@27
  int v49; // r5@27
  unsigned int v50; // r5@29
  signed __int64 v51; // kr28_8@33
  unsigned int v52; // r3@33
  unsigned int v53; // r7@33
  int v54; // r7@35
  unsigned int v55; // r4@41
  int v56; // r4@43
  char v57; // zf@47
  char v58; // zf@50
  int v59; // r6@50
  unsigned __int8 v60; // cf@59
  char v61; // zf@59

  v3 = (HIDWORD(a) ^ HIDWORD(b)) & 0x80000000;
  v4 = __CFSHR__(HIDWORD(a), 20);
  aexp = (HIDWORD(a) >> 20) & 0x7FF;
  v5 = aexp == 0;
  if ( aexp )
  {
    v4 = __CFSHR__(HIDWORD(b), 20);
    bexp = (HIDWORD(b) >> 20) & 0x7FF;
    v5 = bexp == 0;
  }
  if ( !v5 )
  {
    v4 = (unsigned int)aexp >= 0x7FF;
    v5 = aexp == 2047;
    if ( aexp != 2047 )
    {
      v4 = (unsigned int)bexp >= 0x7FF;
      v5 = bexp == 2047;
    }
  }
  if ( v5 )
  {
    v57 = aexp == 2047;
    if ( aexp != 2047 )
    {
      bexp = (HIDWORD(b) >> 20) & 0x7FF;
      v57 = bexp == 2047;
    }
    if ( v57 )
    {
      LODWORD(a) = 0;
      v60 = __CFADD__(2 * HIDWORD(a), 0x200000);
      v61 = 2 * HIDWORD(a) == -2097152;
      if ( (unsigned int)(2 * HIDWORD(a)) <= 0xFFE00000 )
      {
        v60 = __CFADD__(2 * HIDWORD(b), 0x200000);
        v61 = 2 * HIDWORD(b) == -2097152;
      }
      if ( v61 )
        v60 = __CFADD__(2 * HIDWORD(a), 0x200000);
      if ( v60 )
      {
        HIDWORD(a) = -1;
      }
      else if ( 2 * HIDWORD(b) == -2097152 )
      {
        HIDWORD(a) = (HIDWORD(a) ^ HIDWORD(b)) & 0x80000000;
      }
      else
      {
        HIDWORD(a) = v3 | 0x7FF00000;
      }
      return a;
    }
    v59 = LODWORD(a) | 2 * HIDWORD(a);
    v58 = (LODWORD(a) | 2 * HIDWORD(a)) == 0;
    if ( LODWORD(a) | 2 * HIDWORD(a) )
    {
      v59 = LODWORD(b) | 2 * HIDWORD(b);
      v58 = (LODWORD(b) | 2 * HIDWORD(b)) == 0;
    }
    if ( v58 )
    {
      v5 = (LODWORD(a) | 2 * HIDWORD(a)) == 0;
      *(_QWORD *)&a = __PAIR__(HIDWORD(a) ^ HIDWORD(b), v59) & 0x80000000FFFFFFFFLL;
      if ( v5 )
      {
        if ( !(LODWORD(b) | 2 * HIDWORD(b)) )
          HIDWORD(a) = ~v59;
      }
      else
      {
        HIDWORD(a) = v3 | 0x7FF00000;
      }
      return a;
    }
    if ( bexp )
    {
      v54 = -bexp;
    }
    else
    {
      v51 = 2LL * *(_QWORD *)&b;
      v52 = HIDWORD(b) + (*(_QWORD *)&b >> 31);
      v53 = __clz(v52);
      if ( !v52 )
        v53 += __clz(v51);
      v54 = v53 - 11;
      if ( (unsigned int)v54 < 0x20 )
        HIDWORD(b) = (HIDWORD(b) << v54) | ((unsigned int)v51 >> (32 - v54));
      else
        HIDWORD(b) = (_DWORD)v51 << (v54 - 32);
      LODWORD(b) = (_DWORD)v51 << v54;
      if ( aexp )
      {
        v7 = aexp + v54 - 1;
        goto LABEL_8;
      }
    }
    HIDWORD(a) &= 0x7FFFFFFFu;
    v55 = __clz(HIDWORD(a));
    if ( !HIDWORD(a) )
      v55 += __clz(LODWORD(a));
    v56 = v55 - 11;
    if ( (unsigned int)v56 < 0x20 )
      HIDWORD(a) = (HIDWORD(a) << v56) | (LODWORD(a) >> (32 - v56));
    else
      HIDWORD(a) = LODWORD(a) << (v56 - 32);
    LODWORD(a) <<= v56;
    v7 = v54 - v56;
    goto LABEL_8;
  }
  v7 = aexp - (!v4 + bexp);
LABEL_8:
  HIDWORD(a) &= 0xFFFFFu;
  HIDWORD(b) &= 0xFFFFFu;
  v4 = LODWORD(a) >= LODWORD(b);
  LODWORD(a) -= LODWORD(b);
  v9 = v4;
  v4 = __CFADD__(HIDWORD(a), ~HIDWORD(b) + v4);
  HIDWORD(v8) = HIDWORD(a) - (!v9 + HIDWORD(b));
  HIDWORD(b) |= 0x100000u;
  if ( !v4 )
  {
    --v7;
    v4 = __CFSHL__(v8, 1);
    LODWORD(v8) = 2 * v8;
    HIDWORD(v8) += v4 + HIDWORD(v8);
    v8 += *(_QWORD *)&b;
  }
  HIDWORD(v8) = v8 >> 21;
  v10 = HIDWORD(v8) / HIDWORD(b);
  HIDWORD(v8) -= HIDWORD(b) * (HIDWORD(v8) / HIDWORD(b));
  v11 = LODWORD(b) * (unsigned __int64)(unsigned int)v10;
  v4 = (_DWORD)v8 << 11 >= (unsigned int)v11;
  LODWORD(v8) = ((_DWORD)v8 << 11) - v11;
  v13 = v4;
  v4 = __CFADD__(HIDWORD(v8), ~HIDWORD(v11) + v4);
  HIDWORD(v12) = HIDWORD(v8) - (!v13 + HIDWORD(v11));
  if ( !v4 )
  {
    --v10;
    v12 += *(_QWORD *)&b;
  }
  HIDWORD(v12) = v12 >> 21;
  v14 = HIDWORD(v12) / HIDWORD(b);
  HIDWORD(v12) -= HIDWORD(b) * (HIDWORD(v12) / HIDWORD(b));
  v15 = LODWORD(b) * (unsigned __int64)(unsigned int)v14;
  v4 = (_DWORD)v12 << 11 >= (unsigned int)v15;
  LODWORD(v12) = ((_DWORD)v12 << 11) - v15;
  v17 = v4;
  v4 = __CFADD__(HIDWORD(v12), ~HIDWORD(v15) + v4);
  HIDWORD(v16) = HIDWORD(v12) - (!v17 + HIDWORD(v15));
  if ( !v4 )
  {
    --v14;
    v16 += *(_QWORD *)&b;
  }
  HIDWORD(v16) = v16 >> 22;
  v18 = (v10 << 21) | (v14 << 10);
  v19 = HIDWORD(v16) / HIDWORD(b);
  HIDWORD(v16) -= HIDWORD(b) * (HIDWORD(v16) / HIDWORD(b));
  v20 = LODWORD(b) * (unsigned __int64)(unsigned int)v19;
  v4 = (_DWORD)v16 << 10 >= (unsigned int)v20;
  LODWORD(v16) = ((_DWORD)v16 << 10) - v20;
  v22 = v4;
  v4 = __CFADD__(HIDWORD(v16), ~HIDWORD(v20) + v4);
  HIDWORD(v21) = HIDWORD(v16) - (!v22 + HIDWORD(v20));
  if ( !v4 )
  {
    --v19;
    v21 += *(_QWORD *)&b;
  }
  HIDWORD(v21) = v21 >> 21;
  v23 = v18 | v19;
  v24 = HIDWORD(v21) / HIDWORD(b);
  HIDWORD(v21) -= HIDWORD(b) * (HIDWORD(v21) / HIDWORD(b));
  v25 = LODWORD(b) * (unsigned __int64)(unsigned int)v24;
  v4 = (_DWORD)v21 << 11 >= (unsigned int)v25;
  LODWORD(v21) = ((_DWORD)v21 << 11) - v25;
  v27 = v4;
  v4 = __CFADD__(HIDWORD(v21), ~HIDWORD(v25) + v4);
  HIDWORD(v26) = HIDWORD(v21) - (!v27 + HIDWORD(v25));
  if ( !v4 )
  {
    LOWORD(v24) = v24 - 1;
    v26 += *(_QWORD *)&b;
  }
  HIDWORD(v26) = v26 >> 21;
  v28 = HIDWORD(v26) / HIDWORD(b);
  HIDWORD(v26) -= HIDWORD(b) * (HIDWORD(v26) / HIDWORD(b));
  v29 = LODWORD(b) * (unsigned __int64)(unsigned int)v28;
  v4 = (_DWORD)v26 << 11 >= (unsigned int)v29;
  LODWORD(v26) = ((_DWORD)v26 << 11) - v29;
  v33 = v4;
  v4 = __CFADD__(HIDWORD(v26), ~HIDWORD(v29) + v4);
  v32 = HIDWORD(v26) - (!v33 + HIDWORD(v29));
  v31 = v32 == 0;
  v34 = v28 - !v4;
  if ( !v32 )
    v31 = v30 == 0;
  if ( !v31 )
    v34 |= 1u;
  v35 = v34 & 0xFFC007FF | ((v24 & 0x7FF) << 11);
  v36 = (unsigned int)v23 >> 12;
  v37 = v35 >> 2;
  v38 = __OFADD__(v7, 1024);
  v39 = v7 + 1024;
  if ( (unsigned __int8)((v39 < 0) ^ v38) | (v39 == 0) )
  {
    v40 = v35 << 30 >> 1;
    v41 = v37 | (v23 << 20);
    v42 = v36 | 0x100000;
    v43 = 1 - v39;
    v44 = v43 - 32;
    if ( v43 >= 32 )
    {
      if ( v43 > 52 )
      {
        LODWORD(a) = 0;
        HIDWORD(a) = v3;
        return a;
      }
      v50 = ((v40 | 2 * v41) >> 1) | ((unsigned int)v41 >> v44);
      LODWORD(v47) = (unsigned int)v42 >> v44;
      v48 = __CFSHL__(v42, 64 - v43);
      v49 = v50 | (v42 << (64 - v43));
      HIDWORD(v47) = 0;
    }
    else
    {
      v45 = v41;
      v46 = v42 << (32 - v43);
      HIDWORD(v47) = (unsigned int)v42 >> v43;
      LODWORD(v47) = ((unsigned int)v41 >> v43) | v46;
      v48 = __CFSHL__(v45, 32 - v43);
      v49 = v40 | (v45 << (32 - v43));
    }
    *(_QWORD *)&a = __PAIR__(v3, __CFADD__(v49, v48 + 0x7FFFFFFF)) + v47;
    return a;
  }
  LODWORD(a) = (v23 << 20) + __CFSHL__(v23, 20) + v37;
  HIDWORD(a) += (v39 << 20) + __CFSHL__(v39, 20);
  if ( HIDWORD(a) + 0x100000 < 0 )
  {
    HIDWORD(a) = v3 | 0x7FF00000;
    LODWORD(a) = 0;
  }
  else
  {
    HIDWORD(a) |= v3;
  }
  return a;
}

//----- (0801C76C) --------------------------------------------------------
float __fastcall fp_from_dp(double num)
{
  unsigned int v1; // off@1
  char v2; // cf@1
  signed int v3; // r12@1
  unsigned __int8 v4; // cf@5
  unsigned int v5; // r12@5
  int v6; // off@8
  float result; // r0@8
  int v8; // r1@9
  unsigned int v9; // r1@11
  signed int v10; // r1@14

  v1 = __ROR4__(HIDWORD(num), 31);
  v2 = v1 >= 0x70000000;
  v3 = v1 - 0x70000000;
  if ( v1 >= 0x70000000 )
    v2 = (unsigned int)v3 >= 0x200000;
  if ( v2 )
  {
    v4 = __CFSHL__(v3, 1);
    v5 = 2 * v3;
    if ( !v4 )
      v4 = v5 >= 0x3FC00000;
    if ( v4 )
    {
      v10 = 2 * HIDWORD(num);
      if ( (unsigned int)v10 > 0xFFE00000 )
        LODWORD(result) = v10 >> 31;
      else
        LODWORD(result) = ((v5 << 7) + 255) << 23;
    }
    else
    {
      v6 = __RCR__(16 * (v5 >> 2), 1);
      LODWORD(result) = (LODWORD(num) >> 29) + __CFADD__(8 * LODWORD(num), __CFSHL__(LODWORD(num), 3) + 0x7FFFFFFF) + v6;
    }
  }
  else
  {
    HIDWORD(num) = *(_QWORD *)&num >> 21;
    if ( LODWORD(num) << 11 )
      v8 |= 1u;
    v9 = v8 | 0x80000000;
    if ( (unsigned int)(9 - (v3 >> 21)) >= 33 )
      LODWORD(result) = v3 << 31;
    else
      LODWORD(result) = (((9 - (v3 >> 21)) | (v3 << 31)) & 0x80000000)
                      + __CFADD__(v9 << ((v3 >> 21) + 23), __CFSHL__(v9, (v3 >> 21) + 23) + 0x7FFFFFFF)
                      + (v9 >> (9 - (v3 >> 21)));
  }
  return result;
}

//----- (0801C7FC) --------------------------------------------------------
void __fastcall reset_adc(ADC_REGS *adc)
{
  if ( adc == &ADC1_BASE )
  {
    reset_apb2_periph(0x200, 1);                // adc1
    reset_apb2_periph(0x200, 0);
  }
}
// 40012400: using guessed type ADC_REGS ADC1_BASE;

//----- (0801C81C) --------------------------------------------------------
void __fastcall do_lots_of_adc_config(ADC_REGS *adc, _BYTE *chan)
{
  adc->ADC_CR1 = adc->ADC_CR1 & 0xFCFFFEFF | *(_DWORD *)chan | (chan[4] << 8);
  adc->ADC_CR2 = adc->ADC_CR2 & 0xC0FFF7FD | *((_DWORD *)chan + 4) | *((_DWORD *)chan + 3) | *((_DWORD *)chan + 2) | 2 * chan[5];
  adc->ADC_SQR1 = adc->ADC_SQR1 & 0xFE0FFFFF | ((unsigned __int8)(chan[20] - 1) << 20);
}

//----- (0801C86C) --------------------------------------------------------
void __fastcall enable_adc(ADC_REGS *adc, char enable)
{
  if ( enable )
    adc->ADC_CR2 |= 1u;
  else
    adc->ADC_CR2 = 2 * ((unsigned int)adc->ADC_CR2 >> 1);
}

//----- (0801C894) --------------------------------------------------------
int __fastcall sub_801C894(int result, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  if ( (signed int)a2 < 30 )
  {
    if ( (signed int)a2 < 20 )
    {
      if ( (signed int)a2 < 10 )
        *(_DWORD *)(result + 20) = *(_DWORD *)(result + 20) & ~(7 << 3 * a2) | (a4 << 3 * a2);
      else
        *(_DWORD *)(result + 16) = *(_DWORD *)(result + 16) & ~(7 << 3 * (a2 - 10)) | (a4 << 3 * (a2 - 10));
    }
    else
    {
      *(_DWORD *)(result + 12) = *(_DWORD *)(result + 12) & ~(7 << 3 * (a2 - 20)) | (a4 << 3 * (a2 - 20));
    }
  }
  else
  {
    *(_DWORD *)(result + 92) = *(_DWORD *)(result + 92) & ~(7 << 3 * (a2 - 30)) | (a4 << 3 * (a2 - 30));
  }
  if ( (signed int)a3 >= 7 )
  {
    if ( (signed int)a3 >= 13 )
    {
      if ( (signed int)a3 >= 19 )
      {
        if ( (signed int)a3 >= 25 )
          *(_DWORD *)(result + 48) = *(_DWORD *)(result + 48) & ~(31 << 5 * (a3 - 25)) | (a2 << 5 * (a3 - 25));
        else
          *(_DWORD *)(result + 52) = *(_DWORD *)(result + 52) & ~(31 << 5 * (a3 - 19)) | (a2 << 5 * (a3 - 19));
      }
      else
      {
        *(_DWORD *)(result + 56) = *(_DWORD *)(result + 56) & ~(31 << 5 * (a3 - 13)) | (a2 << 5 * (a3 - 13));
      }
    }
    else
    {
      *(_DWORD *)(result + 60) = *(_DWORD *)(result + 60) & ~(31 << 5 * (a3 - 7)) | (a2 << 5 * (a3 - 7));
    }
  }
  else
  {
    *(_DWORD *)(result + 64) = *(_DWORD *)(result + 64) & ~(31 << 5 * (a3 - 1)) | (a2 << 5 * (a3 - 1));
  }
  return result;
}

//----- (0801CA52) --------------------------------------------------------
void __fastcall sub_801CA52(int result)
{
  *(_DWORD *)(result + 8) |= 0x40000000u;
}

//----- (0801CA5C) --------------------------------------------------------
int __fastcall sub_801CA5C(int a1)
{
  return (unsigned __int16)*(_DWORD *)(a1 + 88);
}

//----- (0801CA62) --------------------------------------------------------
bool __fastcall and_bool_low16(int a1, unsigned __int16 a2)
{
  return (*(_DWORD *)a1 & a2) != 0;
}

//----- (0801CA7C) --------------------------------------------------------
int __fastcall sub_801CA7C(int a1, unsigned __int16 a2)
{
  int result; // r0@3

  LOBYTE(result) = *(_DWORD *)a1 & ((unsigned int)a2 >> 8) && *(_DWORD *)(a1 + 4) & (1 << a2);
  return (unsigned __int8)result;
}

//----- (0801CAB0) --------------------------------------------------------
int __fastcall sub_801CAB0(int result, __int16 a2)
{
  *(_DWORD *)result = ~HIBYTE(a2);
  return result;
}

//----- (0801CAC0) --------------------------------------------------------
double __fastcall dp_mul(double a, double b)
{
  int bexp; // r7@0
  unsigned int output_negative; // r12@1
  char v4; // zf@1
  int aexp; // r4@1
  int v6; // r4@7
  unsigned int v7; // lr@8
  unsigned int v8; // r7@8
  int v9; // kr08_4@9
  unsigned int v10; // r0@9
  unsigned int v11; // r1@9
  unsigned int v12; // r2@9
  unsigned __int64 v13; // r0@11
  int v14; // r4@11
  unsigned __int8 v15; // cf@11
  int v16; // off@12
  int v17; // off@12
  unsigned __int8 v18; // vf@13
  int v19; // r4@13
  char v20; // nf@14
  int bexp_1; // r7@17
  char v22; // zf@17
  char v23; // zf@20
  int v24; // r4@26
  int v25; // lr@28
  unsigned int v26; // r7@31
  int v27; // lr@31
  unsigned int v28; // r7@32
  int v29; // r7@34
  int v30; // r4@34
  char v31; // zf@38
  unsigned __int8 v32; // cf@42
  char v33; // zf@42
  int v34; // r4@47
  char v35; // r7@47
  char v36; // r7@48
  unsigned int v37; // r2@48
  unsigned __int8 v38; // cf@50
  int v39; // r2@50
  __int64 v40; // r0@50
  char v41; // r4@52
  unsigned int v42; // r2@52

  output_negative = (HIDWORD(a) ^ HIDWORD(b)) & 0x80000000;
  aexp = (HIDWORD(a) >> 20) & 0x7FF;
  v4 = aexp == 0;
  if ( aexp )
  {
    bexp = (HIDWORD(b) >> 20) & 0x7FF;
    v4 = bexp == 0;
  }
  if ( !v4 )
  {
    v4 = aexp == 2047;
    if ( aexp != 2047 )
      v4 = bexp == 2047;
  }
  if ( !v4 )
  {
    v6 = aexp + bexp;
    HIDWORD(b) = HIDWORD(b) & 0x1FFFFF | 0x100000;
    goto LABEL_8;
  }
  bexp_1 = (HIDWORD(b) >> 20) & 0x7FF;
  v22 = aexp == 2047;
  if ( aexp != 2047 )
    v22 = bexp_1 == 2047;
  if ( !v22 )
  {
    v23 = (LODWORD(a) | 2 * HIDWORD(a)) == 0;
    if ( LODWORD(a) | 2 * HIDWORD(a) )
      v23 = (LODWORD(b) | 2 * HIDWORD(b)) == 0;
    if ( v23 )
      goto LABEL_24;
    v4 = aexp == 0;
    v24 = aexp + bexp_1;
    if ( v4 )
    {
      v25 = (HIDWORD(b) >> 20) & 0x7FF;
      if ( !bexp_1 )
        goto LABEL_24;
      HIDWORD(a) <<= 12;
      if ( !HIDWORD(a) )
      {
        HIDWORD(a) = LODWORD(a);
        LODWORD(a) = 0;
        v25 = bexp_1 - 20;
      }
      v26 = __clz(HIDWORD(a));
      v6 = v25 - v26;
      v27 = HIDWORD(a) << v26;
      LOBYTE(v26) = v26 + 12;
      BYTE4(a) = 32 - v26;
      v8 = LODWORD(a) << v26;
      v7 = v27 | (LODWORD(a) >> SBYTE4(a));
      HIDWORD(b) = HIDWORD(b) & 0x1FFFFF | 0x100000;
LABEL_9:
      v9 = v8 * LODWORD(b);
      v10 = (v7 * (unsigned __int64)LODWORD(b) + (unsigned int)(v8 * (unsigned __int64)LODWORD(b) >> 32)) >> 32;
      v11 = (HIDWORD(b) * (unsigned __int64)v8
           + (unsigned int)(v7 * LODWORD(b) + (v8 * (unsigned __int64)LODWORD(b) >> 32))) >> 32;
      v12 = HIDWORD(b) * v8 + v7 * LODWORD(b) + (v8 * (unsigned __int64)LODWORD(b) >> 32);
      if ( v9 )
        v12 |= 1u;
      v13 = HIDWORD(b) * (unsigned __int64)v7 + v10 + (unsigned __int64)v11;
      v14 = v6 - 1024;
      v15 = __CFSHL__(HIDWORD(v13), 12);
      if ( !__CFSHL__(HIDWORD(v13), 12) )
      {
        v15 = __CFSHL__(v12, 1);
        v12 *= 2;
        v16 = v15 + (_DWORD)v13;
        v15 = __CFADD__(v15, (_DWORD)v13) | __CFADD__((_DWORD)v13, v16);
        LODWORD(v13) = v13 + v16;
        v17 = v15 + HIDWORD(v13);
        v15 = __CFADD__(v15, HIDWORD(v13)) | __CFADD__(HIDWORD(v13), v17);
        HIDWORD(v13) += v17;
      }
      v18 = __OFADD__(v15, v14);
      v19 = v15 + v14;
      v18 |= __OFADD__(1, v19++);
      if ( !((unsigned __int8)((v19 < 0) ^ v18) | (v19 == 0)) )
      {
        LODWORD(a) = __CFADD__(v12, (v13 & 1) + 0x7FFFFFFF) + (_DWORD)v13;
        HIDWORD(a) += (v19 << 20) + __CFSHL__(v19, 20);
        v20 = SHIDWORD(a) < 0;
        HIDWORD(a) -= 0x100000;
        if ( v20 )
        {
          HIDWORD(a) = output_negative | 0x7FF00000;
          LODWORD(a) = 0;
        }
        else
        {
          HIDWORD(a) |= output_negative;
        }
        return a;
      }
      v34 = 1 - v19;
      v35 = v34 - 32;
      if ( v34 < 32 )
      {
        v36 = 32 - v34;
        v15 = v12 & 1;
        v37 = v12 >> 1;
        if ( v15 )
          v37 |= 1u;
        v38 = __CFSHL__(v13, v36);
        v39 = v37 | ((_DWORD)v13 << v36);
        LODWORD(v13) = ((unsigned int)v13 >> v34) | (HIDWORD(v13) << v36);
        HIDWORD(v40) = HIDWORD(v13) >> v34;
LABEL_55:
        *(_QWORD *)&a = __PAIR__(output_negative, __CFADD__(v39, v38 + 0x7FFFFFFF)) + v40;
        return a;
      }
      if ( v34 <= 53 )
      {
        v41 = 64 - v34;
        v4 = (v12 | 2 * (_DWORD)v13) == 0;
        v42 = (unsigned int)v13 >> v35;
        if ( !v4 )
          v42 |= 1u;
        LODWORD(v13) = HIDWORD(v13) >> v35;
        v38 = __CFSHL__(HIDWORD(v13), v41);
        v39 = v42 | (HIDWORD(v13) << v41);
        HIDWORD(v40) = 0;
        goto LABEL_55;
      }
LABEL_24:
      HIDWORD(a) = output_negative;
      LODWORD(a) = 0;
      return a;
    }
    HIDWORD(b) &= 0x7FFFFFFFu;
    v28 = __clz(HIDWORD(b));
    if ( !HIDWORD(b) )
      v28 += __clz(LODWORD(b));
    v29 = v28 - 11;
    v30 = v24 - v29;
    if ( (unsigned int)v29 < 0x20 )
      HIDWORD(b) = (HIDWORD(b) << v29) | (LODWORD(b) >> (32 - v29));
    else
      HIDWORD(b) = LODWORD(b) << (v29 - 32);
    LODWORD(b) <<= v29;
    v6 = v30 + 1;
LABEL_8:
    v7 = (HIDWORD(a) << 11) | 0x80000000 | (LODWORD(a) >> 21);
    v8 = LODWORD(a) << 11;
    goto LABEL_9;
  }
  v31 = (LODWORD(a) | 2 * HIDWORD(a)) == 0;
  if ( LODWORD(a) | 2 * HIDWORD(a) )
    v31 = (LODWORD(b) | 2 * HIDWORD(b)) == 0;
  if ( v31 )
    HIDWORD(a) = -1;
  v32 = __CFADD__(2 * HIDWORD(b), 0x200000);
  v33 = 2 * HIDWORD(b) == -2097152;
  if ( (unsigned int)(2 * HIDWORD(b)) <= 0xFFE00000 )
  {
    v32 = __CFADD__(2 * HIDWORD(a), 0x200000);
    v33 = 2 * HIDWORD(a) == -2097152;
  }
  else
  {
    HIDWORD(a) = HIDWORD(b);
  }
  if ( !(!v33 & v32) )
  {
    HIDWORD(a) = output_negative | 0x7FF00000;
    LODWORD(a) = 0;
  }
  return a;
}

//----- (0801CC64) --------------------------------------------------------
float __fastcall fp_add(float a, float b)
{
  int v2; // r2@3
  int aexp; // r2@5
  int bexp; // r3@6
  unsigned int bsig; // r1@8
  unsigned int v6; // r1@9
  int endexp; // r2@9
  unsigned int asig; // r0@9
  unsigned __int8 v9; // cf@9
  unsigned int v10; // r0@9
  unsigned int v11; // r0@10
  char v12; // zf@15

  if ( (LODWORD(a) ^ LODWORD(b)) < 0 )          // signs are different
    JUMPOUT(&loc_801CCF8);
  v2 = LODWORD(a) - LODWORD(b);                 // make a the bigger number
  if ( LODWORD(a) < LODWORD(b) )
  {
    LODWORD(a) -= v2;
    LODWORD(b) += v2;
  }
  aexp = (LODWORD(a) >> 23) & 0xFF;
  if ( aexp != 255 )
  {
    bexp = (LODWORD(b) >> 23) & 0xFF;
    if ( bexp )
    {
      aexp -= bexp;
      if ( aexp >= 25 )
        return a;
      bsig = (LODWORD(b) << 8) | 0x80000000;
    }
    else
    {
      bsig = LODWORD(b) << 9;
      v12 = bsig == 0;
      if ( bsig )
        v12 = aexp == 0;
      if ( v12 )
      {
        LODWORD(a) += bsig >> 9;
        return a;
      }
      if ( 23 - aexp < 0 )
        return a;
    }
    v6 = bsig >> aexp;
    endexp = LODWORD(a) >> 23;
    asig = (LODWORD(a) << 8) | 0x80000000;
    v9 = __CFADD__(asig, v6);
    v10 = asig + v6;
    if ( v9 )
      v11 = (v10 >> 1) | 0x80000000;
    else
      v11 = v10 & 0x7FFFFFFF;
    LODWORD(a) = (v11 >> 8) + __CFSHR__(v11, 8) + (endexp << 23);
    if ( (unsigned int)(2 * LODWORD(a)) >= 0xFF000000 )
      LODWORD(a) = LODWORD(a) >> 23 << 23;
  }
  return a;
}

//----- (0801CCE8) --------------------------------------------------------
float __fastcall fp_sub(float a, float b)
{
  unsigned int v2; // r3@4
  int aexp; // r12@5
  unsigned __int8 v4; // cf@5
  unsigned __int8 v5; // cf@8
  char v6; // zf@8
  int v7; // r3@8
  unsigned int bexp; // r1@10
  int v9; // r0@11
  unsigned __int8 v10; // cf@13
  unsigned int v11; // r0@13
  unsigned int v12; // r2@18
  unsigned int v13; // r0@18
  int v14; // off@18
  int v15; // r3@18
  int v16; // off@19
  unsigned int v17; // r2@23
  unsigned int v18; // r0@25

  if ( (LODWORD(a) ^ LODWORD(b)) < 0 )          // signs are different
    JUMPOUT(&loc_801CC74);
  if ( LODWORD(a) < LODWORD(b) )
  {
    v2 = (LODWORD(a) - LODWORD(b)) ^ 0x80000000;
    LODWORD(a) -= v2;
    LODWORD(b) += v2;
  }
  aexp = LODWORD(a) >> 23;
  v4 = __CFADD__(2 * LODWORD(a), 0x1000000);
  if ( (unsigned int)(2 * LODWORD(a)) < 0xFF000000 )
    v4 = (unsigned int)(2 * LODWORD(b)) <= 0x1000000;
  if ( v4 )
  {
    if ( (unsigned int)(2 * LODWORD(a)) >= 0xFF000000 )
    {
      if ( (unsigned int)(2 * LODWORD(b)) >= 0xFF000000 )
        a = -6.8056e38/*NaN*/;
      return a;
    }
    if ( 2 * LODWORD(b) )
    {
      v7 = aexp - (LODWORD(b) >> 23);
      if ( v7 >= 2 )
      {
        bexp = LODWORD(b) << 9;
        if ( v7 > 23 )
          return a;
        goto LABEL_23;
      }
      LODWORD(a) -= LODWORD(b) & 0x7FFFFFFF;
    }
    if ( !(2 * LODWORD(a)) )
      a = 0.0;
    return a;
  }
  v5 = __CFADD__(aexp, ~(LODWORD(b) >> 23) + __CFSHR__(LODWORD(b), 23));
  v7 = aexp - (!__CFSHR__(LODWORD(b), 23) + (LODWORD(b) >> 23));
  v6 = aexp == !__CFSHR__(LODWORD(b), 23) + (LODWORD(b) >> 23);
  if ( !__CFADD__(aexp, ~(LODWORD(b) >> 23) + __CFSHR__(LODWORD(b), 23)) )
  {
    LODWORD(a) -= LODWORD(b);
    if ( a == 0.0 )
      return a;
    v9 = LODWORD(a) << 9;
    goto LABEL_18;
  }
  bexp = (LODWORD(b) << 8) | 0x80000000;
  if ( !v6 & v5 )
  {
    if ( v7 > 24 )
      return a;
LABEL_23:
    v17 = bexp >> v7;
    if ( bexp >> v7 << v7 < bexp )
      v17 |= 1u;
    v4 = LODWORD(a) << 9 >= v17;
    v18 = (LODWORD(a) << 9) - v17;
    if ( !v4 )
    {
      v18 *= 2;
      --aexp;
    }
    LODWORD(a) = (v18 >> 9) + __CFADD__(v18 << 23, __CFSHL__(v18, 23) + 0x7FFFFFFF) + (aexp << 23);
    return a;
  }
  v4 = LODWORD(a) << 9 >= bexp;
  v9 = (LODWORD(a) << 9) - bexp;
  if ( !v4 )
  {
LABEL_18:
    v12 = __clz(v9) + 1;
    v13 = (unsigned int)(v9 << v12) >> 9;
    v14 = __ROR4__(aexp, 8);
    v15 = v14 - (v12 << 24);
    if ( v14 <= v12 << 24 )
    {
      LODWORD(a) = ((v13 | 0x800000) >> (1 - BYTE3(v15))) | (v15 << 31);
    }
    else
    {
      v16 = __ROR4__(v15, 1);
      LODWORD(a) = v13 + v16;
    }
    return a;
  }
  v10 = __CFSHR__(v9, 9);
  v11 = (unsigned int)v9 >> 9;
  if ( v10 )
    v10 = v11 & 1;
  LODWORD(a) = (aexp << 23) + v10 + v11;
  return a;
}

//----- (0801CDD0) --------------------------------------------------------
void __fastcall set_rtc_rcc_csr_access(unsigned __int8 enabled)
{
  v420E0020 = enabled;
}

//----- (0801CDD8) --------------------------------------------------------
void __fastcall set_PWR_voltage_detector_enable(int result)
{
  v420E0010 = (unsigned __int8)result;
}

//----- (0801CDE0) --------------------------------------------------------
void __fastcall set_PWR_Vrefint_off_in_low_power_mode(int result)
{
  v420E0024 = (unsigned __int8)result;
}

//----- (0801CDE8) --------------------------------------------------------
void __fastcall set_most_pwr_cr_bits(int result)
{
  PWR_CR = (PWR_CR & 0xFFFFE7FF | result) & 0xFFFFFFF3;
}
// 40007000: using guessed type int PWR_CR;

//----- (0801CE00) --------------------------------------------------------
void __fastcall WFI_or_WFE(int result, char a2)
{
  PWR_CR = 4 * ((unsigned int)PWR_CR >> 2) | result;
  dword_E000ED10 |= 4u;
  if ( a2 == 1 )
    __wfi();
  else
    __wfe();
  dword_E000ED10 &= 0xFFFFFFFB;
}
// 40007000: using guessed type int PWR_CR;
// E000ED10: using guessed type int dword_E000ED10;

//----- (0801CE3C) --------------------------------------------------------
bool __fastcall test_pwr_csr_bits(int mask)
{
  return (PWR_CSR & mask) != 0;
}
// 40007004: using guessed type int PWR_CSR;

//----- (0801CE56) --------------------------------------------------------
void __fastcall set_pwr_cr_bits_offset(int mask)
{
  PWR_CR |= 4 * mask;
}
// 40007000: using guessed type int PWR_CR;

//----- (0801CE7C) --------------------------------------------------------
void __fastcall sub_801CE7C(int result, char a2)
{
  if ( a2 )
    vE0042004 |= result;
  else
    vE0042004 &= ~result;
}

//----- (0801CEA0) --------------------------------------------------------
void __fastcall set_SCB_AIRCR(int result)
{
  dword_E000ED0C = result | 0x5FA0000;
}

//----- (0801CEAA) --------------------------------------------------------
int __fastcall sub_801CEAA(int result)
{
  if ( *(_BYTE *)(result + 3) )
  {
    *(_BYTE *)(*(_BYTE *)result - 536812544) = 16
                                             * ((*(_BYTE *)(result + 1) << (4
                                                                          - ((unsigned __int16)(1792
                                                                                              - (dword_E000ED0C & 0x700)) >> 8))) | *(_BYTE *)(result + 2) & (15 >> ((unsigned __int16)(1792 - (dword_E000ED0C & 0x700)) >> 8)));
    *(_DWORD *)(4 * ((signed int)*(_BYTE *)result >> 5) - 536813312) = 1 << (*(_BYTE *)result & 0x1F);
  }
  else
  {
    *(_DWORD *)(4 * ((signed int)*(_BYTE *)result >> 5) - 536813184) = 1 << (*(_BYTE *)result & 0x1F);
  }
  return result;
}

//----- (0801CF14) --------------------------------------------------------
void __fastcall set_vtor_offset(int base, int offset)
{
  SCB_VTOR = offset & 0x1FFFFF80 | base;
}
// E000ED08: using guessed type int SCB_VTOR;

//----- (0801CF3C) --------------------------------------------------------
void __fastcall TIM_Base_SetConfig(void *TIM, int *a2)
{
  int v2; // r2@1

  LOWORD(v2) = *(_WORD *)TIM;
  if ( TIM == &TIM2_0 || TIM == &TIM3 || TIM == (void *)0x40000800 || TIM == (void *)0x40000C00 )
    v2 = (unsigned __int16)(v2 & 0xFF8F) | *((_WORD *)a2 + 1);
  if ( TIM != (void *)0x40001000 && TIM != (void *)0x40001400 )
    v2 = (unsigned __int16)(v2 & 0xFCFF) | *((_WORD *)a2 + 4);
  *(_WORD *)TIM = v2;
  *((_DWORD *)TIM + 11) = a2[1];
  *((_WORD *)TIM + 20) = *(_WORD *)a2;
  *((_WORD *)TIM + 10) = 1;
}

//----- (0801CFA0) --------------------------------------------------------
void __fastcall set_timer_enable(void *TIM, char enable)
{
  if ( enable )
    *(_WORD *)TIM |= 1u;
  else
    *(_WORD *)TIM &= 0xFFFEu;
}

//----- (0801CFBC) --------------------------------------------------------
int __fastcall sub_801CFBC(int result, __int16 a2, char a3)
{
  if ( a3 )
    *(_WORD *)(result + 12) |= a2;
  else
    *(_WORD *)(result + 12) &= ~a2;
  return result;
}

//----- (0801CFD2) --------------------------------------------------------
void __fastcall TIM_clear_status_bits(void *TIM, __int16 mask)
{
  *((_WORD *)TIM + 8) = ~mask;
}

//----- (0801CFDC) --------------------------------------------------------
void __fastcall apo_something_with_rtc(int result, char a2)
{
  rtc_dword_40002824_unused = 83;
  if ( a2 )
  {
    rtc_dword_40002808 |= result & 0xFFFFFFFB;
    rtc_dword_40002840 |= result & 4;
  }
  else
  {
    rtc_dword_40002808 &= ~(result & 0xFFFFFFFB);
    rtc_dword_40002840 &= ~(result & 4);
  }
  rtc_dword_40002824_unused = 255;
}
// 40002808: using guessed type int rtc_dword_40002808;
// 40002824: using guessed type int rtc_dword_40002824_unused;
// 40002840: using guessed type int rtc_dword_40002840;

//----- (0801D030) --------------------------------------------------------
int __fastcall sub_801D030(unsigned int a1)
{
  int result; // r0@3

  LOBYTE(result) = rtc_dword_40002808 & a1 | rtc_dword_40002840 & 4 & (a1 >> (a1 >> 18) >> 15)
                && (dword_4000280C[0] & (a1 >> 4)) << 16;
  return (unsigned __int8)result;
}
// 40002808: using guessed type int rtc_dword_40002808;
// 40002840: using guessed type int rtc_dword_40002840;

//----- (0801D07A) --------------------------------------------------------
unsigned int __fastcall sub_801D07A(unsigned int result)
{
  _R2 = (unsigned __int16)(result >> 4) | 0x80;
  _R3 = dword_4000280C[0] & 0x80;
  __asm { ORNS.W  R2, R3, R2 }
  dword_4000280C[0] = _R2;
  return result;
}

//----- (0801D0A8) --------------------------------------------------------
int __fastcall sub_801D0A8(int result, unsigned __int8 a2)
{
  *(_DWORD *)(4 * ((signed int)a2 >> 2) + 0x40010008) &= ~(15 << 4 * (a2 & 3));
  result = (unsigned __int8)result;
  *(_DWORD *)(4 * ((signed int)a2 >> 2) + 0x40010008) |= (unsigned __int8)result << 4 * (a2 & 3);
  return result;
}

//----- (0801D0FC) --------------------------------------------------------
int __fastcall sub_801D0FC(int result)
{
  if ( *(_BYTE *)(result + 6) )
  {
    EXTI_IMR &= ~*(_DWORD *)result;
    EXTI_EMR &= ~*(_DWORD *)result;
    *(int *)((char *)&EXTI_IMR + *(_BYTE *)(result + 4)) |= *(_DWORD *)result;
    EXTI_RTSR &= ~*(_DWORD *)result;
    EXTI_FTSR &= ~*(_DWORD *)result;
    if ( *(_BYTE *)(result + 5) == 16 )
    {
      EXTI_RTSR |= *(_DWORD *)result;
      EXTI_FTSR |= *(_DWORD *)result;
    }
    else
    {
      *(int *)((char *)&EXTI_IMR + *(_BYTE *)(result + 5)) |= *(_DWORD *)result;
    }
  }
  else
  {
    *(int *)((char *)&EXTI_IMR + *(_BYTE *)(result + 4)) &= ~*(_DWORD *)result;
  }
  return result;
}
// 40010400: using guessed type int EXTI_IMR;
// 40010404: using guessed type int EXTI_EMR;
// 40010408: using guessed type int EXTI_RTSR;
// 4001040C: using guessed type int EXTI_FTSR;

//----- (0801D184) --------------------------------------------------------
bool __fastcall exti_int_pending(int mask)
{
  return (EXTI_PR & mask) != 0;
}
// 40010414: using guessed type int EXTI_PR;

//----- (0801D19E) --------------------------------------------------------
void __fastcall exti_ack_int(int mask)
{
  EXTI_PR = mask;
}
// 40010414: using guessed type int EXTI_PR;

//----- (0801D1B8) --------------------------------------------------------
void __fastcall memcpy(void *dest, void *src, int len)
{
  void *v3; // r3@1
  void *v4; // r4@1
  int v5; // r5@2

  v3 = dest;
  v4 = src;
  while ( 1 )
  {
    v5 = len--;
    if ( !v5 )
      break;
    *(_BYTE *)v3 = *(_BYTE *)v4;
    v4 = (char *)v4 + 1;
    v3 = (char *)v3 + 1;
  }
}

//----- (0801D1D4) --------------------------------------------------------
void __fastcall memset(void *mem, char val, int len)
{
  void *i; // r3@1
  int v4; // r4@2

  for ( i = mem; ; i = (char *)i + 1 )
  {
    v4 = len--;
    if ( !v4 )
      break;
    *(_BYTE *)i = val;
  }
}

//----- (0801D1EA) --------------------------------------------------------
int __fastcall memcmp(char *dst, char *src, int len)
{
  char *v3; // r4@1
  char *v4; // r5@1
  int result; // r0@1
  int v6; // r6@2

  v3 = dst;
  v4 = src;
  result = 0;
  do
  {
    v6 = len--;
    if ( !v6 )
      break;
    result = (unsigned __int8)*v3++ - (unsigned __int8)*v4++;
  }
  while ( !result );
  return result;
}

//----- (0801D20E) --------------------------------------------------------
char __fastcall chr_in_str(char *str, char chr)
{
  while ( *str && (unsigned __int8)*str != chr )
    ++str;
  return *str;
}

//----- (0801D222) --------------------------------------------------------
signed int __fastcall sub_801D222(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r5@1
  int v4; // r6@1
  unsigned __int8 i; // r7@6

  v2 = a1;
  v3 = a2;
  v4 = *(_DWORD *)(a1 + 44);
  if ( v4 != a2 )
  {
    if ( *(_BYTE *)(a1 + 4) )
    {
      if ( prob_write_sd_blocks(*(_BYTE *)(a1 + 1), a1 + 48, v4, 1u) )
        return 1;
      *(_BYTE *)(v2 + 4) = 0;
      if ( v4 < (unsigned int)(*(_DWORD *)(v2 + 28) + *(_DWORD *)(v2 + 32)) )
      {
        for ( i = *(_BYTE *)(v2 + 3); (signed int)i >= 2; --i )
        {
          v4 += *(_DWORD *)(v2 + 28);
          prob_write_sd_blocks(*(_BYTE *)(v2 + 1), v2 + 48, v4, 1u);
        }
      }
    }
    if ( v3 )
    {
      if ( sub_80207E6(*(_BYTE *)(v2 + 1), v2 + 48, v3) )
        return 1;
      *(_DWORD *)(v2 + 44) = v3;
    }
  }
  return 0;
}

//----- (0801D29A) --------------------------------------------------------
int __fastcall prob_sd_init_partition_table(int a1)
{
  int v1; // r4@1
  char v2; // r5@1

  v1 = a1;
  v2 = sub_801D222(a1, 0);
  if ( !v2 )
  {
    if ( *(_BYTE *)v1 == 3 && *(_BYTE *)(v1 + 5) )
    {
      *(_DWORD *)(v1 + 44) = 0;
      memset((void *)(v1 + 48), 0, 512);
      *(_BYTE *)(v1 + 558) = 0x55;
      *(_BYTE *)(v1 + 559) = 0xAAu;
      *(_BYTE *)(v1 + 48) = 82;
      *(_BYTE *)(v1 + 49) = 82;
      *(_BYTE *)(v1 + 50) = 97;
      *(_BYTE *)(v1 + 51) = 65;
      *(_BYTE *)(v1 + 532) = 114;
      *(_BYTE *)(v1 + 533) = 114;
      *(_BYTE *)(v1 + 534) = 65;
      *(_BYTE *)(v1 + 535) = 97;
      *(_BYTE *)(v1 + 536) = *(_DWORD *)(v1 + 16);
      *(_BYTE *)(v1 + 537) = (unsigned __int16)*(_DWORD *)(v1 + 16) >> 8;
      *(_BYTE *)(v1 + 538) = *(_DWORD *)(v1 + 16) >> 16;
      *(_BYTE *)(v1 + 539) = *(_DWORD *)(v1 + 16) >> 24;
      *(_BYTE *)(v1 + 540) = *(_DWORD *)(v1 + 12);
      *(_BYTE *)(v1 + 541) = (unsigned __int16)*(_DWORD *)(v1 + 12) >> 8;
      *(_BYTE *)(v1 + 542) = *(_DWORD *)(v1 + 12) >> 16;
      *(_BYTE *)(v1 + 543) = *(_DWORD *)(v1 + 12) >> 24;
      prob_write_sd_blocks(*(_BYTE *)(v1 + 1), v1 + 48, *(_DWORD *)(v1 + 20), 1u);
      *(_BYTE *)(v1 + 5) = 0;
    }
    if ( sub_802089C(*(_BYTE *)(v1 + 1), 0, 0) )
      v2 = 1;
  }
  return (unsigned __int8)v2;
}

//----- (0801D372) --------------------------------------------------------
int __fastcall sub_801D372(int a1, int a2)
{
  int v2; // r1@1
  int result; // r0@2

  v2 = a2 - 2;
  if ( v2 < (unsigned int)(*(_DWORD *)(a1 + 24) - 2) )
    result = *(_DWORD *)(a1 + 40) + *(_BYTE *)(a1 + 2) * v2;
  else
    result = 0;
  return result;
}

//----- (0801D38C) --------------------------------------------------------
signed int __fastcall sub_801D38C(int a1, unsigned int a2)
{
  int v2; // r4@1
  unsigned int v3; // r5@1
  signed int result; // r0@3
  unsigned int v5; // r0@4
  unsigned int v6; // r8@9
  int v7; // r6@10
  unsigned int v8; // r8@10
  int v9; // r6@11

  v2 = a1;
  v3 = a2;
  if ( a2 < 2 || a2 >= *(_DWORD *)(a1 + 24) )
    return 1;
  v5 = *(_BYTE *)a1;
  if ( v5 != 1 )
  {
    if ( v5 >= 1 )
    {
      if ( v5 == 3 )
      {
        if ( !sub_801D222(v2, *(_DWORD *)(v2 + 32) + (a2 >> 7)) )
          return ((*(_BYTE *)(4 * v3 % 0x200 + v2 + 50) << 16) | (*(_BYTE *)(4 * v3 % 0x200 + v2 + 51) << 24) | (*(_BYTE *)(4 * v3 % 0x200 + v2 + 49) << 8) | *(_BYTE *)(4 * v3 % 0x200 + v2 + 48)) & 0xFFFFFFF;
      }
      else if ( v5 < 3 && !sub_801D222(v2, *(_DWORD *)(v2 + 32) + (a2 >> 8)) )
      {
        return *(_BYTE *)(2 * v3 % 0x200 + v2 + 48) | (unsigned __int16)(*(_BYTE *)(2 * v3 % 0x200 + v2 + 49) << 8);
      }
    }
    return -1;
  }
  v6 = a2 + (a2 >> 1);
  if ( sub_801D222(v2, *(_DWORD *)(v2 + 32) + (v6 >> 9)) )
    return -1;
  v7 = *(_BYTE *)(v6 % 0x200 + v2 + 48);
  v8 = v6 + 1;
  if ( sub_801D222(v2, *(_DWORD *)(v2 + 32) + (v8 >> 9)) )
    return -1;
  v9 = v7 | (*(_BYTE *)(v8 % 0x200 + v2 + 48) << 8);
  if ( v3 & 1 )
    result = (unsigned int)v9 >> 4;
  else
    result = v9 & 0xFFF;
  return result;
}

//----- (0801D48A) --------------------------------------------------------
int __fastcall sub_801D48A(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // r4@1
  unsigned int v4; // r5@1
  unsigned int v5; // r6@1
  char v6; // r9@3
  unsigned int v7; // r0@4
  unsigned int v8; // r7@10
  signed int v9; // r0@10
  unsigned int v10; // r8@11
  int v11; // r0@12
  unsigned int v12; // r7@14
  signed int v13; // r0@14
  unsigned int v14; // r8@15
  unsigned int v15; // r0@16
  signed int v16; // r0@8
  unsigned int v17; // r8@20
  signed int v18; // r0@21
  unsigned int v19; // r2@22
  int v20; // r8@22
  unsigned int v21; // r6@22

  v3 = a1;
  v4 = a2;
  v5 = a3;
  if ( a2 >= 2 && a2 < *(_DWORD *)(a1 + 24) )
  {
    v7 = *(_BYTE *)a1;
    if ( v7 == 1 )
    {
      v8 = a2 + (a2 >> 1);
      v9 = sub_801D222(v3, *(_DWORD *)(v3 + 32) + (v8 >> 9));
      v6 = v9;
      if ( !v9 )
      {
        v10 = v8 % 0x200 + v3 + 48;
        if ( v4 & 1 )
          v11 = *(_BYTE *)v10 & 0xF | 16 * v5;
        else
          LOBYTE(v11) = v5;
        *(_BYTE *)v10 = v11;
        v12 = v8 + 1;
        *(_BYTE *)(v3 + 4) = 1;
        v13 = sub_801D222(v3, *(_DWORD *)(v3 + 32) + (v12 >> 9));
        v6 = v13;
        if ( !v13 )
        {
          v14 = v12 % 0x200 + v3 + 48;
          if ( v4 & 1 )
            v15 = v5 >> 4;
          else
            v15 = (unsigned __int8)(*(_BYTE *)v14 & 0xF0) | (v5 >> 8) & 0xF;
          *(_BYTE *)v14 = v15;
        }
      }
      goto LABEL_24;
    }
    if ( v7 < 1 )
      goto LABEL_28;
    if ( v7 == 3 )
    {
      v18 = sub_801D222(v3, *(_DWORD *)(v3 + 32) + (a2 >> 7));
      v6 = v18;
      if ( !v18 )
      {
        v19 = 4 * v4 % 0x200;
        v20 = v19 + v3 + 48;
        v21 = v5 | (*(_BYTE *)(v19 + v3 + 51) << 24) & 0xF0000000;
        *(_BYTE *)v20 = v21;
        *(_BYTE *)(v20 + 1) = BYTE1(v21);
        *(_BYTE *)(v20 + 2) = v21 >> 16;
        *(_BYTE *)(v20 + 3) = BYTE3(v21);
      }
      goto LABEL_24;
    }
    if ( v7 >= 3 )
    {
LABEL_28:
      v6 = 2;
    }
    else
    {
      v16 = sub_801D222(v3, *(_DWORD *)(v3 + 32) + (a2 >> 8));
      v6 = v16;
      if ( !v16 )
      {
        v17 = 2 * v4 % 0x200 + v3 + 48;
        *(_BYTE *)v17 = v5;
        *(_BYTE *)(v17 + 1) = BYTE1(v5);
      }
    }
LABEL_24:
    *(_BYTE *)(v3 + 4) = 1;
    return (unsigned __int8)v6;
  }
  v6 = 2;
  return (unsigned __int8)v6;
}

//----- (0801D5EE) --------------------------------------------------------
int __fastcall sub_801D5EE(int a1, unsigned int a2)
{
  int v2; // r4@1
  unsigned int v3; // r5@1
  char v4; // r6@3
  signed int v5; // r0@6
  signed int v6; // r7@6

  v2 = a1;
  v3 = a2;
  if ( a2 >= 2 && a2 < *(_DWORD *)(a1 + 24) )
  {
    v4 = 0;
    while ( v3 < *(_DWORD *)(v2 + 24) )
    {
      v5 = sub_801D38C(v2, v3);
      v6 = v5;
      if ( !v5 )
        break;
      if ( v5 == 1 )
      {
        v4 = 2;
        return (unsigned __int8)v4;
      }
      if ( v5 == -1 )
      {
        v4 = 1;
        return (unsigned __int8)v4;
      }
      v4 = sub_801D48A(v2, v3, 0);
      if ( v4 )
        return (unsigned __int8)v4;
      if ( *(_DWORD *)(v2 + 16) != -1 )
      {
        ++*(_DWORD *)(v2 + 16);
        *(_BYTE *)(v2 + 5) = 1;
      }
      v3 = v6;
    }
  }
  else
  {
    v4 = 2;
  }
  return (unsigned __int8)v4;
}

//----- (0801D660) --------------------------------------------------------
unsigned int __fastcall sub_801D660(int a1, unsigned int a2)
{
  int v2; // r4@1
  unsigned int v3; // r5@1
  signed int v4; // r8@2
  signed int v5; // r6@5
  unsigned int result; // r0@6
  unsigned int v7; // r7@10
  int v8; // r9@15

  v2 = a1;
  v3 = a2;
  if ( a2 )
  {
    v5 = sub_801D38C(a1, a2);
    if ( (unsigned int)v5 < 2 )
      return 1;
    if ( (unsigned int)v5 < *(_DWORD *)(v2 + 24) )
      return v5;
    v4 = v3;
  }
  else
  {
    v4 = *(_DWORD *)(a1 + 12);
    if ( !v4 || (unsigned int)v4 >= *(_DWORD *)(a1 + 24) )
      v4 = 1;
  }
  v7 = v4;
  while ( 1 )
  {
    ++v7;
    if ( v7 >= *(_DWORD *)(v2 + 24) )
    {
      v7 = 2;
      if ( (unsigned int)v4 < 2 )
        return 0;
    }
    result = sub_801D38C(v2, v7);
    if ( !result )
      break;
    if ( result == -1 || result == 1 )
      return result;
    if ( v7 == v4 )
      return 0;
  }
  v8 = sub_801D48A(v2, v7, 0xFFFFFFFu);
  if ( !v8 && v3 )
    v8 = sub_801D48A(v2, v3, v7);
  if ( v8 )
  {
    if ( v8 == 1 )
      v7 = -1;
    else
      v7 = 1;
  }
  else
  {
    *(_DWORD *)(v2 + 12) = v7;
    if ( *(_DWORD *)(v2 + 16) != -1 )
    {
      --*(_DWORD *)(v2 + 16);
      *(_BYTE *)(v2 + 5) = 1;
    }
  }
  return v7;
}

//----- (0801D73C) --------------------------------------------------------
signed int __fastcall sub_801D73C(int a1, unsigned __int16 a2)
{
  int v2; // r4@1
  unsigned __int16 v3; // r5@1
  unsigned int v4; // r6@1
  unsigned __int16 i; // r7@11
  signed int v7; // r0@13

  v2 = a1;
  v3 = a2;
  *(_WORD *)(a1 + 6) = a2;
  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 == 1 || v4 >= *(_DWORD *)(*(_DWORD *)a1 + 24) )
    return 2;
  if ( !v4 && **(_BYTE **)a1 == 3 )
    v4 = *(_DWORD *)(*(_DWORD *)a1 + 36);
  if ( v4 )
  {
    for ( i = 16 * *(_BYTE *)(*(_DWORD *)a1 + 2); v3 >= (unsigned int)i; v3 -= i )
    {
      v7 = sub_801D38C(*(_DWORD *)v2, v4);
      v4 = v7;
      if ( v7 == -1 )
        return 1;
      if ( (unsigned int)v7 < 2 || (unsigned int)v7 >= *(_DWORD *)(*(_DWORD *)v2 + 24) )
        return 2;
    }
    *(_DWORD *)(v2 + 12) = v4;
    *(_DWORD *)(v2 + 16) = sub_801D372(*(_DWORD *)v2, v4) + ((unsigned int)v3 >> 4);
  }
  else
  {
    *(_DWORD *)(a1 + 12) = 0;
    if ( a2 >= (unsigned int)*(_WORD *)(*(_DWORD *)a1 + 8) )
      return 2;
    v3 = a2;
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(*(_DWORD *)a1 + 36) + ((unsigned int)a2 >> 4);
  }
  *(_DWORD *)(v2 + 20) = *(_DWORD *)v2 + 32 * (v3 % 0x10u) + 48;
  return 0;
}

//----- (0801D7F2) --------------------------------------------------------
signed int __fastcall sub_801D7F2(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r5@1
  unsigned __int16 v4; // r7@1
  signed int v6; // r0@9
  int v7; // r6@9
  unsigned int v8; // r0@16
  unsigned int i; // r8@24

  v2 = a1;
  v3 = a2;
  v4 = *(_WORD *)(a1 + 6) + 1;
  if ( *(_WORD *)(a1 + 6) == -1 || !*(_DWORD *)(a1 + 16) )
    return 4;
  if ( !(v4 % 0x10u) )
  {
    ++*(_DWORD *)(a1 + 16);
    if ( *(_DWORD *)(a1 + 12) )
    {
      if ( !((*(_BYTE *)(*(_DWORD *)a1 + 2) - 1) & ((unsigned int)v4 >> 4)) )
      {
        v6 = sub_801D38C(*(_DWORD *)a1, *(_DWORD *)(a1 + 12));
        v7 = v6;
        if ( (unsigned int)v6 < 2 )
          return 2;
        if ( v6 == -1 )
          return 1;
        if ( (unsigned int)v6 >= *(_DWORD *)(*(_DWORD *)v2 + 24) )
        {
          if ( !v3 )
            return 4;
          v8 = sub_801D660(*(_DWORD *)v2, *(_DWORD *)(v2 + 12));
          v7 = v8;
          if ( !v8 )
            return 7;
          if ( v8 == 1 )
            return 2;
          if ( v8 == -1 )
            return 1;
          if ( sub_801D222(*(_DWORD *)v2, 0) )
            return 1;
          memset((void *)(*(_DWORD *)v2 + 48), 0, 512);
          *(_DWORD *)(*(_DWORD *)v2 + 44) = sub_801D372(*(_DWORD *)v2, v7);
          for ( i = 0; i < *(_BYTE *)(*(_DWORD *)v2 + 2); ++i )
          {
            *(_BYTE *)(*(_DWORD *)v2 + 4) = 1;
            if ( sub_801D222(*(_DWORD *)v2, 0) )
              return 1;
            ++*(_DWORD *)(*(_DWORD *)v2 + 44);
          }
          *(_DWORD *)(*(_DWORD *)v2 + 44) -= i;
        }
        *(_DWORD *)(v2 + 12) = v7;
        *(_DWORD *)(v2 + 16) = sub_801D372(*(_DWORD *)v2, v7);
      }
    }
    else if ( v4 >= (unsigned int)*(_WORD *)(*(_DWORD *)a1 + 8) )
    {
      return 4;
    }
  }
  *(_WORD *)(v2 + 6) = v4;
  *(_DWORD *)(v2 + 20) = *(_DWORD *)v2 + 32 * (v4 % 0x10u) + 48;
  return 0;
}

//----- (0801D932) --------------------------------------------------------
int __fastcall sub_801D932(int a1)
{
  int v1; // r4@1
  int result; // r0@1
  char v3; // r7@3
  int v4; // r6@4

  v1 = a1;
  LOBYTE(result) = sub_801D73C(a1, 0);
  if ( (_BYTE)result )
  {
    result = (unsigned __int8)result;
  }
  else
  {
    while ( 1 )
    {
      v3 = sub_801D222(*(_DWORD *)v1, *(_DWORD *)(v1 + 16));
      if ( v3 )
        break;
      v4 = *(_DWORD *)(v1 + 20);
      if ( !*(_BYTE *)v4 )
      {
        v3 = 4;
        break;
      }
      if ( *(_BYTE *)(v4 + 11) & 8 || memcmp(*(char **)(v1 + 20), *(char **)(v1 + 24), 11) )
      {
        v3 = sub_801D7F2(v1, 0);
        if ( !v3 )
          continue;
      }
      break;
    }
    result = (unsigned __int8)v3;
  }
  return result;
}

//----- (0801D99A) --------------------------------------------------------
int __fastcall sub_801D99A(int a1)
{
  int v1; // r4@1
  char v2; // r5@1
  int v3; // r7@4
  unsigned __int8 v4; // r6@4

  v1 = a1;
  v2 = 4;
  while ( *(_DWORD *)(v1 + 16) )
  {
    v2 = sub_801D222(*(_DWORD *)v1, *(_DWORD *)(v1 + 16));
    if ( v2 )
      break;
    v3 = *(_DWORD *)(v1 + 20);
    v4 = *(_BYTE *)v3;
    if ( !*(_BYTE *)v3 )
    {
      v2 = 4;
      break;
    }
    if ( v4 == 229 || v4 == 46 || *(_BYTE *)(v3 + 11) & 8 )
    {
      v2 = sub_801D7F2(v1, 0);
      if ( !v2 )
        continue;
    }
    break;
  }
  if ( v2 )
    *(_DWORD *)(v1 + 16) = 0;
  return (unsigned __int8)v2;
}

//----- (0801D9FE) --------------------------------------------------------
int __fastcall sub_801D9FE(int a1)
{
  int v1; // r4@1
  unsigned __int8 i; // r5@1
  int v3; // r6@3
  void *v4; // r7@9

  v1 = a1;
  for ( i = sub_801D73C(a1, 0); !i; i = sub_801D7F2(v1, 1) )
  {
    i = sub_801D222(*(_DWORD *)v1, *(_DWORD *)(v1 + 16));
    if ( i )
      break;
    v3 = **(_BYTE **)(v1 + 20);
    if ( v3 == 229 )
      break;
    if ( !(_BYTE)v3 )
      break;
  }
  if ( !i )
  {
    i = sub_801D222(*(_DWORD *)v1, *(_DWORD *)(v1 + 16));
    if ( !i )
    {
      v4 = *(void **)(v1 + 20);
      memset(*(void **)(v1 + 20), 0, 32);
      memcpy(v4, *(void **)(v1 + 24), 11);
      *(_BYTE *)(*(_DWORD *)v1 + 4) = 1;
    }
  }
  return i;
}

//----- (0801DA80) --------------------------------------------------------
signed int __fastcall sub_801DA80(int a1, int a2)
{
  int v2; // r7@1
  int v3; // r4@1
  int v4; // r10@1
  int v5; // r9@1
  signed int v6; // r8@1
  int v7; // r11@1
  char v8; // r5@2
  signed int result; // r0@11
  unsigned __int8 v10; // r6@19
  int v11; // r10@25
  int v12; // r0@26
  char v13; // r5@6
  int v14; // [sp+8h] [bp-28h]@1

  v14 = a2;
  v2 = *(_DWORD *)(a1 + 24);
  memset(*(void **)(a1 + 24), 32, 11);
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 8;
  v7 = *(_DWORD *)v14;
  while ( 1 )
  {
    v8 = *(_BYTE *)(v5++ + v7);
    if ( (signed int)(unsigned __int8)v8 < 33 || v8 == 47 || v8 == 92 )
      break;
    if ( v8 != 46 && v4 < (unsigned int)v6 )
    {
      if ( (signed int)(unsigned __int8)v8 >= 128 )
        v3 |= 3u;
      if ( ((signed int)(unsigned __int8)v8 < 129 || (signed int)(unsigned __int8)v8 >= 160)
        && ((signed int)(unsigned __int8)v8 < 224 || (signed int)(unsigned __int8)v8 >= 253) )
      {
        LOBYTE(v12) = chr_in_str("\"*+,:;<=>?[]|", v8);
        if ( v12 )
          return 6;
        if ( (signed int)(unsigned __int8)v8 < 65 || (signed int)(unsigned __int8)v8 >= 91 )
        {
          if ( (signed int)(unsigned __int8)v8 >= 97 && (signed int)(unsigned __int8)v8 < 123 )
          {
            v3 |= 1u;
            v8 -= 32;
          }
        }
        else
        {
          v3 |= 2u;
        }
        *(_BYTE *)(v4++ + v2) = v8;
      }
      else
      {
        v10 = *(_BYTE *)(v5++ + v7);
        if ( ((signed int)v10 < 64 || (signed int)v10 >= 127) && ((signed int)v10 < 128 || (signed int)v10 >= 253)
          || v4 >= (unsigned int)(v6 - 1) )
          return 6;
        *(_BYTE *)(v4 + v2) = v8;
        v11 = v4 + 1;
        *(_BYTE *)(v11 + v2) = v10;
        v4 = v11 + 1;
      }
    }
    else
    {
      if ( v6 != 8 || v8 != 46 )
        return 6;
      v4 = 8;
      v6 = 11;
      v3 *= 4;
    }
  }
  *(_DWORD *)v14 = v5 + v7;
  if ( (signed int)(unsigned __int8)v8 >= 33 )
    v13 = 0;
  else
    v13 = 4;
  if ( v4 )
  {
    if ( *(_BYTE *)v2 == 229 )
      *(_BYTE *)v2 = 5;
    if ( v6 == 8 )
      LOBYTE(v3) = 4 * v3;
    if ( (v3 & 3) == 1 )
      v13 |= 0x10u;
    if ( (v3 & 0xC) == 4 )
      v13 |= 8u;
    *(_BYTE *)(v2 + 11) = v13;
    result = 0;
  }
  else
  {
    result = 6;
  }
  return result;
}

//----- (0801DBE6) --------------------------------------------------------
int __fastcall sub_801DBE6(int result, int a2)
{
  int v2; // r5@1
  int v3; // r3@2
  int v4; // r2@2
  unsigned int i; // r6@2
  int v6; // r4@4
  signed int j; // r6@9
  int v8; // r4@11

  v2 = a2 + 9;
  if ( *(_DWORD *)(result + 16) )
  {
    v3 = *(_DWORD *)(result + 20);
    v4 = *(_BYTE *)(v3 + 12);
    for ( i = 0; i < 8; ++i )
    {
      v6 = *(_BYTE *)(i + v3);
      if ( v6 == 32 )
        break;
      if ( (unsigned __int8)v6 == 5 )
        LOBYTE(v6) = -27;
      *(_BYTE *)v2++ = v6;
    }
    if ( *(_BYTE *)(v3 + 8) != 32 )
    {
      *(_BYTE *)v2++ = 46;
      for ( j = 8; (unsigned int)j < 0xB; ++j )
      {
        v8 = *(_BYTE *)(j + v3);
        if ( v8 == 32 )
          break;
        *(_BYTE *)v2++ = v8;
      }
    }
    *(_BYTE *)(a2 + 8) = *(_BYTE *)(v3 + 11);
    *(_DWORD *)a2 = *(_BYTE *)(v3 + 28) | (*(_BYTE *)(v3 + 30) << 16) | (*(_BYTE *)(v3 + 31) << 24) | (*(_BYTE *)(v3 + 29) << 8);
    *(_WORD *)(a2 + 4) = *(_BYTE *)(v3 + 24) | (unsigned __int16)(*(_BYTE *)(v3 + 25) << 8);
    *(_WORD *)(a2 + 6) = *(_BYTE *)(v3 + 22) | (unsigned __int16)(*(_BYTE *)(v3 + 23) << 8);
  }
  *(_BYTE *)v2 = 0;
  return result;
}

//----- (0801DC8A) --------------------------------------------------------
int __fastcall sub_801DC8A(int a1, int a2)
{
  int v2; // r4@1
  char v3; // r5@5
  char v4; // r0@7
  int v5; // r6@13
  int v7; // [sp+0h] [bp-18h]@1

  v7 = a2;
  v2 = a1;
  if ( *(_BYTE *)a2 == 47 || *(_BYTE *)v7 == 92 )
    ++v7;
  *(_DWORD *)(a1 + 8) = 0;
  if ( (unsigned int)*(_BYTE *)v7 >= 0x20 )
  {
    while ( 1 )
    {
      v3 = sub_801DA80(v2, (int)&v7);
      if ( v3 )
        break;
      v4 = sub_801D932(v2);
      v3 = v4;
      if ( v4 )
      {
        if ( v4 == 4 && !(*(_BYTE *)(*(_DWORD *)(v2 + 24) + 11) & 4) )
          v3 = 5;
        return (unsigned __int8)v3;
      }
      if ( *(_BYTE *)(*(_DWORD *)(v2 + 24) + 11) & 4 )
        return (unsigned __int8)v3;
      v5 = *(_DWORD *)(v2 + 20);
      if ( !(*(_BYTE *)(v5 + 11) & 0x10) )
      {
        v3 = 5;
        return (unsigned __int8)v3;
      }
      *(_DWORD *)(v2 + 8) = (unsigned __int16)(*(_BYTE *)(v5 + 26) | (unsigned __int16)(*(_BYTE *)(v5 + 27) << 8)) | ((unsigned __int16)(*(_BYTE *)(v5 + 20) | (unsigned __int16)(*(_BYTE *)(v5 + 21) << 8)) << 16);
    }
  }
  else
  {
    v3 = sub_801D73C(a1, 0);
    *(_DWORD *)(v2 + 20) = 0;
  }
  return (unsigned __int8)v3;
}

//----- (0801DD2A) --------------------------------------------------------
signed int __fastcall sub_801DD2A(int a1, int a2)
{
  int v2; // r4@1
  signed int result; // r0@2

  v2 = a1;
  if ( sub_80207E6(*(_BYTE *)(a1 + 1), a1 + 48, a2) )
  {
    result = 3;
  }
  else if ( (unsigned __int16)(*(_BYTE *)(v2 + 558) | (unsigned __int16)(*(_BYTE *)(v2 + 559) << 8)) == 43605 )
  {
    if ( ((*(_BYTE *)(v2 + 103) << 8) | (*(_BYTE *)(v2 + 104) << 16) | *(_BYTE *)(v2 + 102)) == 5521734 )
      result = 0;
    else
      result = ((*(_BYTE *)(v2 + 131) << 8) | (*(_BYTE *)(v2 + 132) << 16) | *(_BYTE *)(v2 + 130)) != 5521734;
  }
  else
  {
    result = 2;
  }
  return result;
}

//----- (0801DDA4) --------------------------------------------------------
signed int __fastcall sub_801DDA4(int a1, int a2, char a3)
{
  int v3; // r9@1
  signed int result; // r0@6
  int v5; // r10@7
  char v6; // r11@10
  char v7; // r11@15
  int v8; // r6@20
  char v9; // r4@20
  unsigned __int16 v10; // r1@29
  int v11; // r7@29
  unsigned __int8 v12; // r0@31
  int v13; // r7@34
  unsigned __int8 v14; // r0@34
  char v15; // r4@47
  unsigned int v16; // r8@54
  __int16 v17; // r0@68
  int v18; // [sp+0h] [bp-48h]@1
  unsigned int v19; // [sp+8h] [bp-40h]@45
  int v20; // [sp+Ch] [bp-3Ch]@39
  unsigned __int16 v21; // [sp+10h] [bp-38h]@41
  unsigned int v22; // [sp+14h] [bp-34h]@43
  char v23; // [sp+20h] [bp-28h]@1

  v23 = a3;
  v3 = *(_DWORD *)a1;
  v18 = **(_BYTE **)a1 - 48;
  if ( (unsigned int)v18 >= 0xA || *(_BYTE *)(v3 + 1) != 58 )
    v18 = 0;
  else
    *(_DWORD *)a1 = v3 + 2;
  if ( v18 )
    return 11;
  v5 = dword_20003800;
  *(_DWORD *)a2 = dword_20003800;
  if ( !v5 )
    return 12;
  if ( !*(_BYTE *)v5 || (v6 = isnt_zero(*(_BYTE *)(v5 + 1)), v6 & 1) )
  {
    *(_BYTE *)v5 = 0;
    *(_BYTE *)(v5 + 1) = 0;
    v7 = sub_80207C4(*(_BYTE *)(v5 + 1));
    if ( v7 & 1 )
      return 3;
    if ( v23 && v7 & 4 )
      return 10;
    v8 = 0;
    v9 = sub_801DD2A(v5, 0);
    if ( v9 == 1 && *(_BYTE *)(v5 + 498) )
    {
      v8 = (*(_BYTE *)(v5 + 504) << 16) | (*(_BYTE *)(v5 + 505) << 24) | (*(_BYTE *)(v5 + 503) << 8) | *(_BYTE *)(v5 + 502);
      v9 = sub_801DD2A(v5, v8);
    }
    if ( v9 == 3 )
      return 1;
    if ( v9 )
      return 13;
    if ( (unsigned __int16)(*(_BYTE *)(v5 + 59) | (unsigned __int16)(*(_BYTE *)(v5 + 60) << 8)) != 512 )
      return 13;
    v10 = *(_BYTE *)(v5 + 70);
    v11 = (unsigned __int16)(v10 | (*(_BYTE *)(v5 + 71) << 8));
    if ( !(v10 | (unsigned __int16)(*(_BYTE *)(v5 + 71) << 8)) )
      v11 = (*(_BYTE *)(v5 + 86) << 16) | (*(_BYTE *)(v5 + 87) << 24) | (*(_BYTE *)(v5 + 85) << 8) | *(_BYTE *)(v5 + 84);
    *(_DWORD *)(v5 + 28) = v11;
    v12 = *(_BYTE *)(v5 + 64);
    *(_BYTE *)(v5 + 3) = v12;
    if ( v12 != 1 && v12 != 2 )
      return 13;
    v13 = v11 * v12;
    v14 = *(_BYTE *)(v5 + 61);
    *(_BYTE *)(v5 + 2) = v14;
    if ( !v14 || v14 & (v14 - 1) )
      return 13;
    *(_WORD *)(v5 + 8) = *(_BYTE *)(v5 + 65) | (unsigned __int16)(*(_BYTE *)(v5 + 66) << 8);
    if ( *(_WORD *)(v5 + 8) % 0x10u )
      return 13;
    v20 = (unsigned __int16)(*(_BYTE *)(v5 + 67) | (unsigned __int16)(*(_BYTE *)(v5 + 68) << 8));
    if ( !(*(_BYTE *)(v5 + 67) | (unsigned __int16)(*(_BYTE *)(v5 + 68) << 8)) )
      v20 = (*(_BYTE *)(v5 + 82) << 16) | (*(_BYTE *)(v5 + 83) << 24) | (*(_BYTE *)(v5 + 81) << 8) | *(_BYTE *)(v5 + 80);
    v21 = *(_BYTE *)(v5 + 62) | (unsigned __int16)(*(_BYTE *)(v5 + 63) << 8);
    if ( !v21 )
      return 13;
    v22 = v13 + v21 + ((unsigned int)*(_WORD *)(v5 + 8) >> 4);
    if ( v20 < v22 )
      return 13;
    v19 = (v20 - v22) / *(_BYTE *)(v5 + 2);
    if ( !v19 )
      return 13;
    v15 = 1;
    if ( v19 >= 0xFF6 )
      v15 = 2;
    if ( v19 >= 0xFFF6 )
      v15 = 3;
    *(_DWORD *)(v5 + 24) = v19 + 2;
    *(_DWORD *)(v5 + 40) = v22 + v8;
    *(_DWORD *)(v5 + 32) = v21 + v8;
    if ( v15 == 3 )
    {
      if ( *(_WORD *)(v5 + 8) )
        return 13;
      *(_DWORD *)(v5 + 36) = (*(_BYTE *)(v5 + 94) << 16) | (*(_BYTE *)(v5 + 95) << 24) | (*(_BYTE *)(v5 + 93) << 8) | *(_BYTE *)(v5 + 92);
      v16 = 4 * *(_DWORD *)(v5 + 24);
    }
    else
    {
      if ( !*(_WORD *)(v5 + 8) )
        return 13;
      *(_DWORD *)(v5 + 36) = v13 + *(_DWORD *)(v5 + 32);
      if ( v15 == 2 )
        v16 = 2 * *(_DWORD *)(v5 + 24);
      else
        v16 = (*(_BYTE *)(v5 + 24) & 1) + ((unsigned int)(3 * *(_DWORD *)(v5 + 24)) >> 1);
    }
    if ( *(_DWORD *)(v5 + 28) >= (v16 + 511) >> 9 )
    {
      *(_DWORD *)(v5 + 16) = -1;
      *(_DWORD *)(v5 + 12) = 0;
      if ( v15 == 3 )
      {
        *(_BYTE *)(v5 + 5) = 0;
        *(_DWORD *)(v5 + 20) = (unsigned __int16)(*(_BYTE *)(v5 + 96) | (unsigned __int16)(*(_BYTE *)(v5 + 97) << 8))
                             + v8;
        if ( !sub_80207E6(*(_BYTE *)(v5 + 1), v5 + 48, *(_DWORD *)(v5 + 20))
          && (unsigned __int16)(*(_BYTE *)(v5 + 558) | (unsigned __int16)(*(_BYTE *)(v5 + 559) << 8)) == 43605
          && ((*(_BYTE *)(v5 + 50) << 16) | (*(_BYTE *)(v5 + 51) << 24) | (*(_BYTE *)(v5 + 49) << 8) | *(_BYTE *)(v5 + 48)) == 1096897106
          && ((*(_BYTE *)(v5 + 534) << 16) | (*(_BYTE *)(v5 + 535) << 24) | (*(_BYTE *)(v5 + 533) << 8) | *(_BYTE *)(v5 + 532)) == 1631679090 )
        {
          *(_DWORD *)(v5 + 12) = (*(_BYTE *)(v5 + 542) << 16) | (*(_BYTE *)(v5 + 543) << 24) | (*(_BYTE *)(v5 + 541) << 8) | *(_BYTE *)(v5 + 540);
          *(_DWORD *)(v5 + 16) = (*(_BYTE *)(v5 + 538) << 16) | (*(_BYTE *)(v5 + 539) << 24) | (*(_BYTE *)(v5 + 537) << 8) | *(_BYTE *)(v5 + 536);
        }
      }
      *(_BYTE *)v5 = v15;
      v17 = word_20003A50 + 1;
      word_20003A50 = v17;
      *(_WORD *)(v5 + 6) = v17;
      *(_DWORD *)(v5 + 44) = 0;
      *(_BYTE *)(v5 + 4) = 0;
      result = 0;
    }
    else
    {
      result = 13;
    }
  }
  else if ( v23 && v6 & 4 )
  {
    result = 10;
  }
  else
  {
    result = 0;
  }
  return result;
}
// 20003A50: using guessed type __int16 word_20003A50;

//----- (0801E1B2) --------------------------------------------------------
signed int __fastcall sub_801E1B2(int a1, unsigned __int16 a2)
{
  signed int result; // r0@4

  if ( a1 && *(_BYTE *)a1 && *(_WORD *)(a1 + 6) == a2 )
  {
    if ( isnt_zero(*(_BYTE *)(a1 + 1)) )
      result = 3;
    else
      result = 0;
  }
  else
  {
    result = 9;
  }
  return result;
}

//----- (0801E1E0) --------------------------------------------------------
signed int __fastcall sub_801E1E0(unsigned __int8 a1, int a2)
{
  signed int result; // r0@2
  int v3; // r3@3

  if ( a1 )
  {
    result = 11;
  }
  else
  {
    v3 = *(&dword_20003800 + a1);
    if ( v3 )
      *(_BYTE *)v3 = 0;
    if ( a2 )
      *(_BYTE *)a2 = 0;
    *(&dword_20003800 + a1) = a2;
    result = 0;
  }
  return result;
}

//----- (0801E22C) --------------------------------------------------------
int __fastcall f_open(void *fp, char *path, FA_MODE mode)
{
  void *v3; // r4@1
  char v4; // r7@1
  char v5; // r5@1
  int v6; // r6@3
  signed int v7; // r0@17
  int v8; // r9@17
  int v9; // r8@18
  int v11; // [sp+0h] [bp-48h]@1
  int v12; // [sp+14h] [bp-34h]@3
  char *v13; // [sp+18h] [bp-30h]@1
  char v14; // [sp+1Ch] [bp-2Ch]@1
  int v15; // [sp+28h] [bp-20h]@1

  v15 = (int)path;
  v3 = fp;
  *(_DWORD *)fp = 0;
  v4 = mode & 0x1F;
  v5 = sub_801DDA4((int)&v15, (int)&v11, mode & 0x1E);
  v13 = &v14;
  if ( !v5 )
    v5 = sub_801DC8A((int)&v11, v15);
  v6 = v12;
  if ( !v5 && !v12 )
    v5 = 6;
  if ( v4 & 0x1C )
  {
    if ( v5 )
    {
      if ( v5 == 4 )
        v5 = sub_801D9FE((int)&v11);
      v4 |= 8u;
      v6 = v12;
    }
    else if ( v4 & 4 )
    {
      v5 = 8;
    }
    else if ( *(_BYTE *)(v12 + 11) & 0x11 )
    {
      v5 = 7;
    }
    if ( !v5 )
    {
      if ( v4 & 8 )
      {
        v7 = sub_8020894();
        *(_BYTE *)(v6 + 14) = v7;
        *(_BYTE *)(v6 + 15) = BYTE1(v7);
        *(_BYTE *)(v6 + 16) = (unsigned int)v7 >> 16;
        *(_BYTE *)(v6 + 17) = BYTE3(v7);
        *(_BYTE *)(v6 + 11) = 0;
        *(_BYTE *)(v6 + 28) = 0;
        *(_BYTE *)(v6 + 29) = 0;
        *(_BYTE *)(v6 + 30) = 0;
        *(_BYTE *)(v6 + 31) = 0;
        v8 = (unsigned __int16)(*(_BYTE *)(v6 + 26) | (unsigned __int16)(*(_BYTE *)(v6 + 27) << 8)) | ((unsigned __int16)(*(_BYTE *)(v6 + 20) | (unsigned __int16)(*(_BYTE *)(v6 + 21) << 8)) << 16);
        *(_BYTE *)(v6 + 26) = 0;
        *(_BYTE *)(v6 + 27) = 0;
        *(_BYTE *)(v6 + 20) = 0;
        *(_BYTE *)(v6 + 21) = 0;
        *(_BYTE *)(v11 + 4) = 1;
        if ( v8 )
        {
          v9 = *(_DWORD *)(v11 + 44);
          v5 = sub_801D5EE(v11, v8);
          if ( !v5 )
          {
            *(_DWORD *)(v11 + 12) = v8 - 1;
            v5 = sub_801D222(v11, v9);
          }
        }
      }
    }
  }
  else if ( !v5 )
  {
    if ( *(_BYTE *)(v12 + 11) & 0x10 )
    {
      v5 = 4;
    }
    else if ( v4 & 2 && *(_BYTE *)(v12 + 11) & 1 )
    {
      v5 = 7;
    }
  }
  if ( !v5 )
  {
    if ( v4 & 8 )
      v4 |= 0x20u;
    *((_DWORD *)v3 + 7) = *(_DWORD *)(v11 + 44);
    *((_DWORD *)v3 + 8) = v6;
  }
  if ( !v5 )
  {
    *((_BYTE *)v3 + 6) = v4;
    *((_DWORD *)v3 + 4) = (unsigned __int16)(*(_BYTE *)(v6 + 26) | (unsigned __int16)(*(_BYTE *)(v6 + 27) << 8)) | ((unsigned __int16)(*(_BYTE *)(v6 + 20) | (unsigned __int16)(*(_BYTE *)(v6 + 21) << 8)) << 16);
    *((_DWORD *)v3 + 3) = (*(_BYTE *)(v6 + 30) << 16) | (*(_BYTE *)(v6 + 31) << 24) | (*(_BYTE *)(v6 + 29) << 8) | *(_BYTE *)(v6 + 28);
    *((_DWORD *)v3 + 2) = 0;
    *((_DWORD *)v3 + 6) = 0;
    *(_DWORD *)v3 = v11;
    *((_WORD *)v3 + 2) = *(_WORD *)(v11 + 6);
  }
  return (unsigned __int8)v5;
}

//----- (0801E3D2) --------------------------------------------------------
signed int __fastcall f_read(void *fp, void *data, unsigned int count, int *bytes_read)
{
  void *v4; // r4@1
  unsigned int v5; // r5@1
  void *v6; // r11@1
  int v8; // r10@11
  signed int v9; // r6@13
  int v10; // r0@20
  int v11; // r7@22
  int v12; // r9@22
  int v13; // r8@30
  unsigned __int8 v14; // [sp+4h] [bp-34h]@1
  int *v15; // [sp+10h] [bp-28h]@1

  v15 = bytes_read;
  v4 = fp;
  v5 = count;
  v6 = data;
  *bytes_read = 0;
  v14 = sub_801E1B2(*(_DWORD *)fp, *((_WORD *)fp + 2));
  if ( v14 )
    return v14;
  if ( *((_BYTE *)v4 + 6) & 0x80 )
    return 2;
  if ( !(*((_BYTE *)v4 + 6) & 1) )
    return 7;
  if ( *((_DWORD *)v4 + 3) - *((_DWORD *)v4 + 2) < v5 )
    v5 = *((_DWORD *)v4 + 3) - *((_DWORD *)v4 + 2);
  while ( v5 )
  {
    if ( *((_DWORD *)v4 + 2) % 0x200u )
      goto LABEL_39;
    v8 = (*((_DWORD *)v4 + 2) >> 9) & (*(_BYTE *)(*(_DWORD *)v4 + 2) - 1);
    if ( !v8 )
    {
      if ( *((_DWORD *)v4 + 2) )
        v9 = sub_801D38C(*(_DWORD *)v4, *((_DWORD *)v4 + 5));
      else
        v9 = *((_DWORD *)v4 + 4);
      if ( (unsigned int)v9 < 2 )
      {
        *((_BYTE *)v4 + 6) |= 0x80u;
        return 2;
      }
      if ( v9 == -1 )
      {
        *((_BYTE *)v4 + 6) |= 0x80u;
        return 1;
      }
      *((_DWORD *)v4 + 5) = v9;
    }
    v10 = sub_801D372(*(_DWORD *)v4, *((_DWORD *)v4 + 5));
    if ( !v10 )
    {
      *((_BYTE *)v4 + 6) |= 0x80u;
      return 2;
    }
    v11 = v8 + v10;
    v12 = v5 >> 9;
    if ( !(v5 >> 9) )
    {
      if ( *((_BYTE *)v4 + 6) & 0x40 )
      {
        if ( prob_write_sd_blocks(*(_BYTE *)(*(_DWORD *)v4 + 1), (int)((char *)v4 + 36), *((_DWORD *)v4 + 6), 1u) )
        {
          *((_BYTE *)v4 + 6) |= 0x80u;
          return 1;
        }
        *((_BYTE *)v4 + 6) &= 0xBFu;
      }
      if ( *((_DWORD *)v4 + 6) != v11 && sub_80207E6(*(_BYTE *)(*(_DWORD *)v4 + 1), (int)((char *)v4 + 36), v11) )
      {
        *((_BYTE *)v4 + 6) |= 0x80u;
        return 1;
      }
      *((_DWORD *)v4 + 6) = v11;
LABEL_39:
      v13 = 512 - *((_DWORD *)v4 + 2) % 0x200u;
      if ( v5 < v13 )
        v13 = v5;
      memcpy(v6, (char *)v4 + *((_DWORD *)v4 + 2) % 0x200u + 36, v13);
      goto LABEL_42;
    }
    if ( *(_BYTE *)(*(_DWORD *)v4 + 2) < (unsigned int)(v12 + v8) )
      v12 = *(_BYTE *)(*(_DWORD *)v4 + 2) - v8;
    if ( sub_80207E6(*(_BYTE *)(*(_DWORD *)v4 + 1), (int)v6, v11) )
    {
      *((_BYTE *)v4 + 6) |= 0x80u;
      return 1;
    }
    if ( *((_BYTE *)v4 + 6) & 0x40 )
    {
      if ( *((_DWORD *)v4 + 6) - v11 < (unsigned int)v12 )
        memcpy((char *)v6 + 512 * (*((_DWORD *)v4 + 6) - v11), (char *)v4 + 36, 512);
    }
    v13 = v12 << 9;
LABEL_42:
    v6 = (char *)v6 + v13;
    *((_DWORD *)v4 + 2) += v13;
    *v15 += v13;
    v5 -= v13;
  }
  return 0;
}

//----- (0801E5DE) --------------------------------------------------------
signed int __fastcall f_write(void *fp, void *data, unsigned int count, int *bytes_written)
{
  void *v4; // r4@1
  unsigned int v5; // r5@1
  void *v6; // r10@1
  int v8; // r11@11
  unsigned int v9; // r6@13
  int v10; // r0@26
  int v11; // r7@28
  int v12; // r9@28
  int v13; // r8@35
  unsigned __int8 v14; // [sp+0h] [bp-30h]@1
  int *v15; // [sp+8h] [bp-28h]@1

  v15 = bytes_written;
  v4 = fp;
  v5 = count;
  v6 = data;
  *bytes_written = 0;
  v14 = sub_801E1B2(*(_DWORD *)fp, *((_WORD *)fp + 2));
  if ( v14 )
    return v14;
  if ( *((_BYTE *)v4 + 6) & 0x80 )
    return 2;
  if ( !(*((_BYTE *)v4 + 6) & 2) )
    return 7;
  if ( v5 + *((_DWORD *)v4 + 3) < *((_DWORD *)v4 + 3) )
    v5 = 0;
  while ( v5 )
  {
    if ( *((_DWORD *)v4 + 2) % 0x200u )
      goto LABEL_41;
    v8 = (*((_DWORD *)v4 + 2) >> 9) & (*(_BYTE *)(*(_DWORD *)v4 + 2) - 1);
    if ( !v8 )
    {
      if ( *((_DWORD *)v4 + 2) )
      {
        v9 = sub_801D660(*(_DWORD *)v4, *((_DWORD *)v4 + 5));
      }
      else
      {
        v9 = *((_DWORD *)v4 + 4);
        if ( !v9 )
        {
          v9 = sub_801D660(*(_DWORD *)v4, 0);
          *((_DWORD *)v4 + 4) = v9;
        }
      }
      if ( !v9 )
        break;
      if ( v9 == 1 )
      {
        *((_BYTE *)v4 + 6) |= 0x80u;
        return 2;
      }
      if ( v9 == -1 )
      {
        *((_BYTE *)v4 + 6) |= 0x80u;
        return 1;
      }
      *((_DWORD *)v4 + 5) = v9;
    }
    if ( *((_BYTE *)v4 + 6) & 0x40 )
    {
      if ( prob_write_sd_blocks(*(_BYTE *)(*(_DWORD *)v4 + 1), (int)((char *)v4 + 36), *((_DWORD *)v4 + 6), 1u) )
      {
        *((_BYTE *)v4 + 6) |= 0x80u;
        return 1;
      }
      *((_BYTE *)v4 + 6) &= 0xBFu;
    }
    v10 = sub_801D372(*(_DWORD *)v4, *((_DWORD *)v4 + 5));
    if ( !v10 )
    {
      *((_BYTE *)v4 + 6) |= 0x80u;
      return 2;
    }
    v11 = v8 + v10;
    v12 = v5 >> 9;
    if ( !(v5 >> 9) )
    {
      if ( *((_DWORD *)v4 + 6) != v11
        && *((_DWORD *)v4 + 2) < *((_DWORD *)v4 + 3)
        && sub_80207E6(*(_BYTE *)(*(_DWORD *)v4 + 1), (int)((char *)v4 + 36), v11) )
      {
        *((_BYTE *)v4 + 6) |= 0x80u;
        return 1;
      }
      *((_DWORD *)v4 + 6) = v11;
LABEL_41:
      v13 = 512 - *((_DWORD *)v4 + 2) % 0x200u;
      if ( v5 < v13 )
        v13 = v5;
      memcpy((char *)v4 + *((_DWORD *)v4 + 2) % 0x200u + 36, v6, v13);
      *((_BYTE *)v4 + 6) |= 0x40u;
      goto LABEL_44;
    }
    if ( *(_BYTE *)(*(_DWORD *)v4 + 2) < (unsigned int)(v12 + v8) )
      v12 = *(_BYTE *)(*(_DWORD *)v4 + 2) - v8;
    if ( prob_write_sd_blocks(*(_BYTE *)(*(_DWORD *)v4 + 1), (int)v6, v11, v12) )
    {
      *((_BYTE *)v4 + 6) |= 0x80u;
      return 1;
    }
    if ( *((_DWORD *)v4 + 6) - v11 < (unsigned int)v12 )
    {
      memcpy((char *)v4 + 36, (char *)v6 + 512 * (*((_DWORD *)v4 + 6) - v11), 512);
      *((_BYTE *)v4 + 6) &= 0xBFu;
    }
    v13 = v12 << 9;
LABEL_44:
    v6 = (char *)v6 + v13;
    *((_DWORD *)v4 + 2) += v13;
    *v15 += v13;
    v5 -= v13;
  }
  if ( *((_DWORD *)v4 + 3) < *((_DWORD *)v4 + 2) )
    *((_DWORD *)v4 + 3) = *((_DWORD *)v4 + 2);
  *((_BYTE *)v4 + 6) |= 0x20u;
  return 0;
}

//----- (0801E820) --------------------------------------------------------
signed int __fastcall f_sync_prob(int a1)
{
  int v1; // r4@1
  unsigned __int8 v2; // r5@1
  int v4; // r7@8
  signed int v5; // r0@8

  v1 = a1;
  v2 = sub_801E1B2(*(_DWORD *)a1, *(_WORD *)(a1 + 4));
  if ( !v2 && *(_BYTE *)(v1 + 6) & 0x20 )
  {
    if ( *(_BYTE *)(v1 + 6) & 0x40 )
    {
      if ( prob_write_sd_blocks(*(_BYTE *)(*(_DWORD *)v1 + 1), v1 + 36, *(_DWORD *)(v1 + 24), 1u) )
        return 1;
      *(_BYTE *)(v1 + 6) &= 0xBFu;
    }
    v2 = sub_801D222(*(_DWORD *)v1, *(_DWORD *)(v1 + 28));
    if ( !v2 )
    {
      v4 = *(_DWORD *)(v1 + 32);
      *(_BYTE *)(v4 + 11) |= 0x20u;
      *(_BYTE *)(v4 + 28) = *(_DWORD *)(v1 + 12);
      *(_BYTE *)(v4 + 29) = (unsigned __int16)*(_DWORD *)(v1 + 12) >> 8;
      *(_BYTE *)(v4 + 30) = *(_DWORD *)(v1 + 12) >> 16;
      *(_BYTE *)(v4 + 31) = *(_DWORD *)(v1 + 12) >> 24;
      *(_BYTE *)(v4 + 26) = *(_DWORD *)(v1 + 16);
      *(_BYTE *)(v4 + 27) = (unsigned __int16)*(_DWORD *)(v1 + 16) >> 8;
      *(_BYTE *)(v4 + 20) = *(_DWORD *)(v1 + 16) >> 16;
      *(_BYTE *)(v4 + 21) = *(_DWORD *)(v1 + 16) >> 24;
      v5 = sub_8020894();
      *(_BYTE *)(v4 + 22) = v5;
      *(_BYTE *)(v4 + 23) = BYTE1(v5);
      *(_BYTE *)(v4 + 24) = (unsigned int)v5 >> 16;
      *(_BYTE *)(v4 + 25) = BYTE3(v5);
      *(_BYTE *)(v1 + 6) &= 0xDFu;
      *(_BYTE *)(*(_DWORD *)v1 + 4) = 1;
      v2 = prob_sd_init_partition_table(*(_DWORD *)v1);
    }
  }
  return v2;
}

//----- (0801E8E4) --------------------------------------------------------
int __fastcall f_close(int a1)
{
  int v1; // r4@1
  unsigned __int8 v2; // r5@1

  v1 = a1;
  v2 = f_sync_prob(a1);
  if ( !v2 )
    *(_DWORD *)v1 = 0;
  return v2;
}

//----- (0801E900) --------------------------------------------------------
signed int __fastcall f_seek(int a1, unsigned int a2)
{
  int v2; // r4@1
  unsigned int v3; // r5@1
  signed int result; // r0@1
  unsigned __int8 v5; // r6@1
  int v6; // r10@8
  int v7; // r9@8
  unsigned int v8; // r8@9
  unsigned int v9; // r7@11
  unsigned int v10; // r0@13
  int v11; // r0@32

  v2 = a1;
  v3 = a2;
  LOBYTE(result) = sub_801E1B2(*(_DWORD *)a1, *(_WORD *)(a1 + 4));
  v5 = result;
  if ( (_BYTE)result )
    return (unsigned __int8)result;
  if ( *(_BYTE *)(v2 + 6) & 0x80 )
    return 2;
  if ( *(_DWORD *)(v2 + 12) < v3 && !(*(_BYTE *)(v2 + 6) & 2) )
    v3 = *(_DWORD *)(v2 + 12);
  v6 = *(_DWORD *)(v2 + 8);
  v7 = 0;
  *(_DWORD *)(v2 + 8) = 0;
  if ( v3 )
  {
    v8 = *(_BYTE *)(*(_DWORD *)v2 + 2) << 9;
    if ( v6 && (v3 - 1) / v8 >= (v6 - 1) / v8 )
    {
      *(_DWORD *)(v2 + 8) = (v6 - 1) & ~(v8 - 1);
      v3 -= *(_DWORD *)(v2 + 8);
      v9 = *(_DWORD *)(v2 + 20);
    }
    else
    {
      v9 = *(_DWORD *)(v2 + 16);
      if ( !v9 )
      {
        v10 = sub_801D660(*(_DWORD *)v2, 0);
        v9 = v10;
        if ( v10 == 1 )
        {
          *(_BYTE *)(v2 + 6) |= 0x80u;
          return 2;
        }
        if ( v10 == -1 )
        {
          *(_BYTE *)(v2 + 6) |= 0x80u;
          return 1;
        }
        *(_DWORD *)(v2 + 16) = v10;
      }
      *(_DWORD *)(v2 + 20) = v9;
    }
    if ( v9 )
    {
      while ( v8 < v3 )
      {
        if ( *(_BYTE *)(v2 + 6) & 2 )
        {
          v9 = sub_801D660(*(_DWORD *)v2, v9);
          if ( !v9 )
          {
            v3 = v8;
            break;
          }
        }
        else
        {
          v9 = sub_801D38C(*(_DWORD *)v2, v9);
        }
        if ( v9 == -1 )
        {
          *(_BYTE *)(v2 + 6) |= 0x80u;
          return 1;
        }
        if ( v9 < 2 || v9 >= *(_DWORD *)(*(_DWORD *)v2 + 24) )
        {
          *(_BYTE *)(v2 + 6) |= 0x80u;
          return 2;
        }
        *(_DWORD *)(v2 + 20) = v9;
        *(_DWORD *)(v2 + 8) += v8;
        v3 -= v8;
      }
      *(_DWORD *)(v2 + 8) += v3;
      if ( v3 % 0x200 )
      {
        v11 = sub_801D372(*(_DWORD *)v2, v9);
        if ( !v11 )
        {
          *(_BYTE *)(v2 + 6) |= 0x80u;
          return 2;
        }
        v7 = v11 + (v3 >> 9);
      }
    }
  }
  if ( *(_DWORD *)(v2 + 8) % 0x200u && v7 != *(_DWORD *)(v2 + 24) )
  {
    if ( *(_BYTE *)(v2 + 6) & 0x40 )
    {
      if ( prob_write_sd_blocks(*(_BYTE *)(*(_DWORD *)v2 + 1), v2 + 36, *(_DWORD *)(v2 + 24), 1u) )
      {
        *(_BYTE *)(v2 + 6) |= 0x80u;
        return 1;
      }
      *(_BYTE *)(v2 + 6) &= 0xBFu;
    }
    if ( sub_80207E6(*(_BYTE *)(*(_DWORD *)v2 + 1), v2 + 36, v7) )
    {
      *(_BYTE *)(v2 + 6) |= 0x80u;
      return 1;
    }
    *(_DWORD *)(v2 + 24) = v7;
  }
  if ( *(_DWORD *)(v2 + 12) < *(_DWORD *)(v2 + 8) )
  {
    *(_DWORD *)(v2 + 12) = *(_DWORD *)(v2 + 8);
    *(_BYTE *)(v2 + 6) |= 0x20u;
  }
  return v5;
}

//----- (0801EADA) --------------------------------------------------------
int __fastcall sub_801EADA(int a1, int a2)
{
  int v2; // r4@1
  char v3; // r5@1
  char v5; // [sp+0h] [bp-20h]@2
  int v6; // [sp+10h] [bp-10h]@1

  v6 = a2;
  v2 = a1;
  v3 = sub_801DDA4((int)&v6, a1, 0);
  if ( !v3 )
  {
    *(_DWORD *)(v2 + 24) = &v5;
    v3 = sub_801DC8A(v2, v6);
    if ( !v3 )
    {
      if ( *(_DWORD *)(v2 + 20) )
      {
        if ( *(_BYTE *)(*(_DWORD *)(v2 + 20) + 11) & 0x10 )
          *(_DWORD *)(v2 + 8) = (unsigned __int16)(*(_BYTE *)(*(_DWORD *)(v2 + 20) + 26) | (unsigned __int16)(*(_BYTE *)(*(_DWORD *)(v2 + 20) + 27) << 8)) | ((unsigned __int16)(*(_BYTE *)(*(_DWORD *)(v2 + 20) + 20) | (unsigned __int16)(*(_BYTE *)(*(_DWORD *)(v2 + 20) + 21) << 8)) << 16);
        else
          v3 = 5;
      }
      if ( !v3 )
      {
        *(_WORD *)(v2 + 4) = *(_WORD *)(*(_DWORD *)v2 + 6);
        v3 = sub_801D73C(v2, 0);
      }
    }
    if ( v3 == 4 )
      v3 = 5;
  }
  return (unsigned __int8)v3;
}

//----- (0801EB64) --------------------------------------------------------
int __fastcall sub_801EB64(int a1, int a2)
{
  int v2; // r4@1
  int v3; // r5@1
  int v4; // r6@1
  char v6; // [sp+0h] [bp-20h]@4

  v2 = a1;
  v3 = a2;
  LOBYTE(v4) = sub_801E1B2(*(_DWORD *)a1, *(_WORD *)(a1 + 4));
  if ( !(_BYTE)v4 )
  {
    if ( v3 )
    {
      *(_DWORD *)(v2 + 24) = &v6;
      LOBYTE(v4) = sub_801D99A(v2);
      if ( (unsigned __int8)v4 == 4 )
      {
        *(_DWORD *)(v2 + 16) = 0;
        LOBYTE(v4) = 0;
      }
      if ( !(_BYTE)v4 )
      {
        sub_801DBE6(v2, v3);
        v4 = (unsigned __int8)sub_801D7F2(v2, 0);
        if ( v4 == 4 )
        {
          *(_DWORD *)(v2 + 16) = 0;
          LOBYTE(v4) = 0;
        }
      }
    }
    else
    {
      LOBYTE(v4) = sub_801D73C(v2, 0);
    }
  }
  return (unsigned __int8)v4;
}

//----- (0801EBD4) --------------------------------------------------------
int HAL_SD_Init()
{
  int result; // r0@2
  unsigned __int8 v1; // [sp+0h] [bp-8h]@1
  unsigned __int8 v2; // [sp+0h] [bp-8h]@3
  unsigned __int8 v3; // [sp+0h] [bp-8h]@5

  HAL_SD_MspInit();
  reset_sdio_periph();
  v1 = SD_PowerON();
  if ( v1 )
  {
    result = v1;
  }
  else
  {
    v2 = SD_Initialize_Cards();
    if ( v2 )
    {
      result = v2;
    }
    else
    {
      byte_200036CC = 1;
      dword_200036B8 = 0;
      dword_200036BC = 0;
      dword_200036C0 = 0;
      dword_200036C4 = 0;
      dword_200036C8 = 0;
      something_gnarly_with_sdio_clk((int)&dword_200036B8);
      v3 = HAL_SD_GetCardInfo((int)&unk_200034D0);
      if ( !v3 )
        v3 = SD_Select_Deselect((unsigned __int16)word_20003524 << 16);
      if ( !v3 )
        v3 = sub_801F4B0(0);
      result = v3;
    }
  }
  return result;
}
// 20003524: using guessed type __int16 word_20003524;
// 200036B8: using guessed type int dword_200036B8;
// 200036BC: using guessed type int dword_200036BC;
// 200036C0: using guessed type int dword_200036C0;
// 200036C4: using guessed type int dword_200036C4;
// 200036C8: using guessed type int dword_200036C8;
// 200036CC: using guessed type char byte_200036CC;

//----- (0801EC86) --------------------------------------------------------
signed int sub_801EC86()
{
  unsigned __int8 v0; // r4@1
  signed int result; // r0@2

  v0 = sub_801ECA8();
  if ( v0 == 4 )
  {
    result = 0;
  }
  else if ( v0 == 255 )
  {
    result = 2;
  }
  else
  {
    result = 1;
  }
  return result;
}

//----- (0801ECA8) --------------------------------------------------------
unsigned int sub_801ECA8()
{
  unsigned int result; // r0@3
  unsigned int v1; // [sp+0h] [bp-8h]@1

  v1 = 0;
  if ( sub_801ECD2() == 1 )
  {
    if ( sd_get_status((int)&v1) )
      result = 255;
    else
      result = (v1 >> 9) & 0xF;
  }
  else
  {
    result = 255;
  }
  return result;
}

//----- (0801ECD2) --------------------------------------------------------
signed int sub_801ECD2()
{
  return 1;
}

//----- (0801ECE2) --------------------------------------------------------
signed int SD_PowerON()
{
  unsigned int v0; // r4@1
  unsigned int v1; // r5@1
  unsigned int v2; // r6@1
  signed int v3; // r7@1
  char v5; // ST00_1@5
  unsigned __int8 v6; // [sp+0h] [bp-18h]@1
  unsigned __int8 v7; // [sp+0h] [bp-18h]@6
  unsigned __int8 v8; // [sp+0h] [bp-18h]@9

  v0 = 0;
  v1 = 0;
  v2 = 0;
  v3 = 0;
  byte_200036CC = 118;
  dword_200036B8 = 0;
  dword_200036BC = 0;
  dword_200036C0 = 0;
  dword_200036C4 = 0;
  dword_200036C8 = 0;
  something_gnarly_with_sdio_clk((int)&dword_200036B8);
  set_sdio_power_reg(3);
  HAL_set_sdio_clken(1u);
  sd_cmd_temp.CMDARG = 0;
  sd_cmd_temp.CMDINDEX = 0;
  sd_cmd_temp.WAITRESP = 0;
  sd_cmd_temp.field_C = 0;
  sd_cmd_temp.CPSMEN = 1024;
  SDIO_SendCommand(&sd_cmd_temp);
  v6 = sub_801FB3C();
  if ( v6 )
    return v6;
  sd_cmd_temp.CMDARG = 426;
  sd_cmd_temp.CMDINDEX = 8;
  sd_cmd_temp.WAITRESP = 64;
  sd_cmd_temp.field_C = 0;
  sd_cmd_temp.CPSMEN = 1024;
  SDIO_SendCommand(&sd_cmd_temp);
  if ( (unsigned __int8)sub_801FB88() )
  {
    sd_cmd_temp.CMDARG = 0;
    sd_cmd_temp.CMDINDEX = 55;
    sd_cmd_temp.WAITRESP = 64;
    sd_cmd_temp.field_C = 0;
    sd_cmd_temp.CPSMEN = 1024;
    SDIO_SendCommand(&sd_cmd_temp);
    v5 = SD_CmdResp1Error(0x37u);
  }
  else
  {
    sdio_dword_20003998 = 1;
    v3 = 0x40000000;
  }
  sd_cmd_temp.CMDARG = 0;
  sd_cmd_temp.CMDINDEX = 55;
  sd_cmd_temp.WAITRESP = 64;
  sd_cmd_temp.field_C = 0;
  sd_cmd_temp.CPSMEN = 1024;
  SDIO_SendCommand(&sd_cmd_temp);
  v7 = SD_CmdResp1Error(0x37u);
  if ( !v7 )
  {
    while ( !v2 && v1 < 0xFFFF )
    {
      sd_cmd_temp.CMDARG = 0;
      sd_cmd_temp.CMDINDEX = 55;
      sd_cmd_temp.WAITRESP = 64;
      sd_cmd_temp.field_C = 0;
      sd_cmd_temp.CPSMEN = 1024;
      SDIO_SendCommand(&sd_cmd_temp);
      v8 = SD_CmdResp1Error(0x37u);
      if ( v8 )
        return v8;
      sd_cmd_temp.CMDARG = v3 | 0x80100000;
      sd_cmd_temp.CMDINDEX = 41;
      sd_cmd_temp.WAITRESP = 64;
      sd_cmd_temp.field_C = 0;
      sd_cmd_temp.CPSMEN = 1024;
      SDIO_SendCommand(&sd_cmd_temp);
      v7 = sub_801FD34();
      if ( v7 )
        return v7;
      v0 = read_resp_word(0);
      v2 = v0 >> 31;
      ++v1;
    }
    if ( v1 >= 0xFFFF )
      return 27;
    if ( v0 & 0x40000000 )
      sdio_dword_20003998 = 2;
  }
  return v7;
}
// 200036B8: using guessed type int dword_200036B8;
// 200036BC: using guessed type int dword_200036BC;
// 200036C0: using guessed type int dword_200036C0;
// 200036C4: using guessed type int dword_200036C4;
// 200036C8: using guessed type int dword_200036C8;
// 200036CC: using guessed type char byte_200036CC;
// 20003724: using guessed type SDIO_CMD_ST sd_cmd_temp;
// 20003998: using guessed type int sdio_dword_20003998;

//----- (0801EF2E) --------------------------------------------------------
void turn_off_sd_card()
{
  set_sdio_power_reg(0);
}

//----- (0801EF3E) --------------------------------------------------------
signed int SD_Initialize_Cards()
{
  signed int result; // r0@2
  unsigned __int16 v1; // [sp+0h] [bp-10h]@1

  v1 = 1;
  if ( !sdio_power_enabled() )
    return 37;
  if ( sdio_dword_20003998 != 4 )
  {
    sd_cmd_temp.CMDARG = 0;
    sd_cmd_temp.CMDINDEX = 2;                   // ALL_SEND_CID
    sd_cmd_temp.WAITRESP = 192;
    sd_cmd_temp.field_C = 0;
    sd_cmd_temp.CPSMEN = 1024;
    SDIO_SendCommand(&sd_cmd_temp);
    LOBYTE(result) = wait_for_sd_cmd_resp();
    if ( (_BYTE)result )
      return (unsigned __int8)result;
    sd_resp_cid[0] = read_resp_word(0);
    sd_resp_cid[1] = read_resp_word(4);
    sd_resp_cid[2] = read_resp_word(8);
    sd_resp_cid[3] = read_resp_word(12);
  }
  if ( !sdio_dword_20003998 || sdio_dword_20003998 == 1 || sdio_dword_20003998 == 6 || sdio_dword_20003998 == 2 )
  {
    sd_cmd_temp.CMDARG = 0;
    sd_cmd_temp.CMDINDEX = 3;
    sd_cmd_temp.WAITRESP = 64;
    sd_cmd_temp.field_C = 0;
    sd_cmd_temp.CPSMEN = 1024;
    SDIO_SendCommand(&sd_cmd_temp);
    LOBYTE(result) = sub_801FDFC(3u, (int)&v1);
    if ( (_BYTE)result )
      return (unsigned __int8)result;
  }
  if ( sdio_dword_20003998 != 4 )
  {
    dword_2000399C = v1;
    sd_cmd_temp.CMDARG = v1 << 16;
    sd_cmd_temp.CMDINDEX = 9;                   // SEND_CSD
    sd_cmd_temp.WAITRESP = 192;
    sd_cmd_temp.field_C = 0;
    sd_cmd_temp.CPSMEN = 1024;
    SDIO_SendCommand(&sd_cmd_temp);
    LOBYTE(result) = wait_for_sd_cmd_resp();
    if ( (_BYTE)result )
      return (unsigned __int8)result;
    sd_resp_csd[0] = read_resp_word(0);
    sd_resp_csd[1] = read_resp_word(4);
    sd_resp_csd[2] = read_resp_word(8);
    sd_resp_csd[3] = read_resp_word(12);
  }
  return 0;
}
// 8020928: using guessed type int sdio_power_enabled(void);
// 20003724: using guessed type SDIO_CMD_ST sd_cmd_temp;
// 20003758: using guessed type int sd_resp_csd[4];
// 20003768: using guessed type int sd_resp_cid[4];
// 20003998: using guessed type int sdio_dword_20003998;
// 2000399C: using guessed type int dword_2000399C;

//----- (0801F0E0) --------------------------------------------------------
int __fastcall HAL_SD_GetCardInfo(int a1)
{
  unsigned int v1; // r4@1
  unsigned int v2; // r4@1
  unsigned int v3; // r4@3
  unsigned int v4; // r4@3
  __int64 v5; // r6@3
  signed int v6; // r2@3
  __int64 v7; // r8@3
  char v8; // r4@6
  unsigned int v9; // r4@6
  unsigned int v10; // r4@6
  unsigned int v11; // r4@6

  *(_BYTE *)(a1 + 86) = sdio_dword_20003998;
  *(_WORD *)(a1 + 84) = dword_2000399C;
  v1 = BYTE3(sd_resp_csd[0]);
  *(_BYTE *)a1 = BYTE3(sd_resp_csd[0]) >> 6;
  *(_BYTE *)(a1 + 1) = (v1 >> 2) & 0xF;
  *(_BYTE *)(a1 + 2) = v1 & 3;
  *(_BYTE *)(a1 + 3) = (unsigned int)sd_resp_csd[0] >> 16;
  *(_BYTE *)(a1 + 4) = BYTE1(sd_resp_csd[0]);
  *(_BYTE *)(a1 + 5) = LOBYTE(sd_resp_csd[0]);
  *(_WORD *)(a1 + 6) = 16 * BYTE3(sd_resp_csd[1]);
  LOBYTE(v1) = (unsigned int)sd_resp_csd[1] >> 16;
  *(_WORD *)(a1 + 6) |= (unsigned __int8)v1 >> 4;
  *(_BYTE *)(a1 + 8) = v1 & 0xF;
  v2 = BYTE1(sd_resp_csd[1]);
  *(_BYTE *)(a1 + 9) = BYTE1(sd_resp_csd[1]) >> 7;
  *(_BYTE *)(a1 + 10) = (v2 >> 6) & 1;
  *(_BYTE *)(a1 + 11) = (v2 >> 5) & 1;
  *(_BYTE *)(a1 + 12) = (v2 >> 4) & 1;
  *(_BYTE *)(a1 + 13) = 0;
  if ( sdio_dword_20003998 && sdio_dword_20003998 != 1 )
  {
    if ( sdio_dword_20003998 == 2 )
    {
      *(_DWORD *)(a1 + 16) = (sd_resp_csd[1] & 0x3F) << 16;
      *(_DWORD *)(a1 + 16) |= BYTE3(sd_resp_csd[2]) << 8;
      *(_DWORD *)(a1 + 16) |= (unsigned __int8)((unsigned int)sd_resp_csd[2] >> 16);
      v2 = (unsigned int)sd_resp_csd[2] >> 8;
      *(_QWORD *)(a1 + 72) = (unsigned int)((*(_DWORD *)(a1 + 16) + 1) << 19);
      *(_DWORD *)(a1 + 80) = 512;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 16) = (v2 & 3) << 10;
    *(_DWORD *)(a1 + 16) |= 4 * LOBYTE(sd_resp_csd[1]);
    v3 = BYTE3(sd_resp_csd[2]);
    *(_DWORD *)(a1 + 16) |= (unsigned __int8)(BYTE3(sd_resp_csd[2]) >> 6);
    *(_BYTE *)(a1 + 20) = (v3 >> 3) & 7;
    *(_BYTE *)(a1 + 21) = v3 & 7;
    v4 = (unsigned __int8)((unsigned int)sd_resp_csd[2] >> 16);
    *(_BYTE *)(a1 + 22) = (unsigned __int8)((unsigned int)sd_resp_csd[2] >> 16) >> 5;
    *(_BYTE *)(a1 + 23) = (v4 >> 2) & 7;
    *(_BYTE *)(a1 + 24) = 2 * (v4 & 3);
    v2 = BYTE1(sd_resp_csd[2]);
    *(_BYTE *)(a1 + 24) |= BYTE1(sd_resp_csd[2]) >> 7;
    *(_QWORD *)(a1 + 72) = (unsigned int)(*(_DWORD *)(a1 + 16) + 1);
    v5 = *(_QWORD *)(a1 + 72);
    v6 = 1 << (*(_BYTE *)(a1 + 24) + 2);
    v7 = (unsigned int)v6 * v5;
    HIDWORD(v7) += ((unsigned __int64)v6 >> 32) * v5;
    *(_QWORD *)(a1 + 72) = v7;
    *(_DWORD *)(a1 + 80) = 1 << *(_BYTE *)(a1 + 8);
    *(_QWORD *)(a1 + 72) *= *(_DWORD *)(a1 + 80);
  }
  *(_BYTE *)(a1 + 25) = (v2 >> 6) & 1;
  *(_BYTE *)(a1 + 26) = 2 * (v2 & 0x3F);
  v8 = LOBYTE(sd_resp_csd[2]);
  *(_BYTE *)(a1 + 26) |= LOBYTE(sd_resp_csd[2]) >> 7;
  *(_BYTE *)(a1 + 27) = v8 & 0x7F;
  v9 = BYTE3(sd_resp_csd[3]);
  *(_BYTE *)(a1 + 28) = BYTE3(sd_resp_csd[3]) >> 7;
  *(_BYTE *)(a1 + 29) = (v9 >> 5) & 3;
  *(_BYTE *)(a1 + 30) = (v9 >> 2) & 7;
  *(_BYTE *)(a1 + 31) = 4 * (v9 & 3);
  v10 = (unsigned __int8)((unsigned int)sd_resp_csd[3] >> 16);
  *(_BYTE *)(a1 + 31) |= (unsigned __int8)((unsigned int)sd_resp_csd[3] >> 16) >> 6;
  *(_BYTE *)(a1 + 32) = (v10 >> 5) & 1;
  *(_BYTE *)(a1 + 33) = 0;
  *(_BYTE *)(a1 + 34) = v10 & 1;
  v11 = BYTE1(sd_resp_csd[3]);
  *(_BYTE *)(a1 + 35) = BYTE1(sd_resp_csd[3]) >> 7;
  *(_BYTE *)(a1 + 36) = (v11 >> 6) & 1;
  *(_BYTE *)(a1 + 37) = (v11 >> 5) & 1;
  *(_BYTE *)(a1 + 38) = (v11 >> 4) & 1;
  *(_BYTE *)(a1 + 39) = (v11 >> 2) & 3;
  *(_BYTE *)(a1 + 40) = v11 & 3;
  *(_BYTE *)(a1 + 41) = LOBYTE(sd_resp_csd[3]) >> 1;
  *(_BYTE *)(a1 + 42) = 1;
  *(_BYTE *)(a1 + 44) = BYTE3(sd_resp_cid[0]);
  *(_WORD *)(a1 + 46) = (unsigned __int8)((unsigned int)sd_resp_cid[0] >> 16) << 8;
  *(_WORD *)(a1 + 46) |= BYTE1(sd_resp_cid[0]);
  *(_DWORD *)(a1 + 48) = LOBYTE(sd_resp_cid[0]) << 24;
  *(_DWORD *)(a1 + 48) |= BYTE3(sd_resp_cid[1]) << 16;
  *(_DWORD *)(a1 + 48) |= (unsigned __int8)((unsigned int)sd_resp_cid[1] >> 16) << 8;
  *(_DWORD *)(a1 + 48) |= BYTE1(sd_resp_cid[1]);
  *(_BYTE *)(a1 + 52) = LOBYTE(sd_resp_cid[1]);
  *(_BYTE *)(a1 + 53) = BYTE3(sd_resp_cid[2]);
  *(_DWORD *)(a1 + 56) = (unsigned __int8)((unsigned int)sd_resp_cid[2] >> 16) << 24;
  *(_DWORD *)(a1 + 56) |= BYTE1(sd_resp_cid[2]) << 16;
  *(_DWORD *)(a1 + 56) |= LOBYTE(sd_resp_cid[2]) << 8;
  *(_DWORD *)(a1 + 56) |= BYTE3(sd_resp_cid[3]);
  LOBYTE(v11) = (unsigned int)sd_resp_cid[3] >> 16;
  *(_BYTE *)(a1 + 60) |= (unsigned __int8)v11 >> 4;
  *(_WORD *)(a1 + 62) = (v11 & 0xF) << 8;
  *(_WORD *)(a1 + 62) |= BYTE1(sd_resp_cid[3]);
  *(_BYTE *)(a1 + 64) = LOBYTE(sd_resp_cid[3]) >> 1;
  *(_BYTE *)(a1 + 65) = 1;
  return 0;
}
// 20003758: using guessed type int sd_resp_csd[4];
// 20003768: using guessed type int sd_resp_cid[4];
// 20003998: using guessed type int sdio_dword_20003998;
// 2000399C: using guessed type int dword_2000399C;

//----- (0801F4B0) --------------------------------------------------------
signed int __fastcall sub_801F4B0(int a1)
{
  unsigned __int8 v1; // r5@1

  v1 = 0;
  if ( sdio_dword_20003998 == 3 )
    return 39;
  if ( !sdio_dword_20003998 || sdio_dword_20003998 == 1 || sdio_dword_20003998 == 2 )
  {
    if ( a1 == 4096 )
      return 39;
    if ( a1 == 2048 )
    {
      v1 = sd_switch_some_kind_of_func(1);
      if ( !v1 )
      {
        byte_200036CC = 1;
        dword_200036B8 = 0;
        dword_200036BC = 0;
        dword_200036C0 = 0;
        dword_200036C4 = 2048;
        dword_200036C8 = 0;
        something_gnarly_with_sdio_clk((int)&dword_200036B8);
      }
    }
    else
    {
      v1 = sd_switch_some_kind_of_func(0);
      if ( !v1 )
      {
        byte_200036CC = 1;
        dword_200036B8 = 0;
        dword_200036BC = 0;
        dword_200036C0 = 0;
        dword_200036C4 = 0;
        dword_200036C8 = 0;
        something_gnarly_with_sdio_clk((int)&dword_200036B8);
      }
    }
  }
  return v1;
}
// 200036B8: using guessed type int dword_200036B8;
// 200036BC: using guessed type int dword_200036BC;
// 200036C0: using guessed type int dword_200036C0;
// 200036C4: using guessed type int dword_200036C4;
// 200036C8: using guessed type int dword_200036C8;
// 200036CC: using guessed type char byte_200036CC;
// 20003998: using guessed type int sdio_dword_20003998;

//----- (0801F578) --------------------------------------------------------
int __fastcall SD_Select_Deselect(int a1)
{
  sd_cmd_temp.CMDARG = a1;
  sd_cmd_temp.CMDINDEX = 7;
  sd_cmd_temp.WAITRESP = 64;
  sd_cmd_temp.field_C = 0;
  sd_cmd_temp.CPSMEN = 1024;
  SDIO_SendCommand(&sd_cmd_temp);
  return (unsigned __int8)SD_CmdResp1Error(7u);
}
// 20003724: using guessed type SDIO_CMD_ST sd_cmd_temp;

//----- (0801F5B0) --------------------------------------------------------
signed int __fastcall HAL_SD_ReadBlocks(int a1, int a2, unsigned __int64 a3, signed __int16 a4)
{
  int v4; // r7@1
  unsigned __int64 v5; // r4@1
  signed __int16 v6; // r6@1
  signed int result; // r0@3
  unsigned __int8 v8; // r8@5

  v4 = a1;
  LODWORD(v5) = a3;
  v6 = a4;
  sdio_err_state = 0;
  sdio_dword_200039A4 = 0;
  sdio_dword_200039A0 = 0;
  SDIO_DCTRL = 0;
  if ( sdio_dword_20003998 == 2 )
  {
    v6 = 512;
    v5 = a3 >> 9;
  }
  sd_cmd_temp.CMDARG = (unsigned __int16)v6;
  sd_cmd_temp.CMDINDEX = 0x10;
  sd_cmd_temp.WAITRESP = 64;
  sd_cmd_temp.field_C = 0;
  sd_cmd_temp.CPSMEN = 1024;
  SDIO_SendCommand(&sd_cmd_temp);
  result = SD_CmdResp1Error(0x10u);
  if ( result )
  {
    result = (unsigned __int8)result;
  }
  else
  {
    sdio_dword_200036D0 = -1;
    sdio_dword_200036D4 = (unsigned __int16)v6;
    sdio_dword_200036D8 = 144;
    sdio_dword_200036DC = 2;
    sdio_dword_200036E0 = 0;
    sdio_dword_200036E4 = 1;
    SDIO_DataConfig((int)&sdio_dword_200036D0);
    sd_cmd_temp.CMDARG = v5;
    sd_cmd_temp.CMDINDEX = 17;
    sd_cmd_temp.WAITRESP = 64;
    sd_cmd_temp.field_C = 0;
    sd_cmd_temp.CPSMEN = 1024;
    SDIO_SendCommand(&sd_cmd_temp);
    result = SD_CmdResp1Error(0x11u);
    v8 = result;
    if ( result )
    {
      result = (unsigned __int8)result;
    }
    else
    {
      set_sdio_mask(810, 1);
      sdio_sub_8020932(1);
      sdio_something(v4, (unsigned __int16)v6);
      result = v8;
    }
  }
  return result;
}
// 200036D0: using guessed type int sdio_dword_200036D0;
// 200036D4: using guessed type int sdio_dword_200036D4;
// 200036D8: using guessed type int sdio_dword_200036D8;
// 200036DC: using guessed type int sdio_dword_200036DC;
// 200036E0: using guessed type int sdio_dword_200036E0;
// 200036E4: using guessed type int sdio_dword_200036E4;
// 20003724: using guessed type SDIO_CMD_ST sd_cmd_temp;
// 20003998: using guessed type int sdio_dword_20003998;
// 200039A0: using guessed type int sdio_dword_200039A0;
// 200039A4: using guessed type int sdio_dword_200039A4;
// 20003B77: using guessed type char sdio_err_state;
// 40012C2C: using guessed type int SDIO_DCTRL;

//----- (0801F6E4) --------------------------------------------------------
signed int __fastcall prob_write_sd_block(int a1, int a2, unsigned __int64 a3, signed __int16 a4, int a5)
{
  int v5; // r7@1
  unsigned __int64 v6; // r4@1
  signed __int16 v7; // r6@1
  signed int result; // r0@3
  unsigned __int8 v9; // r9@9

  v5 = a1;
  LODWORD(v6) = a3;
  v7 = a4;
  sdio_err_state = 0;
  sdio_dword_200039A4 = 0;
  sdio_dword_200039A0 = 1;
  SDIO_DCTRL = 0;
  if ( sdio_dword_20003998 == 2 )
  {
    v7 = 512;
    v6 = a3 >> 9;
  }
  sd_cmd_temp.CMDARG = (unsigned __int16)v7;
  sd_cmd_temp.CMDINDEX = 16;
  sd_cmd_temp.WAITRESP = 64;
  sd_cmd_temp.field_C = 0;
  sd_cmd_temp.CPSMEN = 1024;
  SDIO_SendCommand(&sd_cmd_temp);
  result = SD_CmdResp1Error(0x10u);
  if ( result )
  {
    result = (unsigned __int8)result;
  }
  else
  {
    sd_cmd_temp.CMDARG = dword_2000399C << 16;
    sd_cmd_temp.CMDINDEX = 55;
    sd_cmd_temp.WAITRESP = 64;
    sd_cmd_temp.field_C = 0;
    sd_cmd_temp.CPSMEN = 1024;
    SDIO_SendCommand(&sd_cmd_temp);
    result = SD_CmdResp1Error(0x37u);
    if ( result )
    {
      result = (unsigned __int8)result;
    }
    else
    {
      sd_cmd_temp.CMDARG = a5;
      sd_cmd_temp.CMDINDEX = 23;
      sd_cmd_temp.WAITRESP = 64;
      sd_cmd_temp.field_C = 0;
      sd_cmd_temp.CPSMEN = 1024;
      SDIO_SendCommand(&sd_cmd_temp);
      result = SD_CmdResp1Error(0x17u);
      if ( result )
      {
        result = (unsigned __int8)result;
      }
      else
      {
        sd_cmd_temp.CMDARG = v6;
        sd_cmd_temp.CMDINDEX = 25;
        sd_cmd_temp.WAITRESP = 64;
        sd_cmd_temp.field_C = 0;
        sd_cmd_temp.CPSMEN = 1024;
        SDIO_SendCommand(&sd_cmd_temp);
        result = SD_CmdResp1Error(0x19u);
        v9 = result;
        if ( result )
        {
          result = (unsigned __int8)result;
        }
        else
        {
          sdio_dword_200036D0 = -1;
          sdio_dword_200036D4 = (unsigned __int16)v7 * a5;
          sdio_dword_200036D8 = 144;
          sdio_dword_200036DC = 0;
          sdio_dword_200036E0 = 0;
          sdio_dword_200036E4 = 1;
          SDIO_DataConfig((int)&sdio_dword_200036D0);
          set_sdio_mask(810, 1);
          sdio_sub_8020932(1);
          sub_80203C4(v5, (unsigned __int16)v7 * a5);
          result = v9;
        }
      }
    }
  }
  return result;
}
// 200036D0: using guessed type int sdio_dword_200036D0;
// 200036D4: using guessed type int sdio_dword_200036D4;
// 200036D8: using guessed type int sdio_dword_200036D8;
// 200036DC: using guessed type int sdio_dword_200036DC;
// 200036E0: using guessed type int sdio_dword_200036E0;
// 200036E4: using guessed type int sdio_dword_200036E4;
// 20003724: using guessed type SDIO_CMD_ST sd_cmd_temp;
// 20003998: using guessed type int sdio_dword_20003998;
// 2000399C: using guessed type int dword_2000399C;
// 200039A0: using guessed type int sdio_dword_200039A0;
// 200039A4: using guessed type int sdio_dword_200039A4;
// 20003B77: using guessed type char sdio_err_state;
// 40012C2C: using guessed type int SDIO_DCTRL;

//----- (0801F8C4) --------------------------------------------------------
signed int sub_801F8C4()
{
  unsigned __int8 v0; // r4@1
  signed int result; // r0@7

  v0 = 0;
  dword_200039AC = 1000;
  while ( !dword_200039A8 && !sdio_dword_200039A4 && !sdio_err_state && dword_200039AC )
  {
    --dword_200039AC;
    if ( !dword_200039AC )
      return 4;
  }
  dword_200039A8 = 0;
  dword_200039AC = 1000;
  while ( SDIO_STA & 0x1000 && dword_200039AC )
  {
    --dword_200039AC;
    if ( !dword_200039AC )
      return 4;
  }
  if ( sdio_dword_200039A0 == 1 )
    v0 = sd_stop_transmission();
  set_sdio_icr(1535);
  if ( sdio_err_state )
    result = (unsigned __int8)sdio_err_state;
  else
    result = v0;
  return result;
}
// 200039A0: using guessed type int sdio_dword_200039A0;
// 200039A4: using guessed type int sdio_dword_200039A4;
// 200039A8: using guessed type int dword_200039A8;
// 200039AC: using guessed type int dword_200039AC;
// 20003B77: using guessed type char sdio_err_state;
// 40012C34: using guessed type int SDIO_STA;

//----- (0801F9A2) --------------------------------------------------------
int sd_stop_transmission()
{
  sd_cmd_temp.CMDARG = 0;
  sd_cmd_temp.CMDINDEX = 12;
  sd_cmd_temp.WAITRESP = 64;
  sd_cmd_temp.field_C = 0;
  sd_cmd_temp.CPSMEN = 1024;
  SDIO_SendCommand(&sd_cmd_temp);
  return (unsigned __int8)SD_CmdResp1Error(0xCu);
}
// 20003724: using guessed type SDIO_CMD_ST sd_cmd_temp;

//----- (0801F9EC) --------------------------------------------------------
signed int __fastcall sd_get_status(int a1)
{
  int v1; // r4@1
  signed int result; // r0@2
  unsigned __int8 v3; // r5@3

  v1 = a1;
  if ( a1 )
  {
    sd_cmd_temp.CMDARG = dword_2000399C << 16;
    sd_cmd_temp.CMDINDEX = 13;
    sd_cmd_temp.WAITRESP = 64;
    sd_cmd_temp.field_C = 0;
    sd_cmd_temp.CPSMEN = 1024;
    SDIO_SendCommand(&sd_cmd_temp);
    LOBYTE(result) = SD_CmdResp1Error(0xDu);
    v3 = result;
    if ( (_BYTE)result )
    {
      result = (unsigned __int8)result;
    }
    else
    {
      *(_DWORD *)v1 = read_resp_word(0);
      result = v3;
    }
  }
  else
  {
    result = 38;
  }
  return result;
}
// 20003724: using guessed type SDIO_CMD_ST sd_cmd_temp;
// 2000399C: using guessed type int dword_2000399C;

//----- (0801FA5A) --------------------------------------------------------
void __fastcall SDIO_interrupt_real()
{
  if ( get_sdio_sta_0(256) )
  {
    sdio_err_state = 0;
    set_sdio_icr_0(256);
    sdio_dword_200039A4 = 1;
  }
  else if ( get_sdio_sta_0(2) )
  {
    set_sdio_icr_0(2);
    sdio_err_state = 2;
  }
  else if ( get_sdio_sta_0(8) )
  {
    set_sdio_icr_0(8);
    sdio_err_state = 4;
  }
  else if ( get_sdio_sta_0(32) )
  {
    set_sdio_icr_0(32);
    sdio_err_state = 6;
  }
  else if ( get_sdio_sta_0(16) )
  {
    set_sdio_icr_0(16);
    sdio_err_state = 5;
  }
  else if ( get_sdio_sta_0(512) )
  {
    set_sdio_icr_0(512);
    sdio_err_state = 7;
  }
  set_sdio_mask(49978, 0);
}
// 200039A4: using guessed type int sdio_dword_200039A4;
// 20003B77: using guessed type char sdio_err_state;

//----- (0801FB08) --------------------------------------------------------
void __fastcall DMA2_CH4_interrupt_real()
{
  if ( v40026400 & 0x10002000 )
  {
    dword_200039A8 = 1;
    sub_8020AC4(268496896);
  }
}
// 200039A8: using guessed type int dword_200039A8;

//----- (0801FB3C) --------------------------------------------------------
signed int sub_801FB3C()
{
  signed int v0; // r5@1
  signed int v1; // r6@1
  signed int result; // r0@5

  v0 = 0x10000;
  v1 = 20000;
  while ( v0 && !get_sdio_sta(128) )
  {
    --v0;
    --v1;
    if ( !v1 )
      return 3;
  }
  if ( v0 )
  {
    set_sdio_icr(1535);
    result = 0;
  }
  else
  {
    result = 3;
  }
  return result;
}

//----- (0801FB88) --------------------------------------------------------
signed int sub_801FB88()
{
  signed int v0; // r7@1
  char v1; // r5@1
  signed int v2; // r6@1
  signed int result; // r0@5

  v0 = 0x10000;
  v1 = SDIO_STA;
  v2 = 20000;
  while ( !(v1 & 0x45) && v0 )
  {
    --v0;
    v1 = SDIO_STA;
    --v2;
    if ( !v2 )
    {
      set_sdio_icr(4);
      return 3;
    }
  }
  if ( v0 && !(v1 & 4) )
  {
    if ( v1 & 0x40 )
    {
      set_sdio_icr(64);
      result = 0;
    }
    else
    {
      result = 0;
    }
  }
  else
  {
    set_sdio_icr(4);
    result = 3;
  }
  return result;
}
// 40012C34: using guessed type int SDIO_STA;

//----- (0801FC00) --------------------------------------------------------
signed int __fastcall SD_CmdResp1Error(unsigned __int8 a1)
{
  unsigned __int8 v1; // r4@1
  char v2; // r6@1
  signed int v3; // r8@1
  signed int result; // r0@4
  int v5; // r0@9
  int v6; // r7@11

  v1 = a1;
  v2 = SDIO_STA;
  v3 = 20000;
  while ( !(v2 & 0x45) )
  {
    v2 = SDIO_STA;
    --v3;
    if ( !v3 )
    {
      set_sdio_icr(4);
      return 3;
    }
  }
  if ( v2 & 4 )
  {
    set_sdio_icr(4);
    result = 3;
  }
  else if ( v2 & 1 )
  {
    set_sdio_icr(1);
    result = 1;
  }
  else
  {
    LOBYTE(v5) = get_sdio_respcmd();
    if ( v5 == v1 )
    {
      set_sdio_icr(1535);
      v6 = read_resp_word(0);
      if ( v6 & 0xFDFFE008 )
      {
        if ( v6 >= 0 )
        {
          if ( v6 & 0x40000000 )
          {
            result = 9;
          }
          else if ( v6 & 0x20000000 )
          {
            result = 10;
          }
          else if ( v6 & 0x10000000 )
          {
            result = 11;
          }
          else if ( v6 & 0x8000000 )
          {
            result = 12;
          }
          else if ( v6 & 0x4000000 )
          {
            result = 13;
          }
          else if ( v6 & 0x1000000 )
          {
            result = 14;
          }
          else if ( v6 & 0x800000 )
          {
            result = 15;
          }
          else if ( v6 & 0x400000 )
          {
            result = 16;
          }
          else if ( v6 & 0x200000 )
          {
            result = 17;
          }
          else if ( v6 & 0x100000 )
          {
            result = 18;
          }
          else if ( v6 & 0x80000 )
          {
            result = 19;
          }
          else if ( v6 & 0x40000 )
          {
            result = 20;
          }
          else if ( v6 & 0x20000 )
          {
            result = 21;
          }
          else if ( v6 & 0x10000 )
          {
            result = 22;
          }
          else if ( v6 & 0x8000 )
          {
            result = 23;
          }
          else if ( v6 & 0x4000 )
          {
            result = 24;
          }
          else if ( v6 & 0x2000 )
          {
            result = 25;
          }
          else if ( v6 & 8 )
          {
            result = 26;
          }
          else
          {
            result = 0;
          }
        }
        else
        {
          result = 28;
        }
      }
      else
      {
        result = 0;
      }
    }
    else
    {
      result = 16;
    }
  }
  return result;
}
// 40012C34: using guessed type int SDIO_STA;

//----- (0801FD34) --------------------------------------------------------
signed int sub_801FD34()
{
  char v0; // r5@1
  signed int v1; // r6@1
  signed int result; // r0@4

  v0 = SDIO_STA;
  v1 = 20000;
  while ( !(v0 & 0x45) )
  {
    v0 = SDIO_STA;
    --v1;
    if ( !v1 )
    {
      set_sdio_icr(4);
      return 3;
    }
  }
  if ( v0 & 4 )
  {
    set_sdio_icr(4);
    result = 3;
  }
  else
  {
    set_sdio_icr(1535);
    result = 0;
  }
  return result;
}
// 40012C34: using guessed type int SDIO_STA;

//----- (0801FD8C) --------------------------------------------------------
signed int wait_for_sd_cmd_resp()
{
  char v0; // r5@1
  signed int v1; // r6@1
  signed int result; // r0@4

  v0 = SDIO_STA;
  v1 = 20000;
  while ( !(v0 & 0x45) )
  {
    v0 = SDIO_STA;
    --v1;
    if ( !v1 )
    {
      set_sdio_icr(4);
      return 3;
    }
  }
  if ( v0 & 4 )
  {
    set_sdio_icr(4);
    result = 3;
  }
  else if ( v0 & 1 )
  {
    set_sdio_icr(1);
    result = 1;
  }
  else
  {
    set_sdio_icr(1535);
    result = 0;
  }
  return result;
}
// 40012C34: using guessed type int SDIO_STA;

//----- (0801FDFC) --------------------------------------------------------
signed int __fastcall sub_801FDFC(unsigned __int8 a1, int a2)
{
  unsigned __int8 v2; // r4@1
  int v3; // r5@1
  char v4; // r7@1
  signed int v5; // r9@1
  signed int result; // r0@4
  int v7; // r0@9
  int v8; // r0@11

  v2 = a1;
  v3 = a2;
  v4 = SDIO_STA;
  v5 = 20000;
  while ( !(v4 & 0x45) )
  {
    v4 = SDIO_STA;
    --v5;
    if ( !v5 )
    {
      set_sdio_icr(4);
      return 3;
    }
  }
  if ( v4 & 4 )
  {
    set_sdio_icr(4);
    result = 3;
  }
  else if ( v4 & 1 )
  {
    set_sdio_icr(1);
    result = 1;
  }
  else
  {
    LOBYTE(v7) = get_sdio_respcmd();
    if ( v7 == v2 )
    {
      set_sdio_icr(1535);
      v8 = read_resp_word(0);
      if ( v8 & 0xE000 )
      {
        if ( v8 & 0x2000 )
        {
          result = 19;
        }
        else if ( v8 & 0x4000 )
        {
          result = 16;
        }
        else if ( v8 & 0x8000 )
        {
          result = 15;
        }
        else
        {
          result = 0;
        }
      }
      else
      {
        *(_WORD *)v3 = HIWORD(v8);
        result = 0;
      }
    }
    else
    {
      result = 16;
    }
  }
  return result;
}
// 40012C34: using guessed type int SDIO_STA;

//----- (0801FEC8) --------------------------------------------------------
signed int __fastcall sd_switch_some_kind_of_func(char a1)
{
  char v1; // r4@1
  signed int result; // r0@2
  int v3; // [sp+0h] [bp-18h]@1
  int v4; // [sp+4h] [bp-14h]@1

  v1 = a1;
  v3 = 0;
  v4 = 0;
  if ( read_resp_word(0) & 0x2000000 )
  {
    result = 14;
  }
  else
  {
    LOBYTE(result) = sub_8020068((unsigned __int16)dword_2000399C, (int)&v3);
    if ( (_BYTE)result )
    {
      result = (unsigned __int8)result;
    }
    else if ( v1 == 1 )
    {
      if ( v4 & 0x40000 )
      {
        sd_cmd_temp.CMDARG = dword_2000399C << 16;
        sd_cmd_temp.CMDINDEX = 55;
        sd_cmd_temp.WAITRESP = 64;
        sd_cmd_temp.field_C = 0;
        sd_cmd_temp.CPSMEN = 1024;
        SDIO_SendCommand(&sd_cmd_temp);
        LOBYTE(result) = SD_CmdResp1Error(0x37u);
        if ( (_BYTE)result )
        {
          result = (unsigned __int8)result;
        }
        else
        {
          sd_cmd_temp.CMDARG = 2;
          sd_cmd_temp.CMDINDEX = 6;
          sd_cmd_temp.WAITRESP = 64;
          sd_cmd_temp.field_C = 0;
          sd_cmd_temp.CPSMEN = 1024;
          SDIO_SendCommand(&sd_cmd_temp);
          LOBYTE(result) = SD_CmdResp1Error(6u);
          if ( (_BYTE)result )
            result = (unsigned __int8)result;
          else
            result = 0;
        }
      }
      else
      {
        result = 37;
      }
    }
    else if ( v4 & 0x10000 )
    {
      sd_cmd_temp.CMDARG = dword_2000399C << 16;
      sd_cmd_temp.CMDINDEX = 55;
      sd_cmd_temp.WAITRESP = 64;
      sd_cmd_temp.field_C = 0;
      sd_cmd_temp.CPSMEN = 1024;
      SDIO_SendCommand(&sd_cmd_temp);
      LOBYTE(result) = SD_CmdResp1Error(0x37u);
      if ( (_BYTE)result )
      {
        result = (unsigned __int8)result;
      }
      else
      {
        sd_cmd_temp.CMDARG = 0;
        sd_cmd_temp.CMDINDEX = 6;
        sd_cmd_temp.WAITRESP = 64;
        sd_cmd_temp.field_C = 0;
        sd_cmd_temp.CPSMEN = 1024;
        SDIO_SendCommand(&sd_cmd_temp);
        LOBYTE(result) = SD_CmdResp1Error(6u);
        if ( (_BYTE)result )
          result = (unsigned __int8)result;
        else
          result = 0;
      }
    }
    else
    {
      result = 37;
    }
  }
  return result;
}
// 20003724: using guessed type SDIO_CMD_ST sd_cmd_temp;
// 2000399C: using guessed type int dword_2000399C;

//----- (08020068) --------------------------------------------------------
signed int __fastcall sub_8020068(int a1, int a2)
{
  int v2; // r5@1
  int v3; // r6@1
  signed int result; // r0@1
  unsigned __int8 v5; // r7@5
  signed int v6; // r8@7
  unsigned int v7; // [sp+0h] [bp-20h]@1
  unsigned int v8; // [sp+4h] [bp-1Ch]@1

  v2 = a2;
  v3 = 0;
  v7 = 0;
  v8 = 0;
  sd_cmd_temp.CMDARG = 8;
  sd_cmd_temp.CMDINDEX = 16;
  sd_cmd_temp.WAITRESP = 64;
  sd_cmd_temp.field_C = 0;
  sd_cmd_temp.CPSMEN = 1024;
  SDIO_SendCommand(&sd_cmd_temp);
  LOBYTE(result) = SD_CmdResp1Error(0x10u);
  if ( (_BYTE)result )
  {
    result = (unsigned __int8)result;
  }
  else
  {
    sd_cmd_temp.CMDARG = dword_2000399C << 16;
    sd_cmd_temp.CMDINDEX = 55;
    sd_cmd_temp.WAITRESP = 64;
    sd_cmd_temp.field_C = 0;
    sd_cmd_temp.CPSMEN = 1024;
    SDIO_SendCommand(&sd_cmd_temp);
    LOBYTE(result) = SD_CmdResp1Error(0x37u);
    if ( (_BYTE)result )
    {
      result = (unsigned __int8)result;
    }
    else
    {
      sdio_dword_200036D0 = -1;
      sdio_dword_200036D4 = 8;
      sdio_dword_200036D8 = 48;
      sdio_dword_200036DC = 2;
      sdio_dword_200036E0 = 0;
      sdio_dword_200036E4 = 1;
      SDIO_DataConfig((int)&sdio_dword_200036D0);
      sd_cmd_temp.CMDARG = 0;
      sd_cmd_temp.CMDINDEX = 51;
      sd_cmd_temp.WAITRESP = 64;
      sd_cmd_temp.field_C = 0;
      sd_cmd_temp.CPSMEN = 1024;
      SDIO_SendCommand(&sd_cmd_temp);
      LOBYTE(result) = SD_CmdResp1Error(0x33u);
      v5 = result;
      if ( (_BYTE)result )
      {
        result = (unsigned __int8)result;
      }
      else
      {
        v6 = 20000;
        while ( !(SDIO_STA & 0x62A) )
        {
          if ( get_sdio_sta(0x200000) )
            *(&v7 + v3++) = read_sdio_fifo();
          --v6;
          if ( !v6 )
          {
            set_sdio_icr(8);
            return 4;
          }
        }
        if ( get_sdio_sta(8) )
        {
          set_sdio_icr(8);
          result = 4;
        }
        else if ( get_sdio_sta(2) )
        {
          set_sdio_icr(2);
          result = 2;
        }
        else if ( get_sdio_sta(32) )
        {
          set_sdio_icr(32);
          result = 6;
        }
        else if ( get_sdio_sta(512) )
        {
          set_sdio_icr(512);
          result = 7;
        }
        else
        {
          set_sdio_icr(1535);
          *(_DWORD *)(v2 + 4) = ((unsigned __int16)(v7 & 0xFF00) << 8) | (v7 << 24) | (v7 >> 8) & 0xFF00 | (v7 >> 24);
          *(_DWORD *)v2 = ((unsigned __int16)(v8 & 0xFF00) << 8) | (v8 << 24) | (v8 >> 8) & 0xFF00 | (v8 >> 24);
          result = v5;
        }
      }
    }
  }
  return result;
}
// 200036D0: using guessed type int sdio_dword_200036D0;
// 200036D4: using guessed type int sdio_dword_200036D4;
// 200036D8: using guessed type int sdio_dword_200036D8;
// 200036DC: using guessed type int sdio_dword_200036DC;
// 200036E0: using guessed type int sdio_dword_200036E0;
// 200036E4: using guessed type int sdio_dword_200036E4;
// 20003724: using guessed type SDIO_CMD_ST sd_cmd_temp;
// 2000399C: using guessed type int dword_2000399C;
// 40012C34: using guessed type int SDIO_STA;

//----- (0802027C) --------------------------------------------------------
int __fastcall strlen(int a1)
{
  int v1; // r3@1
  int v2; // t1@2
  int i; // r2@4
  int v4; // t1@6
  int j; // r1@7
  int v6; // t1@7
  int v7; // t1@9

  v1 = a1 + 1;
  if ( a1 << 30 )
  {
    while ( 1 )
    {
      v2 = *(_BYTE *)a1++;
      if ( !v2 )
        break;
      if ( !(a1 << 30) )
        goto LABEL_4;
    }
  }
  else
  {
LABEL_4:
    for ( i = *(_DWORD *)a1; !((i - 0x1010101) & ~i & 0x80808080); i = v4 )
    {
      v4 = *(_DWORD *)(a1 + 4);
      a1 += 4;
    }
    v6 = *(_BYTE *)a1++;
    for ( j = v6; j; j = v7 )
      v7 = *(_BYTE *)a1++;
  }
  return a1 - v1;
}

//----- (080202B4) --------------------------------------------------------
void disable_sd_card_hw()
{
  GPIO_CONFIG cfg; // [sp+0h] [bp-10h]@1

  HAL_set_sdio_clken(0);
  set_sdio_power_reg(0);
  reset_sdio_periph();
  set_APB2_periph_clock(0x800, 0);
  set_gpio_pin_func(&GPIOC, 8u, 0);
  set_gpio_pin_func(&GPIOC, 0xCu, 0);
  set_gpio_pin_func(&GPIOD, 2u, 0);
  cfg.pins = 256;
  cfg.mode = 0;
  cfg.pull = 0;
  gpio_config_pin(&GPIOC, &cfg);
  cfg.pins = 4;
  gpio_config_pin(&GPIOD, &cfg);
  cfg.pins = 4096;
  gpio_config_pin(&GPIOC, &cfg);
}
// 40020800: using guessed type GPIO_REGS GPIOC;
// 40020C00: using guessed type GPIO_REGS GPIOD;

//----- (08020332) --------------------------------------------------------
void HAL_SD_MspInit()
{
  GPIO_CONFIG cfg; // [sp+0h] [bp-10h]@1

  set_AHB_periph_clk(0xC, 1);
  set_gpio_pin_func(&GPIOC, 8u, 0xCu);
  set_gpio_pin_func(&GPIOC, 0xCu, 0xCu);
  set_gpio_pin_func(&GPIOD, 2u, 0xCu);
  cfg = (GPIO_CONFIG)0x100030200000100LL;
  gpio_config_pin(&GPIOC, &cfg);
  cfg.pins = 4;
  gpio_config_pin(&GPIOD, &cfg);
  cfg.pins = 4096;
  cfg.pull = 0;
  gpio_config_pin(&GPIOC, &cfg);
  set_APB2_periph_clock(2048, 1);
  set_AHB_periph_clk(0x2000000, 1);
}
// 40020800: using guessed type GPIO_REGS GPIOC;
// 40020C00: using guessed type GPIO_REGS GPIOD;

//----- (080203C4) --------------------------------------------------------
int __fastcall sub_80203C4(int a1, unsigned int a2)
{
  int v2; // r4@1
  unsigned int v3; // r5@1
  int *v5; // [sp+0h] [bp-38h]@1
  int v6; // [sp+4h] [bp-34h]@1
  int v7; // [sp+8h] [bp-30h]@1
  unsigned int v8; // [sp+Ch] [bp-2Ch]@1
  int v9; // [sp+10h] [bp-28h]@1
  int v10; // [sp+14h] [bp-24h]@1
  int v11; // [sp+18h] [bp-20h]@1
  int v12; // [sp+1Ch] [bp-1Ch]@1
  int v13; // [sp+20h] [bp-18h]@1
  int v14; // [sp+24h] [bp-14h]@1
  int v15; // [sp+28h] [bp-10h]@1

  v2 = a1;
  v3 = a2;
  sub_8020AC4(0x1000F000);
  sub_8020A92(0x40026444, 0);
  v5 = &SDIO_FIFO;
  v6 = v2;
  v7 = 16;
  v8 = v3 >> 2;
  v9 = 0;
  v10 = 128;
  v11 = 512;
  v12 = 2048;
  v13 = 0;
  v14 = 0x2000;
  v15 = 0;
  sub_8020A54(0x40026444, (int)&v5);
  sub_8020AAE(0x40026444, 2, 1);
  return sub_8020A92(0x40026444, 1);
}
// 40012C80: using guessed type int SDIO_FIFO;

//----- (08020434) --------------------------------------------------------
void __fastcall sdio_something(int a1, unsigned int a2)
{
  int v2; // r4@1
  unsigned int v3; // r5@1
  int *v4; // [sp+0h] [bp-38h]@1
  int v5; // [sp+4h] [bp-34h]@1
  int v6; // [sp+8h] [bp-30h]@1
  unsigned int v7; // [sp+Ch] [bp-2Ch]@1
  int v8; // [sp+10h] [bp-28h]@1
  int v9; // [sp+14h] [bp-24h]@1
  int v10; // [sp+18h] [bp-20h]@1
  int v11; // [sp+1Ch] [bp-1Ch]@1
  int v12; // [sp+20h] [bp-18h]@1
  int v13; // [sp+24h] [bp-14h]@1
  int v14; // [sp+28h] [bp-10h]@1

  v2 = a1;
  v3 = a2;
  sub_8020AC4(0x1000F000);
  sub_8020A92(0x40026444, 0);
  v4 = &SDIO_FIFO;
  v5 = v2;
  v6 = 0;
  v7 = v3 >> 2;
  v8 = 0;
  v9 = 128;
  v10 = 512;
  v11 = 2048;
  v12 = 0;
  v13 = 0x2000;
  v14 = 0;
  sub_8020A54(0x40026444, (int)&v4);
  sub_8020AAE(0x40026444, 2, 1);
  sub_8020A92(0x40026444, 1);
}
// 40012C80: using guessed type int SDIO_FIFO;

//----- (080204B8) --------------------------------------------------------
double __fastcall dp_from_int(int num)
{
  double result; // r0@2
  double v2; // r0@3
  int (__fastcall *v3)(_DWORD, _DWORD); // r12@3

  if ( num < 0 )
  {
    v2 = dp_from_uint_core(-num);
    LODWORD(result) = v3(LODWORD(v2), HIDWORD(v2) | 0x80000000);// return double v2 floating point negated
  }
  else
  {
    result = dp_from_uint_core(num);
  }
  return result;
}

//----- (080204CC) --------------------------------------------------------
double __fastcall dp_from_uint(unsigned int result)
{
  return dp_from_uint_core(result);
}

//----- (080204D0) --------------------------------------------------------
// local variable allocation has failed, the output may be wrong!
double __fastcall dp_from_uint_core(int num)
{
  char v1; // zf@0
  unsigned int v2; // r1@2
  unsigned int v3; // r0@2
  int v4; // r1@2

  if ( !v1 )
  {
    v2 = __clz(num);
    v3 = num << v2;
    v4 = ((1053 - v2) << 20) + (v3 >> 11);
    num = v3 << 21;
  }
  return *(double *)&num;
}
// 80204D0: variables would overlap: r0.4 and r0.8
// 80204D0: bad return variable

//----- (080204E8) --------------------------------------------------------
double __fastcall dp_sqrt(double num)
{
  int nexp; // r3@1
  unsigned int outexp; // r12@4
  int v3; // off@6
  unsigned int v4; // r4@7
  unsigned int v5; // r3@7
  unsigned int v6; // r2@7
  unsigned int v7; // r5@7
  unsigned __int64 v8; // r0@7
  char v9; // cf@8
  int v10; // off@9
  int v11; // off@11
  unsigned __int64 v12; // r0@16
  unsigned __int64 v13; // kr18_8@16
  int v14; // off@16
  unsigned __int64 v15; // r0@18
  unsigned __int64 v16; // kr28_8@18
  int v17; // off@18
  unsigned __int64 v18; // kr38_8@20
  int v19; // off@21
  unsigned int v20; // r3@24
  int v21; // r3@26

  nexp = HIDWORD(num) >> 20;
  if ( HIDWORD(num) >> 20 )
  {
    if ( (unsigned int)nexp >= 0x7FF )
    {
      if ( nexp != 2047 && HIDWORD(num) <= 0xFFF00000 )
      {
        HIDWORD(num) = LODWORD(num) | 2 * HIDWORD(num);
        if ( HIDWORD(num) )
          fp_set_nan_error();
      }
      return num;
    }
    HIDWORD(num) = HIDWORD(num) & ~(nexp << 20) | 0x100000;
  }
  else
  {
    if ( num == 0.0 )
      return num;
    v20 = __clz(HIDWORD(num));
    if ( !HIDWORD(num) )
      v20 += __clz(LODWORD(num));
    v21 = v20 - 11;
    if ( (unsigned int)v21 < 0x20 )
      HIDWORD(num) = (HIDWORD(num) << v21) | (LODWORD(num) >> (32 - v21));
    else
      HIDWORD(num) = LODWORD(num) << (v21 - 32);
    LODWORD(num) <<= v21;
    nexp = 1 - v21;
  }
  outexp = (unsigned int)(nexp + 1021) >> 1;
  if ( ((_BYTE)nexp - 3) & 1 )
  {
    v3 = *(_QWORD *)&num >> 31;
    LODWORD(num) *= 2;
    HIDWORD(num) += v3;
  }
  HIDWORD(num) = *(_QWORD *)&num >> 30;
  LODWORD(num) *= 4;
  v4 = 0x300000;
  v5 = 0;
  v6 = 0x80000000;
  v7 = 0x100000;
  HIDWORD(v8) = HIDWORD(num) - 0x900000;
  if ( SHIDWORD(v8) >= 0 )
  {
    do
    {
LABEL_8:
      v9 = v7 & 1;
      v7 >>= 1;
      if ( v9 )
        goto LABEL_18;
      HIDWORD(v8) -= v4;
      v4 += v7;
      v10 = v8 >> 31;
      LODWORD(v8) = 2 * v8;
      HIDWORD(v8) = HIDWORD(v8) + v10 - v7;
    }
    while ( (v8 & 0x8000000000000000LL) == 0LL );
  }
  v9 = v7 & 1;
  v7 >>= 1;
  if ( v9 )
    goto LABEL_16;
  do
  {
    HIDWORD(v8) += v4;
    v4 -= v7;
    v11 = v8 >> 31;
    LODWORD(v8) = 2 * v8;
    HIDWORD(v8) = HIDWORD(v8) + v11 - v7;
    if ( (v8 & 0x8000000000000000LL) == 0LL )
      goto LABEL_8;
    v9 = v7 & 1;
    v7 >>= 1;
  }
  while ( !v9 );
  while ( 1 )
  {
LABEL_16:
    v12 = v8 + __PAIR__(v4, v5);
    v13 = __PAIR__(v4, v5) - __PAIR__(v7, v6);
    v4 = (__PAIR__(v4, v5) - __PAIR__(v7, v6)) >> 32;
    v5 = v13;
    v14 = v12 >> 31;
    LODWORD(v12) = 2 * v12;
    HIDWORD(v12) += v14;
    v8 = v12 - __PAIR__(v7, v6);
    if ( SHIDWORD(v8) < 0 )
      goto LABEL_15;
    v6 >>= 1;
    if ( !v6 )
      break;
LABEL_18:
    while ( 1 )
    {
      v15 = v8 - __PAIR__(v4, v5);
      v16 = __PAIR__(v4, v5) + __PAIR__(v7, v6);
      v4 = (__PAIR__(v4, v5) + __PAIR__(v7, v6)) >> 32;
      v5 = v16;
      v17 = v15 >> 31;
      LODWORD(v15) = 2 * v15;
      HIDWORD(v15) += v17;
      v8 = v15 - __PAIR__(v7, v6);
      if ( SHIDWORD(v8) < 0 )
        break;
      v6 >>= 1;
      if ( !v6 )
        goto LABEL_20;
    }
LABEL_15:
    v6 >>= 1;
    if ( !v6 )
      goto LABEL_21;
  }
LABEL_20:
  v18 = __PAIR__(v4, v5) + __PAIR__(v7, 1);
  v4 = (__PAIR__(v4, v5) + __PAIR__(v7, 1)) >> 32;
  v5 = v18;
LABEL_21:
  v19 = __RCR__(v5, 1);
  LODWORD(num) = v19;
  HIDWORD(num) = (v4 >> 1) + (outexp << 20);
  return num;
}

//----- (080205D8) --------------------------------------------------------
float __fastcall fp_from_int64(__int64 num)
{
  char v1; // cf@2
  char v2; // zf@2
  unsigned int v3; // r2@10
  int v4; // r2@10

  if ( num >= 0 )
  {
    if ( !num )
      return *(float *)&num;
    v2 = HIDWORD(num) == 0;
  }
  else
  {
    v1 = (unsigned int)num <= 0;
    LODWORD(num) = -(signed int)num;
    HIDWORD(num) = -HIDWORD(num) - !v1;
    v2 = HIDWORD(num) == 0;
  }
  if ( v2 )
  {
    HIDWORD(num) = __clz(num);
    LODWORD(num) = (_DWORD)num << SBYTE4(num);
    HIDWORD(num) = 157 - HIDWORD(num);
  }
  else
  {
    v3 = __clz(HIDWORD(num));
    HIDWORD(num) ^= num;
    LODWORD(num) = (_DWORD)num << v3;
    v2 = (_DWORD)num == 0;
    v4 = 32 - v3;
    HIDWORD(num) = __ROR4__(HIDWORD(num), v4);
    LODWORD(num) = HIDWORD(num) ^ num;
    if ( !v2 )
      LODWORD(num) = num | 1;
    HIDWORD(num) = v4 + 157;
  }
  LODWORD(num) = ((unsigned int)num >> 8)
               + __CFADD__((_DWORD)num << 24, __CFSHL__(num, 24) + 0x7FFFFFFF)
               + (HIDWORD(num) << 23);
  return *(float *)&num;
}

//----- (0802063A) --------------------------------------------------------
double __fastcall dp_log10(double num)
{
  return dp_log_core(num, 1);
}

//----- (08020644) --------------------------------------------------------
double __fastcall dp_sub(double a, double b)
{
  if ( (HIDWORD(a) ^ HIDWORD(b)) < 0 )          // signs are different
    JUMPOUT(&loc_801C404);
  JUMPOUT(loc_8020658);                         // this function just jumps into the middle of add
}

//----- (080207C4) --------------------------------------------------------
int __fastcall sub_80207C4(int a1)
{
  return (unsigned __int8)HAL_SD_Init();
}

//----- (080207D6) --------------------------------------------------------
bool __fastcall isnt_zero(char a1)
{
  return a1 != 0;
}

//----- (080207E6) --------------------------------------------------------
signed int __fastcall sub_80207E6(int a1, int a2, int a3)
{
  signed int v3; // r4@1

  v3 = 20000;
  HAL_SD_ReadBlocks(a2, a2, (unsigned int)(a3 << 9), 512);
  while ( sub_801EC86() )
  {
    --v3;
    if ( !v3 )
      return 2;
  }
  return 0;
}

//----- (08020820) --------------------------------------------------------
signed int __fastcall prob_write_sd_blocks(int a1, int a2, int a3, unsigned __int8 a4)
{
  int v4; // r10@1
  int v5; // r5@1
  unsigned __int8 v6; // r6@1
  unsigned int i; // r7@1
  signed int v8; // r9@3

  v4 = a2;
  v5 = a3;
  v6 = a4;
  for ( i = 0; i < v6; ++i )
  {
    prob_write_sd_block(v4 + (i << 9), 512, (v5 << 9) + (i << 9), 512, 1);
    sub_801F8C4();
    v8 = 20000;
    while ( sub_801EC86() )
    {
      --v8;
      if ( !v8 )
        return 2;
    }
  }
  return 0;
}

//----- (08020894) --------------------------------------------------------
signed int sub_8020894()
{
  return 0x3449B3C0;
}

//----- (0802089C) --------------------------------------------------------
int __fastcall sub_802089C(int a1, unsigned int a2, int a3)
{
  a2 = (unsigned __int8)a2;
  if ( (unsigned __int8)a2 == 1 )
  {
    *(_DWORD *)a3 = 0x20000;
  }
  else if ( (unsigned __int8)a2 >= 1u )
  {
    if ( a2 == 3 )
    {
      *(_DWORD *)a3 = 32;
    }
    else if ( a2 < 3 )
    {
      *(_WORD *)a3 = 512;
    }
  }
  return 0;
}

//----- (080208D8) --------------------------------------------------------
void reset_sdio_periph()
{
  reset_apb2_periph(0x800, 1);
  reset_apb2_periph(0x800, 0);
}

//----- (080208F0) --------------------------------------------------------
void __fastcall something_gnarly_with_sdio_clk(int result)
{
  SDIO_CLKCR = SDIO_CLKCR & 0xFFFF8100 | *(_BYTE *)(result + 20) | *(_DWORD *)(result + 8) | *(_DWORD *)(result + 4) | *(_DWORD *)(result + 12) | *(_DWORD *)result | *(_DWORD *)(result + 16);
}
// 40012C04: using guessed type int SDIO_CLKCR;

//----- (0802091A) --------------------------------------------------------
void __fastcall HAL_set_sdio_clken(unsigned __int8 clken)
{
  v422580A0 = clken;
}

//----- (08020922) --------------------------------------------------------
void __fastcall set_sdio_power_reg(int val)
{
  SDIO_POWER = val;
}
// 40012C00: using guessed type int SDIO_POWER;

//----- (08020928) --------------------------------------------------------
int sdio_power_enabled()
{
  return SDIO_POWER & 3;
}
// 8020928: using guessed type int sdio_power_enabled(void);
// 40012C00: using guessed type int SDIO_POWER;

//----- (08020932) --------------------------------------------------------
void __fastcall sdio_sub_8020932(int result)
{
  v4225858C = (unsigned __int8)result;
}

//----- (0802093A) --------------------------------------------------------
void __fastcall SDIO_SendCommand(SDIO_CMD_ST *cmd)
{
  SDIO_ARG = cmd->CMDARG;
  SDIO_CMD = ((unsigned int)SDIO_CMD >> 11 << 11) | cmd->CMDINDEX | cmd->WAITRESP | cmd->field_C | cmd->CPSMEN;
}
// 40012C08: using guessed type int SDIO_ARG;
// 40012C0C: using guessed type int SDIO_CMD;

//----- (08020962) --------------------------------------------------------
unsigned __int8 get_sdio_respcmd()
{
  return SDIO_RESPCMD;
}
// 40012C10: using guessed type int SDIO_RESPCMD;

//----- (0802096A) --------------------------------------------------------
_DWORD __fastcall read_resp_word(int which)
{
  return *(int *)((char *)SDIO_RESP + which);
}
// 40012C14: using guessed type int SDIO_RESP[4];

//----- (08020980) --------------------------------------------------------
void __fastcall SDIO_DataConfig(int result)
{
  SDIO_DTIMER = *(_DWORD *)result;
  SDIO_DLEN = *(_DWORD *)(result + 4);
  SDIO_DCTRL = SDIO_DCTRL & 0xFFFFFF08 | *(_DWORD *)(result + 8) | *(_DWORD *)(result + 12) | *(_DWORD *)(result + 16) | *(_DWORD *)(result + 20);
}
// 40012C24: using guessed type int SDIO_DTIMER;
// 40012C28: using guessed type int SDIO_DLEN;
// 40012C2C: using guessed type int SDIO_DCTRL;

//----- (080209AE) --------------------------------------------------------
int read_sdio_fifo()
{
  return SDIO_FIFO;
}
// 40012C80: using guessed type int SDIO_FIFO;

//----- (080209B4) --------------------------------------------------------
void __fastcall set_sdio_mask(int bits, char state)
{
  if ( state )
    SDIO_MASK |= bits;
  else
    SDIO_MASK &= ~bits;
}
// 40012C38: using guessed type int SDIO_ICR;
// 40012C3C: using guessed type int SDIO_MASK;

//----- (080209D2) --------------------------------------------------------
bool __fastcall get_sdio_sta(int mask)
{
  return (SDIO_STA & mask) != 0;
}
// 40012C34: using guessed type int SDIO_STA;

//----- (080209EC) --------------------------------------------------------
void __fastcall set_sdio_icr(int val)
{
  SDIO_ICR = val;
}
// 40012C38: using guessed type int SDIO_ICR;

//----- (080209F2) --------------------------------------------------------
bool __fastcall get_sdio_sta_0(int mask)
{
  return (SDIO_STA & mask) != 0;
}
// 40012C34: using guessed type int SDIO_STA;

//----- (08020A0C) --------------------------------------------------------
void __fastcall set_sdio_icr_0(int result)
{
  SDIO_ICR = result;
}
// 40012C38: using guessed type int SDIO_ICR;

//----- (08020A54) --------------------------------------------------------
int __fastcall sub_8020A54(int result, int a2)
{
  *(_DWORD *)result = *(_DWORD *)result & 0xFFFF800F | *(_DWORD *)(a2 + 8) | *(_DWORD *)(a2 + 32) | *(_DWORD *)(a2 + 16) | *(_DWORD *)(a2 + 20) | *(_DWORD *)(a2 + 24) | *(_DWORD *)(a2 + 28) | *(_DWORD *)(a2 + 36) | *(_DWORD *)(a2 + 40);
  *(_DWORD *)(result + 4) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(result + 8) = *(_DWORD *)a2;
  *(_DWORD *)(result + 12) = *(_DWORD *)(a2 + 4);
  return result;
}

//----- (08020A92) --------------------------------------------------------
int __fastcall sub_8020A92(int result, char a2)
{
  if ( a2 )
    *(_DWORD *)result |= 1u;
  else
    *(_DWORD *)result &= 0xFFFEu;
  return result;
}

//----- (08020AAE) --------------------------------------------------------
int __fastcall sub_8020AAE(int result, int a2, char a3)
{
  if ( a3 )
    *(_DWORD *)result |= a2;
  else
    *(_DWORD *)result &= ~a2;
  return result;
}

//----- (08020AC4) --------------------------------------------------------
int __fastcall sub_8020AC4(int result)
{
  if ( result & 0x10000000 )
    v40026404 = result;
  else
    v40026004 = result;
  return result;
}

//----- (08020ADC) --------------------------------------------------------
void fp_set_nan_error()
{
  *fp_get_last_error_ptr() = 33;
}

//----- (08020AE8) --------------------------------------------------------
double __fastcall dp_log_core(double num, int base_sel)
{
  int inexp; // r0@1
  __int16 exponent; // r7@2
  char v4; // zf@2
  double result; // r0@7
  char v6; // cf@14
  double frac_minus_1; // r4@16
  double frac_plus_1; // r0@16
  double v9; // r0@16
  double v10; // kr00_8@16
  double v11; // r0@16
  double v12; // r10@16
  double v13; // r0@16
  double v14; // r0@16
  double v15; // r0@16
  double v16; // r0@16
  double v17; // r0@16
  double v18; // r0@16
  double v19; // r0@16
  double v20; // r0@16
  double v21; // r0@16
  double v22; // r0@16
  double v23; // r0@16
  double v24; // r0@16
  double v25; // r0@16
  double v26; // r0@16
  double kinda_ln_result; // kr08_8@16
  double dexponent; // r0@16
  double dexponent2; // kr10_8@16
  double v30; // r0@17
  double v31; // r0@17
  double v32; // r4@17
  double exp_factor; // r0@17
  double log_result; // r2@17
  double v35; // ST08_8@19
  double v36; // ST00_8@19
  double v37; // r4@19
  double v38; // r0@19
  double v39; // r0@19
  double v40; // r0@19
  double v41; // r4@19
  double v42; // ST00_8@20
  double v43; // r4@20
  double v44; // r0@20
  double v45; // r0@20
  double a; // [sp+10h] [bp-30h]@1
  int v47; // [sp+18h] [bp-28h]@1
  int mode; // [sp+1Ch] [bp-24h]@1

  v47 = HIDWORD(num);
  mode = base_sel;
  a = num;
  inexp = (HIDWORD(num) >> 20) & 0x7FF;
  if ( inexp == 2047 )
  {
    exponent = 0;
    v4 = HIDWORD(a) << 12 == 0;
    if ( !(HIDWORD(a) << 12) )
      v4 = LODWORD(a) == 0;
    if ( !v4 || SHIDWORD(a) >= 0 )
      return a;
  }
  else
  {
    if ( inexp < 1 )
    {
      inexp = dp_normalize(&a);
      if ( inexp >= 1 )
      {
        *fp_get_last_error_ptr() = 34;
        return -1.79769313e308/*-Inf*/;
      }
    }
    HIDWORD(a) = HIDWORD(a) & 0x800FFFFF | 0x3FE00000;// convert input to fraction (between 0 and 1)
    exponent = inexp - 1022;                    // save exponent where 0 = 2^-1
  }
  if ( *(_QWORD *)&a >= 0LL )
  {
    dp_something_0_0(a, 0.707106781);
    if ( !v6 )
    {
      a = dp_mul(2.0, a);
      --exponent;
    }
    frac_minus_1 = dp_add(-1.0, a);             // take ln(frac) using a taylor series representation
    frac_plus_1 = dp_add(1.0, a);
    v9 = dp_div(frac_minus_1, frac_plus_1);
    v10 = v9;
    v11 = dp_mul(v9, v9);
    v12 = v11;
    v13 = dp_mul(0.148219198, v11);
    v14 = dp_add(v13, 0.153109884);             // 2/13
    v15 = dp_mul(v14, v12);
    v16 = dp_add(v15, 0.181837064);             // 2/11
    v17 = dp_mul(v16, v12);
    v18 = dp_add(v17, 0.222221953);             // 2/9
    v19 = dp_mul(v18, v12);
    v20 = dp_add(v19, 0.285714288);             // 2/7
    v21 = dp_mul(v20, v12);
    v22 = dp_add(v21, 0.4);                     // 2/5
    v23 = dp_mul(v22, v12);
    v24 = dp_add(v23, 0.666666667);             // 2/3
    v25 = dp_mul(v24, v12);
    v26 = dp_sub(frac_minus_1, v25);
    kinda_ln_result = dp_mul(v26, v10);
    dexponent = dp_from_int(exponent);
    dexponent2 = dexponent;
    if ( mode )
    {
      if ( mode < 1 )                           // mode == -1 -> base e
      {
        v42 = dp_mul(1.44269502, frac_minus_1);
        v43 = dp_mul(0.0000000192596299, frac_minus_1);
        v44 = dp_mul(1.44269504, kinda_ln_result);
        v45 = dp_sub(v43, v44);
        exp_factor = dp_add(v45, v42);
        log_result = dexponent2;
      }
      else                                      // mode == 1 -> base 10
      {
        v35 = dp_mul(0.434294462, frac_minus_1);
        v36 = dp_mul(0.0000000196992723, frac_minus_1);
        v37 = dp_mul(0.0000000750859783, dexponent2);
        v38 = dp_mul(kinda_ln_result, 0.434294482);
        v39 = dp_sub(v37, v38);
        v40 = dp_add(v39, v36);
        v41 = dp_add(v40, v35);
        exp_factor = dp_mul(0.301029921, dexponent2);
        log_result = v41;
      }
    }
    else                                        // mode == 0 -> base2
    {
      v30 = dp_mul(0.000000117304635, dexponent);
      v31 = dp_sub(v30, kinda_ln_result);
      v32 = dp_add(v31, frac_minus_1);
      exp_factor = dp_mul(0.693147063, dexponent2);
      log_result = v32;
    }
    result = dp_add(exp_factor, log_result);
  }
  else
  {
    *fp_get_last_error_ptr() = 33;
    result = 3.59538627e308/*NaN*/;
  }
  return result;
}

//----- (08020DC0) --------------------------------------------------------
int *__cdecl fp_get_last_error_ptr()
{
  return &fp_last_error;
}

//----- (08020DCC) --------------------------------------------------------
int __fastcall dp_normalize(double *num)
{
  int v1; // r3@1
  unsigned int v2; // r2@1
  int exponent; // r1@1
  char v4; // zf@1
  int v5; // r3@6
  int v6; // r4@7

  v1 = *((_DWORD *)num + 1);
  v2 = v1 & 0x80000000;
  exponent = 1;
  v1 &= 0xFFFFFu;
  v4 = v1 == 0;
  *((_DWORD *)num + 1) = v1;
  if ( !v1 )
    v4 = *(_DWORD *)num == 0;
  if ( !v4 )
  {
    while ( 1 )
    {
      v6 = *((_DWORD *)num + 1);
      if ( v6 & 0x100000 )
        break;
      v5 = *(_DWORD *)num;
      *((_DWORD *)num + 1) = *(_QWORD *)num >> 31;
      *(_DWORD *)num = 2 * v5;
      --exponent;
    }
    *((_DWORD *)num + 1) = v6 & 0xFFFFF;
  }
  *((_DWORD *)num + 1) |= v2;
  return exponent;
}

//----- (08020E10) --------------------------------------------------------
void __fastcall dp_something_0_0(double a, double b)
{
  ;
}

//----- (08020E50) --------------------------------------------------------
void __fastcall TIM2_interrupt()
{
  // the TIM2 interrupt fires every 10ms and is largely
  // responsible for program operation
  TIM_clear_status_bits(&TIM2_0, 1);            // ack tim2 update interrupt
  TIM2_10ms_interrupt = 1;
  if ( logging_active )
  {
    if ( !curr_logging_interval && !auto_hold_is_enabled )
    {
      ++logging_interval_timer_1s;
      if ( (signed int)logging_interval_timer_1s >= 20 )
      {
        logging_interval_timer_1s = 0;
        ++logging_interval_maxspeed_timer_200ms;
        if ( (signed int)(unsigned __int8)logging_interval_maxspeed_timer_200ms < 5 )
          logging_interval_elapsed = 1;
      }
    }
  }
  if ( log_playback_mode )
  {
    ++log_playback_mode_timeout;
    if ( (signed int)(unsigned __int16)log_playback_mode_timeout > 1000 )// 10 seconds
      log_playback_mode_stop();
  }
  if ( meas_diode_reprocess_timer_1s )
    --meas_diode_reprocess_timer_1s;
  if ( (curr_meas_mode == MM_ACuA
     || curr_meas_mode == MM_ACmA
     || curr_meas_mode == MM_ACA
     || curr_meas_mode == MM_DCuA
     || curr_meas_mode == MM_DCmA
     || curr_meas_mode == MM_DCA)
    && curr_sub_mode == SM_SPL1
    || curr_sub_mode == SM_SPL3 )
  {
    if ( burden_active_msg_showing_timer_1s )
    {
      --burden_active_msg_showing_timer_1s;
      if ( !burden_active_msg_showing_timer_1s )
        need_to_update_subscr = 1;
    }
  }
  if ( curr_meas_mode == MM_CAP )
  {
    if ( mes_cap_no_reading_timeout_timer_10ms_unit )
    {
      --mes_cap_no_reading_timeout_timer_10ms_unit;
      if ( !mes_cap_no_reading_timeout_timer_10ms_unit )
        meas_cap_no_reading_timeout_elapsed = 1;
    }
  }
  ++meas_cap_some_other_timer_unused;
  if ( curr_meas_mode == MM_HZ || curr_meas_mode == MM_mSEC || curr_meas_mode == MM_DUTY )
  {
    ++freq_input_timeout_timer_10ms_unit;
    if ( (signed int)(unsigned __int16)freq_input_timeout_timer_10ms_unit > 300 )
    {
      freq_input_timeout_timer_10ms_unit = 0;
      curr_scr_digits = 0;
      if ( !autoranging_disabled )
        curr_meas_range = 0;
      if ( auto_hold_is_enabled )
      {
        auto_hold_holding = 1;
        auto_hold_need_to_unhold = 0;
        TIM2_auto_hold_unhold_timer_1s = 0;
      }
      else
      {
        meas_was_updated = 1;
        meter_range_changed = 1;
      }
    }
  }
  if ( curr_meas_mode == MM_ACuA
    || curr_meas_mode == MM_ACmA
    || curr_meas_mode == MM_ACA
    || curr_meas_mode == MM_ACV
    || curr_meas_mode == MM_ACmV
    || curr_meas_mode == MM_LOW_Z && lowz_measuring_ac )
  {
    ++freq_input_timeout_timer_10ms_unit;
    if ( (signed int)(unsigned __int16)freq_input_timeout_timer_10ms_unit > 500 )
    {
      freq_input_timeout_timer_10ms_unit = 0;
      ac_input_freq_range = 0;
      need_to_update_subscr = 1;
      ac_input_freq = 0;
    }
  }
  if ( auto_hold_is_enabled & (unsigned __int8)(auto_hold_holding ^ 1) )
  {
    ++TIM2_auto_hold_unhold_timer_1s;
    if ( TIM2_auto_hold_unhold_timer_1s == 100 )
    {
      TIM2_auto_hold_unhold_timer_1s = 0;
      auto_hold_need_to_unhold = 1;
    }
  }
  if ( (signed int)(unsigned __int16)TIM2_auto_hold_unhold_timer_1s >= 101 )
    TIM2_auto_hold_unhold_timer_1s = 100;
  ++TIM2_prepare_sample_timer_100ms;
  if ( (unsigned int)TIM2_prepare_sample_timer_100ms >= 10 )
  {
    TIM2_prepare_sample_timer_100ms = 0;
    TIM2_need_to_prepare_sample = 1;
  }
  ++bt_packet_write_timer_250ms;
  if ( (unsigned int)bt_packet_write_timer_250ms >= 25 )
  {
    bt_packet_write_timer_250ms = 0;
    need_to_write_bt_packet = 1;
  }
  ++TIM2_500ms_timer;
  if ( (unsigned int)TIM2_500ms_timer >= 50 )
  {
    TIM2_500ms_timer = 0;
    setup_edit_timeout_subcounter_500ms = 1;
    beep_every_half_second = beep_every_half_second != 1;
    if ( (unsigned __int8)meter_amp_leads_incorrect | (unsigned __int8)meter_overload && beep_every_half_second )
      beep_ms(0x1F4u);
    if ( setup_currently_editing )
    {
      blink_value_being_edited = blink_value_being_edited != 1;
      need_to_update_subscr = 1;
    }
    if ( curr_sub_mode == SM_HOUR_MINUTE )
    {
      blink_dash_for_hour_minute = blink_dash_for_hour_minute != 1;
      show_hour_min_on_subscr(1);
    }
  }
  ++apo_timeout_subtimer_10ms;
  if ( (unsigned int)apo_timeout_subtimer_10ms >= 100 )
  {
    apo_timeout_subtimer_10ms = 0;
    if ( !curr_apo_off && !logging_active )
    {
      --apo_timeout_sec;
      if ( !apo_timeout_sec )
        apo_trigger_poweroff = 1;
    }
  }
}
// 2000021C: using guessed type __int16 apo_timeout_sec;
// 20003858: using guessed type int curr_scr_digits;
// 20003870: using guessed type int ac_input_freq;
// 200039B0: using guessed type int TIM2_prepare_sample_timer_100ms;
// 200039B4: using guessed type int TIM2_500ms_timer;
// 200039B8: using guessed type int apo_timeout_subtimer_10ms;
// 200039BC: using guessed type int bt_packet_write_timer_250ms;
// 20003A62: using guessed type __int16 log_playback_mode_timeout;
// 20003A66: using guessed type __int16 TIM2_auto_hold_unhold_timer_1s;
// 20003A74: using guessed type __int16 freq_input_timeout_timer_10ms_unit;
// 20003A78: using guessed type __int16 mes_cap_no_reading_timeout_timer_10ms_unit;
// 20003A7A: using guessed type __int16 meas_cap_some_other_timer_unused;
// 20003AB6: using guessed type char logging_interval_maxspeed_timer_200ms;
// 20003ADE: using guessed type char apo_trigger_poweroff;
// 20003AE6: using guessed type char autoranging_disabled;
// 20003AEC: using guessed type char meter_range_changed;
// 20003AF2: using guessed type char auto_hold_holding;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B0A: using guessed type char setup_currently_editing;
// 20003B0B: using guessed type char blink_value_being_edited;
// 20003B11: using guessed type char amp_lead_in_ma_jack_only;
// 20003B12: using guessed type char meter_amp_leads_incorrect;
// 20003B13: using guessed type char beep_every_half_second;
// 20003B32: using guessed type char lowz_measuring_ac;
// 20003B3C: using guessed type char meas_cap_no_reading_timeout_elapsed;
// 20003B42: using guessed type char burden_active_msg_showing_timer_1s;
// 20003B49: using guessed type char meter_danger_icon;
// 20003B4A: using guessed type char meter_overload;
// 20003B4C: using guessed type char meas_diode_reprocess_timer_1s;
// 20003B62: using guessed type char TIM2_10ms_interrupt;
// 20003B63: using guessed type char TIM2_need_to_prepare_sample;
// 20003B64: using guessed type char need_to_write_bt_packet;
// 20003B65: using guessed type char setup_edit_timeout_subcounter_500ms;
// 20003B67: using guessed type char blink_dash_for_hour_minute;

//----- (0802123A) --------------------------------------------------------
void __fastcall TIM3_interrupt()
{
  // fires every 1ms
  TIM_clear_status_bits(&TIM3, 1);              // ack timer 3 update interrupt
  TIM3_1ms_interrupt_unused = 1;
  if ( sys_boot_button_delay_timer_1ms_unit )
    --sys_boot_button_delay_timer_1ms_unit;
  if ( beep_timer_1ms )
  {
    --beep_timer_1ms;
    if ( !beep_timer_1ms )
    {
      beep_currently_beeping = 0;
      HIWORD(GPIOE.BSRR) = 128;
      if ( beep_num_beeps )
      {
        beep_timer_1ms = beep_time;
        --beep_num_beeps;
        if ( beep_num_beeps % 2 == 1 )
        {
          beep_currently_beeping = 1;
          LOWORD(GPIOE.BSRR) = 128;
        }
      }
    }
  }
}
// 2000021A: using guessed type __int16 sys_boot_button_delay_timer_1ms_unit;
// 20003A68: using guessed type __int16 beep_timer_1ms;
// 20003A6A: using guessed type __int16 beep_time;
// 20003B14: using guessed type char beep_currently_beeping;
// 20003B61: using guessed type char TIM3_1ms_interrupt_unused;
// 40021000: using guessed type GPIO_REGS GPIOE;

//----- (080212C4) --------------------------------------------------------
void __fastcall USART2_interrupt()
{
  char v0; // r0@4

  if ( sub_8017A08((int)&USART2_1, 1831) )
    sub_8017A76((int)&USART2_1, 1831);
  if ( sub_8017A08((int)&USART2_1, 1317) )
  {
    v0 = sub_801798C((int)&USART2_1);
    bt_rx_buf[(unsigned __int8)bt_rx_buf_curr_pos] = v0;
    sub_8017A76((int)&USART2_1, 1317);
    ++bt_rx_buf_curr_pos;
    if ( (signed int)(unsigned __int8)bt_rx_buf_curr_pos >= 20 )
      bt_rx_buf_curr_pos = 0;
    if ( bt_rx_buf_curr_pos == 1 )
    {
      if ( (unsigned __int8)bt_rx_buf[0] == 244 )
      {
        bt_rx_buf_max_pos = 5;
      }
      else if ( (unsigned __int8)bt_rx_buf[0] == 248 )
      {
        bt_rx_buf_max_pos = 15;
      }
      else
      {
        bt_rx_buf_curr_pos = 0;
      }
    }
    else if ( (unsigned __int8)bt_rx_buf_curr_pos >= (unsigned int)(unsigned __int8)bt_rx_buf_max_pos )
    {
      bt_new_received_msg = 1;
      bt_rx_msg_len = bt_rx_buf_max_pos;
      bt_rx_buf_curr_pos = 0;
    }
  }
}
// 20003AD4: using guessed type char bt_rx_buf_curr_pos;
// 20003AD5: using guessed type char bt_rx_buf_max_pos;
// 20003AD6: using guessed type char bt_rx_msg_len;
// 20003AD7: using guessed type char bt_new_received_msg;

//----- (0802136C) --------------------------------------------------------
void __fastcall SysTick_Handler()
{
  SysTick_Handler_real();
}

//----- (08021374) --------------------------------------------------------
void __fastcall SDIO_interrupt()
{
  SDIO_interrupt_real();
}

//----- (0802137C) --------------------------------------------------------
void __cdecl DMA2_CH4_interrupt()
{
  DMA2_CH4_interrupt_real();
}

//----- (08021384) --------------------------------------------------------
void __fastcall RTC_WKUP_interrupt()
{
  if ( sub_801D030(0x4000u) )
  {
    sub_801D07A(0x4000u);
    exti_ack_int(0x100000);
  }
}

//----- (080213A4) --------------------------------------------------------
void __fastcall EXTI0_interrupt()
{
  if ( exti_int_pending(1) )
    exti_ack_int(1);
}

//----- (080213B8) --------------------------------------------------------
void __fastcall EXTI1_interrupt()
{
  if ( exti_int_pending(2) )
    exti_ack_int(2);
}

//----- (080213CC) --------------------------------------------------------
void __fastcall EXTI2_interrupt()
{
  if ( exti_int_pending(4) )
    exti_ack_int(4);
}

//----- (080213E0) --------------------------------------------------------
void __fastcall EXTI3_interrupt()
{
  if ( exti_int_pending(8) )
    exti_ack_int(8);
}

//----- (080213F4) --------------------------------------------------------
void __fastcall EXTI4_interrupt()
{
  if ( exti_int_pending(16) )
    exti_ack_int(16);
}

//----- (08021408) --------------------------------------------------------
void __fastcall EXTI_9_5_interrupt()
{
  if ( exti_int_pending(32) )
    exti_ack_int(32);
  if ( exti_int_pending(64) )
    exti_ack_int(64);
  if ( exti_int_pending(128) )
    exti_ack_int(128);
  if ( exti_int_pending(256) )
    exti_ack_int(256);
  if ( exti_int_pending(512) )
    exti_ack_int(512);
}

//----- (08021464) --------------------------------------------------------
void __fastcall EXTI_15_10_interrupt()
{
  if ( exti_int_pending(1024) )
    exti_ack_int(1024);
  if ( exti_int_pending(2048) )
    exti_ack_int(2048);
  if ( exti_int_pending(4096) )
    exti_ack_int(4096);
  if ( exti_int_pending(0x2000) )
    exti_ack_int(0x2000);
  if ( exti_int_pending(0x4000) )
    exti_ack_int(0x4000);
  if ( exti_int_pending(0x8000) )
    exti_ack_int(0x8000);
}

//----- (080214E0) --------------------------------------------------------
void __fastcall ADC1_interrupt()
{
  if ( sub_801CA7C((int)&ADC1_BASE, 0x106u) )
    sub_801CAB0((int)&ADC1_BASE, 262);
}
// 40012400: using guessed type ADC_REGS ADC1_BASE;

//----- (080215F0) --------------------------------------------------------
void __noreturn main_loop()
{
  set_vtor_offset(0x8000000, 0x6000);
  config_clock_interrupts_and_gpio();
  load_stuff_from_eeprom_and_init();
  lcd_init(curr_lcd_contrast, 1);
  finish_sys_init_and_handle_boot_buttons();
  while ( 1 )
  {
    hy_read_update_and_do_cap_stuff();
    if ( meas_was_updated )
    {
      meter_process_new_meas();
      if ( curr_meas_mode == MM_LOW_Z )
        meter_process_new_lowz_meas();
      scr_need_to_update_units_in_certain_modes = 1;
    }
    update_display();
    if ( TIM2_10ms_interrupt )
    {
      TIM2_10ms_interrupt = 0;
      read_range_switch_then_update();
      read_buttons_then_update();
      read_amp_lead_pos_then_update();
      hy_change_CTA_val_for_ac_freq();
      subscr_periodically_switch_between_amps_and_volts_for_power();
    }
    if ( TIM2_need_to_prepare_sample )
    {
      TIM2_need_to_prepare_sample = 0;
      rtc_read_time();
      check_on_batt_and_internal_temp();
      log_prepare_sample();
    }
    if ( need_to_write_bt_packet )
    {
      need_to_write_bt_packet = 0;
      if ( bt_enabled )
        build_and_write_bt_packet_also();
    }
    if ( setup_edit_timeout_subcounter_500ms )
    {
      setup_edit_timeout_subcounter_500ms = 0;
      if ( setup_currently_editing )
        end_setup_without_saving_after_2min_timeout();
    }
    if ( rtc_last_read_was_new_second )
    {
      rtc_last_read_was_new_second = 0;
      rtc_read_time();
      logging_interval_maxspeed_timer_200ms = 0;
      if ( logging_active )
      {
        if ( curr_logging_interval )
        {
          if ( !auto_hold_is_enabled )
          {
            ++logging_interval_timer_1s;
            if ( logging_interval_timer_1s >= (unsigned int)curr_logging_interval )
            {
              logging_interval_timer_1s = 0;
              logging_interval_elapsed = 1;
            }
          }
        }
      }
    }
    if ( logging_active & logging_interval_elapsed )
      log_save_sample();
    if ( bt_new_received_msg )
      bt_process_received_msg();
    if ( log_need_to_flush_samples_from_eeprom )
    {
      log_need_to_flush_samples_from_eeprom = 0;
      if ( log_flush_samples_from_eeprom() )
      {
        logging_active = 0;
        turn_off_sd_card();
        log_playback_mode_stop();
      }
    }
    if ( __PAIR__(meter_range_changed, meter_mode_changed) )
    {
      meter_process_range_mode_changed(1);
      if ( curr_meas_mode != MM_HZ
        && curr_meas_mode != MM_mSEC
        && curr_meas_mode != MM_DUTY
        && curr_meas_mode != MM_CAP
        && auto_hold_is_enabled )
      {
        meas_was_updated = 0;
        scr_need_to_refresh_meas_units_and_icons = 0;
        need_to_update_subscr = 0;
        mode_range_just_got_changed_for_hold_purposes = 1;
      }
    }
    if ( apo_trigger_poweroff )
      apo_do_poweroff_then_poweron();
  }
}
// 20000222: using guessed type char curr_lcd_contrast;
// 20003AB6: using guessed type char logging_interval_maxspeed_timer_200ms;
// 20003AC4: using guessed type char log_need_to_flush_samples_from_eeprom;
// 20003AD3: using guessed type char bt_enabled;
// 20003AD7: using guessed type char bt_new_received_msg;
// 20003ADE: using guessed type char apo_trigger_poweroff;
// 20003AEC: using guessed type char meter_range_changed;
// 20003AFC: using guessed type char scr_need_to_refresh_meas_units_and_icons;
// 20003AFD: using guessed type char scr_need_to_update_units_in_certain_modes;
// 20003AFE: using guessed type char need_to_update_subscr;
// 20003B0A: using guessed type char setup_currently_editing;
// 20003B62: using guessed type char TIM2_10ms_interrupt;
// 20003B63: using guessed type char TIM2_need_to_prepare_sample;
// 20003B64: using guessed type char need_to_write_bt_packet;
// 20003B65: using guessed type char setup_edit_timeout_subcounter_500ms;
// 20003B66: using guessed type char rtc_last_read_was_new_second;

//----- (0802179C) --------------------------------------------------------
void load_stuff_from_eeprom_and_init()
{
  rtc_read_time();
  cal_load_factors_for_mode_and_range(MM_INTERNAL_THERMISTOR, 0);
  load_logging_interval();
  load_lcd_contrast();
  load_curr_apo_status();
  load_temp_mode();
  load_hv_diode_mode();
  load_curr_cont_threshold();
  load_burden_display_enabled();
  load_curr_year_month();
  load_meter_serial();
  load_eeprom_sample_count();
  reset_apo_timeout();
  batt_is_low_icon = 0;
  curr_meas_range = 0;
  curr_meas_mode = 0;
  meter_in_cal_mode = 0;
  setting_last_cal_year_month = 0;
  meter_set_default_subscr_mode();
  meter_min_max_mode = 0;
  manual_hold_is_enabled = 0;
  auto_hold_is_enabled = 0;
  rel_meas_enabled = 0;
  input_1ms_peak_enabled = 0;
  input_lpf_enabled = 0;
  high_voltage_diode = 0;
  meter_danger_icon = 0;
  meter_overload = 0;
  meter_mode_acv_dcv = 0;
  measuring_amps_of_va_or_volts_of_burden = 0;
  meas_amp_burden_timer = 0;
  curr_range_switch_bits = 0;
  range_switch_inputs = 0;
  if ( apo_woke_up )
  {
    button_hold_timer = 51;
    button_check_timer = 10;
  }
  bt_new_rxed_button = 0;
  bt_pressed_keycode = 0;
  maybe_refresh_lcd_contrast_register();
}
// 20003ADC: using guessed type char apo_woke_up;
// 20003ADF: using guessed type char batt_is_low_icon;
// 20003AF5: using guessed type char rel_meas_enabled;
// 20003B05: using guessed type char bt_new_rxed_button;
// 20003B0E: using guessed type char button_hold_timer;
// 20003B0F: using guessed type char button_check_timer;
// 20003B24: using guessed type char meter_in_cal_mode;
// 20003B25: using guessed type char setting_last_cal_year_month;
// 20003B49: using guessed type char meter_danger_icon;
// 20003B4A: using guessed type char meter_overload;
// 20003B4B: using guessed type char high_voltage_diode;
// 20003B4F: using guessed type char input_1ms_peak_enabled;
// 20003B51: using guessed type char input_lpf_enabled;
// 20003B52: using guessed type char meter_mode_acv_dcv;
// 20003B59: using guessed type char measuring_amps_of_va_or_volts_of_burden;
// 20003B5A: using guessed type char meas_amp_burden_timer;

//----- (08021872) --------------------------------------------------------
void apo_do_poweroff_then_poweron(void)
{
  apo_trigger_poweroff = 0;
  bt_enabled = 0;
  apo_prepare_to_turn_off();
  WFI_or_WFE(1, 2);
  apo_woke_up = 1;
  config_clock_interrupts_and_gpio();
  load_stuff_from_eeprom_and_init();
  lcd_init(curr_lcd_contrast, 1);
  finish_sys_init_and_handle_boot_buttons();
}
// 20000222: using guessed type char curr_lcd_contrast;
// 20003AD3: using guessed type char bt_enabled;
// 20003ADC: using guessed type char apo_woke_up;
// 20003ADE: using guessed type char apo_trigger_poweroff;

//----- (08021E9C) --------------------------------------------------------
void __fastcall SystemInit()
{
  RCC_CR |= 0x100u;                             // switch MSI on
  RCC_CFGR &= 0x88FFC00C;                       // * set MSI as system clock
                                                // * set AHB prescaler to SYSCLK/1
                                                // * set APB1 prescaler to HCLK/1
                                                // * set APB2 prescaler to HCLK/1
                                                // * disable output clock
                                                // * set output clock prescaler to /1
  RCC_CR &= 0xEEFEFFFE;                         // * turn off HSI
                                                // * turn off HSE
                                                // * turn off PLL
                                                // * turn off clock security system
  RCC_CR &= 0xFFFBFFFF;                         // * turn off HSE oscillator bypass
  RCC_CFGR &= 0xFF02FFFF;                       // * set PLLSRC to HSI
                                                // * set PLLMUL to x3
                                                // * set PLLDIV to 0, not allowed
  RCC_CIR = 0;                                  // disable all clock interrupts
  setup_system_from_reset_continued();
  SCB_VTOR = 0x8000000;                         // set interrupt table address to start of FLASH
}
// 40023808: using guessed type int RCC_CFGR;
// 4002380C: using guessed type int RCC_CIR;
// E000ED08: using guessed type int SCB_VTOR;

//----- (08021EEE) --------------------------------------------------------
void setup_system_from_reset_continued()
{
  int hse_timeout; // [sp+4h] [bp-4h]@1

  hse_timeout = 0;
  RCC_CR |= 0x10000u;                           // switch on HSE
  do                                            // wait for HSE to become ready
    ++hse_timeout;
  while ( !(RCC_CR & 0x20000) && hse_timeout != 20480 );
  if ( ((RCC_CR & 0x20000) != 0) == 1 )         // if it became ready
  {
    FLASH_ACR |= 4u;                            // enable 64 bit flash access
    FLASH_ACR |= 2u;                            // enable flash prefetch
    FLASH_ACR |= 1u;                            // set flash latency to one wait state
    RCC_APB1ENR |= 0x10000000u;                 // enable clock to PWR interface
    PWR_CR = 0x800;                             // set voltage scaling range to 1 (1.8V)
    while ( PWR_CSR & 0x10 )                    // wait for voltage scaling change to take effect
      ;
    RCC_CFGR &= 0xFF02FFFF;                     // * set PLLSRC to HSI
                                                // * set PLLMUL to x3
                                                // * set PLLDIV to 0, not allowed
    RCC_CFGR |= 0x910000u;                      // * set PLLSRC to HSE
                                                // * set PLLMUL to x12
                                                // * set PLLDIV to /3
                                                // resulting output 4 * 12 / 3 MHz = 16MHz
    RCC_CR |= 0x1000000u;                       // switch on PLL
    while ( !(RCC_CR & 0x2000000) )             // wait for PLL to become ready
      ;
    RCC_CFGR = 4 * ((unsigned int)RCC_CFGR >> 2);// set SYSCLK to PLL output
    RCC_CFGR |= 3u;
    while ( (RCC_CFGR & 0xC) != 12 )            // wait for switch to be active
      ;
  }
}
// 40007000: using guessed type int PWR_CR;
// 40007004: using guessed type int PWR_CSR;
// 40023804: using guessed type int RCC_ICSCR;
// 40023808: using guessed type int RCC_CFGR;
// 40023820: using guessed type int RCC_APB2ENR;
// 40023824: using guessed type int RCC_APB1ENR;
// 40023C00: using guessed type int FLASH_ACR;

//----- (08022710) --------------------------------------------------------
int call_funcs_in_init_func_table()
{
  int (**i)(); // r1@1
  int result; // r0@2

  for ( i = &init_func_table; (_BYTE *)i != ascii_to_segs_tbl_uppercase; i = (int (**)())result )
    result = ((int (__fastcall *)(_DWORD))((char *)i + (_DWORD)*i))(i + 1);
  return result;
}
// 8022710: using guessed type int call_funcs_in_init_func_table(void);
// 80227A4: using guessed type int (*init_func_table)();
// 80227B0: using guessed type int dword_80227B0;

//----- (08022832) --------------------------------------------------------
signed int should_call_funcs_in_init_func_table()
{
  return 1;
}

//----- (08022836) --------------------------------------------------------
void __noreturn unused_sub_8022836()
{
  unused_sub_8022848();
}

//----- (08022848) --------------------------------------------------------
void __noreturn unused_sub_8022848()
{
  while ( 1 )
    __breakpoint(171);
}

//----- (08022880) --------------------------------------------------------
void reset_vector()
{
  SystemInit();
  if ( should_call_funcs_in_init_func_table() )
    call_funcs_in_init_func_table();
  main_loop();
}
// 8022710: using guessed type int call_funcs_in_init_func_table(void);

// ALL OK, 705 function(s) have been successfully decompiled
